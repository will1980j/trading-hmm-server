<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Trading Analytics</title>
    <link rel="stylesheet" href="/style_preload.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-selection.v3.min.js"></script>
    <script src="https://d3js.org/d3-scale.v4.min.js"></script>
    <script src="https://d3js.org/d3-axis.v3.min.js"></script>
    <script src="https://d3js.org/d3-shape.v3.min.js"></script>
    <script src="https://d3js.org/d3-zoom.v3.min.js"></script>
    <script src="https://d3js.org/d3-brush.v3.min.js"></script>
    <script src="https://d3js.org/d3-transition.v3.min.js"></script>
    <script src="d3_charts.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js" crossorigin="anonymous"></script>
    <script defer src="api_integration.js"></script>
    <script defer src="notification_system.js"></script>
    <script defer src="professional_styles.js"></script>
    <script defer src="ai_chat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --accent-color: #00ff88;
            --glass-bg: rgba(255,255,255,0.08);
            --glass-border: rgba(255,255,255,0.1);
            --shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            margin: 0;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        /* Theme Styles */
        .theme-gradient {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
        }
        
        .theme-dark {
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            color: #e0e0e0;
        }
        
        .theme-minimal {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #212529;
        }
        
        .theme-minimal .navbar {
            background: rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .theme-minimal .nav-link {
            color: #495057;
            background: rgba(0,0,0,0.03);
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .theme-minimal .nav-link:hover {
            background: rgba(0,0,0,0.08);
            color: #212529;
        }
        
        .theme-minimal .nav-link.active {
            color: #007bff;
            background: rgba(0,123,255,0.1);
            border-color: rgba(0,123,255,0.2);
        }
        
        .theme-minimal .header,
        .theme-minimal .controls,
        .theme-minimal .metric-card,
        .theme-minimal .chart-container,
        .theme-minimal .calendar-day {
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            color: #212529;
        }
        
        .theme-minimal .chart-container h3,
        .theme-minimal .metric-label,
        .theme-minimal .calendar-date,
        .theme-minimal .calendar-stats,
        .theme-minimal .filter-group label {
            color: #495057;
        }
        
        .theme-minimal .positive { color: #28a745; }
        .theme-minimal .negative { color: #dc3545; }
        .theme-minimal .neutral { color: #ffc107; }
        
        .market-widget {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 8px;
            min-width: 100px;
            transition: all 0.3s ease;
        }
        
        .market-widget:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .market-name {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .market-status {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-bottom: 5px;
        }
        
        .market-open {
            background: rgba(0,255,136,0.2);
            color: #00ff88;
        }
        
        .market-closed {
            background: rgba(255,71,87,0.2);
            color: #ff4757;
        }
        
        .market-timer {
            font-size: 11px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(0,255,136,0.3); }
            50% { box-shadow: 0 0 25px rgba(0,255,136,0.8); }
        }
        
        .market-widget.open {
            animation: glow 2s infinite;
            border: 1px solid rgba(0,255,136,0.3);
        }
        
        .market-status.market-open {
            animation: pulse 2s infinite;
        }
        
        .theme-minimal .theme-select {
            background: rgba(255,255,255,0.9);
            color: #495057;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .theme-neon {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            color: #00ff88;
        }
        
        .theme-gold {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2416 100%);
            color: #f4e4bc;
        }
        
        .navbar {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 15px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .nav-link {
            color: rgba(255,255,255,0.8);
            text-decoration: none;
            padding: 10px 18px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .nav-link.active {
            color: #00ff88;
            background: rgba(0,255,136,0.15);
            border-color: rgba(0,255,136,0.3);
        }
        
        .theme-select {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        .theme-select option {
            background: #2a2a2a;
            color: white;
        }
        
        .theme-minimal .theme-select {
            background: rgba(255,255,255,0.9);
            color: #495057;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .theme-minimal .theme-select option {
            background: white;
            color: #495057;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 30px;
            background: rgba(255,255,255,0.08);
            border-radius: 20px;
            backdrop-filter: blur(20px);
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00d4aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .theme-minimal .header h1 {
            background: linear-gradient(45deg, #007bff, #0056b3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            display: flex;
            gap: 25px;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.08);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .session-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .session-checkboxes label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .session-checkboxes input[type="checkbox"] {
            width: auto;
            padding: 0;
        }
        
        .filter-group label {
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        select, input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 14px;
        }
        
        select option {
            background: white;
            color: #333;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.08);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            height: auto;
            min-height: 480px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .chart-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }
        
        .chart-container h3 {
            font-weight: 600;
            margin-bottom: 15px;
            color: rgba(255,255,255,0.9);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .advanced-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .metric-section {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .ai-insight {
            background: linear-gradient(45deg, rgba(0,255,136,0.1), rgba(0,212,170,0.1));
            border: 1px solid rgba(0,255,136,0.2);
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .loading {
            opacity: 0.6;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .metric-section h3 {
            margin-bottom: 15px;
            color: #00ff88;
        }
        
        .risk-metrics, .monte-carlo {
            display: grid;
            gap: 10px;
        }
        
        .risk-item, .mc-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .metric-card {
            background: rgba(255,255,255,0.08);
            border-radius: 18px;
            padding: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
            background: rgba(255,255,255,0.12);
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: 700;
            margin: 10px 0;
            background: linear-gradient(45deg, var(--accent-color), #00d4aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .theme-minimal .metric-value {
            background: linear-gradient(45deg, #007bff, #0056b3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .metric-label {
            font-size: 0.8em;
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        .positive { color: #00ff88; }
        .negative { color: #ff4757; }
        .neutral { color: #ffa502; }
        
        .data-input {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }
        
        .input-labels {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .input-labels span {
            font-size: 12px;
            opacity: 0.8;
            text-align: center;
        }
        
        .input-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin: 5px 0 15px 0;
        }
        
        .btn {
            background: linear-gradient(45deg, var(--accent-color), #00d4aa);
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 14px;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0,255,136,0.2);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,255,136,0.4);
            background: linear-gradient(45deg, #00d4aa, var(--accent-color));
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .trades-table th,
        .trades-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .trades-table th {
            background: rgba(255,255,255,0.1);
            font-weight: bold;
        }
        
        .r-columns {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            font-size: 12px;
        }
        
        .r-value {
            padding: 2px 5px;
            border-radius: 3px;
            text-align: center;
        }
        
        /* Modern Calendar Heatmap Styles */
        .calendar-heatmap {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .calendar-months {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .calendar-month {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .calendar-month-label {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255,255,255,0.8);
            margin-bottom: 5px;
        }
        
        .calendar-weeks {
            display: flex;
            gap: 3px;
        }
        
        .calendar-week {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .calendar-day-heatmap {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .calendar-day-heatmap:hover {
            transform: scale(1.3);
            border: 1px solid rgba(255,255,255,0.4);
            z-index: 10;
            position: relative;
        }
        
        .calendar-day-heatmap.no-data {
            background: rgba(255,255,255,0.05);
        }
        
        .calendar-day-heatmap.profit-1 { background: rgba(0, 255, 136, 0.2); }
        .calendar-day-heatmap.profit-2 { background: rgba(0, 255, 136, 0.4); }
        .calendar-day-heatmap.profit-3 { background: rgba(0, 255, 136, 0.6); }
        .calendar-day-heatmap.profit-4 { background: rgba(0, 255, 136, 0.8); }
        .calendar-day-heatmap.profit-5 { background: rgba(0, 255, 136, 1.0); }
        
        .calendar-day-heatmap.loss-1 { background: rgba(255, 71, 87, 0.2); }
        .calendar-day-heatmap.loss-2 { background: rgba(255, 71, 87, 0.4); }
        .calendar-day-heatmap.loss-3 { background: rgba(255, 71, 87, 0.6); }
        .calendar-day-heatmap.loss-4 { background: rgba(255, 71, 87, 0.8); }
        .calendar-day-heatmap.loss-5 { background: rgba(255, 71, 87, 1.0); }
        
        .calendar-day-heatmap.breakeven { background: rgba(255, 165, 2, 0.5); }
        
        .calendar-legend {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: rgba(255,255,255,0.7);
        }
        
        .calendar-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .calendar-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        /* Traditional Calendar Styles */
        .calendar-day {
            background: var(--glass-bg);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            font-size: 12px;
            min-height: 85px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
            box-shadow: var(--shadow);
        }
        
        .calendar-day:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }
        
        .calendar-profitable { background: rgba(0, 255, 136, 0.3); }
        .calendar-loss { background: rgba(255, 71, 87, 0.3); }
        .calendar-breakeven { background: rgba(255, 165, 2, 0.3); }
        
        .calendar-date { font-weight: bold; margin-bottom: 4px; }
        .calendar-stats { font-size: 10px; opacity: 0.9; }
        
        /* Calendar Tooltip */
        .calendar-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .tooltip {
            position: relative;
            cursor: help;
        }
        
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
            max-width: 300px;
            white-space: normal;
            width: max-content;
        }
        
        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* News Ticker Animation */
        @keyframes scroll {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }
        
        /* Market Data Styling */
        .positive { color: #00ff88; }
        .negative { color: #ff4757; }
        .neutral { color: #ffa502; }
        
        .bias-long { background: rgba(0,255,136,0.2) !important; color: #00ff88; }
        .bias-short { background: rgba(255,71,87,0.2) !important; color: #ff4757; }
        .bias-neutral { background: rgba(255,165,0,0.2) !important; color: #ffa502; }
        
        /* AI Analysis Formatting */
        .ai-analysis-formatted {
            font-family: 'Inter', sans-serif;
        }
        
        .ai-loading {
            opacity: 0.7;
            font-style: italic;
        }

        /* Chat Widget Styles */
        .chat-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .chat-toggle {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }

        .chat-toggle:hover {
            transform: scale(1.1);
        }

        .chat-toggle i {
            color: white;
            font-size: 24px;
        }

        .chat-container {
            position: absolute;
            bottom: 70px;
            right: 0;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .chat-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
        }

        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .chat-message {
            margin-bottom: 15px;
        }

        .chat-message.user .message-content {
            background: #667eea;
            color: white;
            padding: 10px 15px;
            border-radius: 18px 18px 5px 18px;
            margin-left: 50px;
            word-wrap: break-word;
        }

        .chat-message.ai .message-content {
            background: white;
            color: #333;
            padding: 10px 15px;
            border-radius: 18px 18px 18px 5px;
            margin-right: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            word-wrap: break-word;
        }

        .chat-input {
            padding: 15px;
            background: white;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
        }

        .chat-input button {
            width: 40px;
            height: 40px;
            background: #667eea;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-input button:hover {
            background: #5a6fd8;
        }
    </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" referrerpolicy="no-referrer"/>
</head>
<body>
    <nav class="navbar">
        <div style="display: flex; justify-content: space-between; align-items: center;">

            <div style="display: flex; gap: 15px; align-items: center; justify-content: center; flex: 1;">
                <select id="styleSelector" onchange="changeStyle()" class="theme-select">
                    <option value="slate">Slate</option>
                    <option value="charcoal">Charcoal</option>
                    <option value="navy">Navy</option>
                    <option value="graphite">Graphite</option>
                    <option value="midnight">Midnight</option>
                    <option value="steel">Steel</option>
                    <option value="carbon">Carbon</option>
                    <option value="obsidian">Obsidian</option>
                    <option value="onyx">Onyx</option>
                    <option value="platinum">Platinum</option>
                    <option value="arctic">Arctic</option>
                </select>
                <a class="active nav-link" data-route="dashboard" href="/dashboard">Dashboard</a>
                <a class="nav-link" data-route="trade-manager" href="/trade-manager">Trade Manager</a>
                <a class="nav-link" data-route="signal-analysis-lab" href="/signal-analysis-lab" style="color: white !important;">Signal Lab</a>
                <a class="nav-link" data-route="prop-portfolio" href="/prop-portfolio">Prop Portfolio</a>
                <a class="nav-link" data-route="financial-summary" href="/financial-summary">Financial Summary</a>
                <a class="nav-link" data-route="reporting-hub" href="/reporting-hub">Reporting Hub</a>
                <a class="nav-link" data-route="tradingview" href="/tradingview">TradingView</a>
                <a class="nav-link" data-route="styles" href="/styles">Styles</a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>Analytics Dashboard</h1>
            <p>Dynamic Equity Curve with Session & R-Target Filtering</p>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px;">
                <div style="text-align: left;">
                    <div style="font-size: 14px; opacity: 0.8;">Current Time</div>
                    <div id="currentDateTime" style="font-size: 18px; font-weight: 600;">Loading...</div>
                </div>
                <div id="marketStatus" style="display: flex; gap: 15px;">Loading markets...</div>
            </div>
        </div>
        
        <!-- Real-Time News Ticker -->
        <div style="background: linear-gradient(135deg, rgba(0,123,255,0.1), rgba(0,86,179,0.1)); border: 1px solid rgba(0,123,255,0.2); border-radius: 15px; padding: 20px; margin-bottom: 25px; overflow: hidden;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <h3 style="color: #007bff; margin: 0; display: flex; align-items: center; gap: 10px;">
                    📈 Live Market Feed
                    <span style="font-size: 12px; background: rgba(0,123,255,0.2); padding: 2px 8px; border-radius: 10px; font-weight: normal;">Real-Time</span>
                </h3>
                <div id="futuresData" style="display: flex; gap: 15px; font-size: 12px; font-weight: 600;">Loading futures...</div>
            </div>
            <div id="newsTicker" style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; height: 60px; overflow: hidden; position: relative;">
                <div id="tickerContent" style="white-space: nowrap; animation: scroll 60s linear infinite; color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.4;">
                    Loading market news...
                </div>
            </div>
        </div>
        
        <!-- AI Market Intelligence -->
        <div style="background: linear-gradient(135deg, rgba(255,165,0,0.1), rgba(255,140,0,0.1)); border: 1px solid rgba(255,165,0,0.3); border-radius: 15px; padding: 20px; margin-bottom: 25px;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <h3 style="color: #ffa500; margin: 0; display: flex; align-items: center; gap: 10px;">
                    🤖 AI Market Intelligence
                    <span style="font-size: 12px; background: rgba(255,165,0,0.2); padding: 2px 8px; border-radius: 10px; font-weight: normal;">GPT-4o Powered</span>
                </h3>
                <div id="marketBias" style="font-size: 14px; font-weight: 600; padding: 4px 12px; border-radius: 6px; background: rgba(255,255,255,0.1);">ANALYZING...</div>
            </div>
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
                <div>
                    <div id="aiMarketAnalysis" style="font-size: 13px; line-height: 1.5; margin-bottom: 15px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; min-height: 80px;">
                        <div class="ai-loading">🔄 ICT AI analyzing 1H bias, session structure, and FVG opportunities...</div>
                    </div>
                    <div id="marketAlerts" style="font-size: 12px; background: rgba(255,71,87,0.1); border: 1px solid rgba(255,71,87,0.3); border-radius: 6px; padding: 10px; min-height: 40px;">
                        <strong>Setup Alerts:</strong> <span id="alertsList">Monitoring for pivot sweeps and FVG formations...</span>
                    </div>
                </div>
                <div>
                    <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
                        <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">NQ KEY LEVELS</div>
                        <div id="keyLevels" style="font-size: 13px; line-height: 1.4;">
                            <div><strong>Resistance:</strong> <span id="resistanceLevels">Loading...</span></div>
                            <div><strong>Support:</strong> <span id="supportLevels">Loading...</span></div>
                            <div><strong>Pivot:</strong> <span id="pivotLevel">Loading...</span></div>
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="font-size: 11px; opacity: 0.8;">AI CONFIDENCE</div>
                            <div id="aiConfidence" style="font-size: 16px; font-weight: 600; color: #00ff88;">75%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Economic News & AI Analysis -->
        <div style="background: linear-gradient(135deg, rgba(138,43,226,0.1), rgba(75,0,130,0.1)); border: 1px solid rgba(138,43,226,0.3); border-radius: 15px; padding: 20px; margin-bottom: 25px;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <h3 style="color: #8a2be2; margin: 0; display: flex; align-items: center; gap: 10px;">
                    📊 Economic Intelligence
                    <span style="font-size: 12px; background: rgba(138,43,226,0.2); padding: 2px 8px; border-radius: 10px; font-weight: normal;">AI Powered</span>
                </h3>
                <div id="economicImpact" style="font-size: 14px; font-weight: 600; padding: 4px 12px; border-radius: 6px; background: rgba(255,255,255,0.1);">NEUTRAL</div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">TODAY'S ECONOMIC EVENTS</div>
                    <div id="economicEvents" style="font-size: 12px; line-height: 1.4; margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; min-height: 60px;">
                        <div class="ai-loading">Loading economic calendar...</div>
                    </div>
                </div>
                <div>
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">AI ECONOMIC ANALYSIS</div>
                    <div id="aiEconomicAnalysis" style="font-size: 12px; line-height: 1.4; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; min-height: 60px;">
                        <div class="ai-loading">Analyzing economic impact on NQ futures...</div>
                    </div>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px; font-weight: 600;">KEY ECONOMIC RISKS</div>
                <div id="economicRisks" style="font-size: 12px; line-height: 1.3;">Monitoring Fed policy, inflation data, and employment trends...</div>
            </div>
        </div>
        
        <!-- Strategy Overview Panel -->
        <div style="background: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(0,212,170,0.1)); border: 1px solid rgba(0,255,136,0.2); border-radius: 15px; padding: 20px; margin-bottom: 25px;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <h3 style="color: #00ff88; margin: 0; display: flex; align-items: center; gap: 10px;">
                    🎯 ICT Liquidity Grab Strategy
                    <span style="font-size: 12px; background: rgba(0,255,136,0.2); padding: 2px 8px; border-radius: 10px; font-weight: normal;">Active System</span>
                </h3>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">BIAS DETERMINATION</div>
                    <div style="font-size: 13px; line-height: 1.4;">
                        • <strong>1H FVG/IFVG</strong> respect/violation<br>
                        • Color-coded bias indicator<br>
                        • Session structure confirmation
                    </div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">ENTRY CRITERIA</div>
                    <div style="font-size: 13px; line-height: 1.4;">
                        • <strong>1min pivot sweep</strong> completion<br>
                        • <strong>FVG/IFVG formation</strong> confirmation<br>
                        • Entry at gap top/bottom
                    </div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px; font-weight: 600;">RISK MANAGEMENT</div>
                    <div style="font-size: 13px; line-height: 1.4;">
                        • <strong>SL:</strong> Below/above FVG base<br>
                        • <strong>BE:</strong> 1:1 risk/reward<br>
                        • <strong>TP:</strong> Testing R-targets
                    </div>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid #00ff88;">
                <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">STRATEGY NOTES</div>
                <div style="font-size: 13px; font-weight: 500;">High-frequency NQ scalping using ICT concepts. Multiple setups per session targeting liquidity grabs with precise FVG-based entries and tight risk management.</div>
            </div>
        </div>
        
        <div class="controls" style="margin-bottom: 20px;">
            <div style="background: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(0,212,170,0.1)); border: 1px solid rgba(0,255,136,0.2); border-radius: 15px; padding: 20px; margin-bottom: 25px;">
                <h3 style="color: #00ff88; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    AI Strategy Intelligence
                    <span style="font-size: 12px; background: rgba(0,255,136,0.2); padding: 2px 8px; border-radius: 10px; font-weight: normal;">Live Analysis</span>
                </h3>
                <div id="strategySummary" style="font-size: 14px; line-height: 1.6; margin-bottom: 15px; color: rgba(255,255,255,0.9);">Initializing comprehensive strategy analysis...</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 15px;">
                    <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">SYSTEM HEALTH</div>
                        <div id="systemHealth" style="font-size: 16px; font-weight: 600; color: #00ff88;">Analyzing...</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">ADAPTATION SCORE</div>
                        <div id="adaptationScore" style="font-size: 16px; font-weight: 600; color: #ffa502;">Learning...</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">NEXT ACTION</div>
                        <div id="nextAction" style="font-size: 16px; font-weight: 600; color: #3742fa;">Processing...</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid #00ff88;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">STRATEGIC RECOMMENDATION</div>
                    <div id="strategicRecommendation" style="font-size: 13px; font-weight: 500;">Analyzing your trading patterns and market conditions...</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="filter-group">
                <label>Data Source</label>
                <select id="dataSourceToggle" onchange="switchDataSource()" style="padding: 8px 12px; border-radius: 8px; background: rgba(255,255,255,0.9); color: #333; font-size: 14px; font-weight: 600;">
                    <option value="trade-manager">📊 Trade Manager</option>
                    <option value="signal-lab">🔬 Signal Lab</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Session Filter</label>
                <div class="session-checkboxes">
                    <label><input type="checkbox" id="sessionAll" checked onchange="toggleAllSessions()"> All</label>
                    <label><input type="checkbox" class="session-filter" value="ASIA" onchange="updateCharts()"> Asia</label>
                    <label><input type="checkbox" class="session-filter" value="LONDON" onchange="updateCharts()"> London</label>
                    <label><input type="checkbox" class="session-filter" value="NY PRE MARKET" onchange="updateCharts()"> NY Pre</label>
                    <label><input type="checkbox" class="session-filter" value="NEW YORK AM" onchange="updateCharts()"> NY AM</label>
                    <label><input type="checkbox" class="session-filter" value="NY LUNCH" onchange="updateCharts()"> NY Lunch</label>
                    <label><input type="checkbox" class="session-filter" value="NEW YORK PM" onchange="updateCharts()"> NY PM</label>
                </div>
            </div>
            
            <div class="filter-group">
                <label>R Target</label>
                <select id="rTargetFilter" onchange="updateCharts()">
                    <option value="1">1R Target</option>
                    <option value="2">2R Target</option>
                    <option value="3">3R Target</option>
                    <option value="4">4R Target</option>
                    <option value="5">5R Target</option>
                    <option value="6">6R Target</option>
                    <option value="7">7R Target</option>
                    <option value="8">8R Target</option>
                    <option value="9">9R Target</option>
                    <option value="10">10R Target</option>
                    <option value="11">11R Target</option>
                    <option value="12">12R Target</option>
                    <option value="13">13R Target</option>
                    <option value="14">14R Target</option>
                    <option value="15">15R Target</option>
                    <option value="16">16R Target</option>
                    <option value="17">17R Target</option>
                    <option value="18">18R Target</option>
                    <option value="19">19R Target</option>
                    <option value="20">20R Target</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Bias Filter</label>
                <select id="biasFilter" onchange="updateCharts()">
                    <option value="ALL">All Bias</option>
                    <option value="LONG">Long</option>
                    <option value="SHORT">Short</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Include Breakeven</label>
                <select id="breakevenFilter" onchange="updateCharts()">
                    <option value="true">Include BE</option>
                    <option value="false">Exclude BE</option>
                </select>
            </div>
        </div>
        
        <div class="metrics-grid">
            <div class="metric-card tooltip" data-tooltip="Total number of trades in your dataset. More trades = more reliable statistics.">
                <div class="metric-label">Total Trades</div>
                <div class="metric-value" id="filteredTrades">0</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Percentage of winning trades. Good: >50%, Excellent: >60%. Includes breakeven trades as wins.">
                <div class="metric-label">Win Rate</div>
                <div class="metric-value positive" id="filteredWinRate">0%</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Gross profit ÷ gross loss. Good: >1.25, Excellent: >2.0. Measures how much you make vs lose.">
                <div class="metric-label">Profit Factor</div>
                <div class="metric-value" id="profitFactor">0.00</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Average R per trade. Positive = profitable system. Good: >0.2R, Excellent: >0.5R.">
                <div class="metric-label">Expectancy</div>
                <div class="metric-value" id="expectancy">0.00R</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Risk-adjusted return. Good: >1.0, Excellent: >2.0. Higher = better return per unit of risk.">
                <div class="metric-label">Sharpe Ratio</div>
                <div class="metric-value" id="sharpeRatio">0.00</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Largest peak-to-trough loss. Lower is better. Good: <10R, Acceptable: <20R.">
                <div class="metric-label">Max Drawdown</div>
                <div class="metric-value negative" id="maxDrawdown">0.00R</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Total return ÷ max drawdown. Good: >2.0, Excellent: >5.0. Measures profit vs worst loss.">
                <div class="metric-label">Recovery Factor</div>
                <div class="metric-value" id="recoveryFactor">0.00</div>
            </div>
            <div class="metric-card tooltip" data-tooltip="Optimal position size based on win rate and avg win/loss. Good: 10-25%, Dangerous: >50%.">
                <div class="metric-label">Kelly %</div>
                <div class="metric-value" id="kellyPercent">0.00%</div>
            </div>
        </div>
        
        <div class="advanced-metrics">
            <div class="metric-section">
                <h3>Cyclical & Seasonal Performance</h3>
                <div class="risk-metrics">
                    <div class="risk-item tooltip" data-tooltip="Best performing day of the week. Focus trading on this day for optimal results.">
                        <span>Best Day of Week</span>
                        <span id="bestDayOfWeek" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Current month performance vs historical average. Positive = above average month.">
                        <span>Monthly Seasonality</span>
                        <span id="monthlySeasonality" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Performance in current quarter vs other quarters. Q1=Jan-Mar, Q2=Apr-Jun, etc.">
                        <span>Quarterly Performance</span>
                        <span id="quarterlyPerf" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="30-day rolling expectancy. Shows recent performance trend vs long-term average.">
                        <span>30D Rolling Expectancy</span>
                        <span id="rolling30D" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Average days between profitable trades. Lower = more consistent profits.">
                        <span>Profit Frequency</span>
                        <span id="profitFrequency" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Performance during high volatility periods vs low volatility. Shows market regime preference.">
                        <span>Volatility Regime</span>
                        <span id="volatilityRegime" class="neutral">Loading...</span>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                    <strong>Cyclical Summary:</strong> <span id="cyclicalSummary">Loading seasonal analysis...</span>
                </div>
                <div style="margin-top: 10px; padding: 12px; background: rgba(0,255,136,0.1); border-radius: 8px; border: 1px solid rgba(0,255,136,0.3);">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px; color: #ffffff; font-weight: 600;">🤖 AI Cyclical Analysis:</div>
                    <div id="aiCyclicalAnalysis" style="font-size: 13px; line-height: 1.4; color: #ffffff;">Analyzing seasonal patterns and cyclical performance trends...</div>
                </div>
            </div>
            
            <div class="metric-section">
                <h3>AI Performance Intelligence</h3>
                <div class="risk-metrics">
                    <div class="risk-item tooltip" data-tooltip="AI-detected trading patterns that lead to your biggest winners. Focus on these setups.">
                        <span>Winning Pattern</span>
                        <span id="winningPattern" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI confidence in next trade success based on recent sequence and patterns.">
                        <span>Next Trade Confidence</span>
                        <span id="nextTradeConfidence" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI-suggested optimal R target based on current market conditions and your performance.">
                        <span>Dynamic R-Target</span>
                        <span id="dynamicRTarget" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI behavioral analysis. Green=disciplined, Yellow=caution, Red=emotional trading detected.">
                        <span>Behavioral Score</span>
                        <span id="behavioralScore" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI-recommended position size based on recent performance and risk metrics.">
                        <span>Optimal Position Size</span>
                        <span id="optimalPositionSize" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI prediction of drawdown recovery time based on historical patterns.">
                        <span>Recovery Forecast</span>
                        <span id="recoveryForecast" class="positive">Loading...</span>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,255,136,0.1); border-radius: 8px; border: 1px solid rgba(0,255,136,0.3);">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px; color: #ffffff; font-weight: 600;">Generative AI Strategic Analysis:</div>
                    <div id="aiInsights" style="font-size: 13px; line-height: 1.4; margin-bottom: 12px; color: #ffffff; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">Analyzing trading patterns and market conditions...</div>
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px; color: #ffffff; font-weight: 600;">ML Risk Assessment:</div>
                    <div id="mlRiskAnalysis" style="font-size: 13px; line-height: 1.4; color: #ffffff; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">Processing risk patterns...</div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                    <strong>AI Performance Summary:</strong> <span id="aiPerformanceSummary">Loading comprehensive analysis...</span>
                </div>
            </div>
            
            <div class="metric-section">
                <h3>Advanced Statistical Analysis</h3>
                <div class="risk-metrics">
                    <div class="risk-item tooltip" data-tooltip="Tests if wins/losses are random. Random = good (independent trades), Clustered = psychological patterns, Alternating = unnatural.">
                        <span>Runs Test (Randomness)</span>
                        <span id="runsTest" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Measures if returns are correlated. Near 0 = good (independent), Positive = momentum, Negative = mean reversion.">
                        <span>Autocorrelation (Lag-1)</span>
                        <span id="autocorrelation" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Risk-adjusted excess return. Good: >0.5, Excellent: >1.0. Higher = better return per unit of risk.">
                        <span>Information Ratio</span>
                        <span id="informationRatio" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Drawdown-based risk measure. Lower = better. Good: <5, Acceptable: <10. Measures 'pain' of losses.">
                        <span>Ulcer Index</span>
                        <span id="ulcerIndex" class="negative">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Average loss in worst 5% of cases. Shows your tail risk. Less negative = better risk management.">
                        <span>Expected Shortfall (95%)</span>
                        <span id="expectedShortfall" class="negative">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Longest time to recover from losses. Shorter = better. Good: <30 days, Concerning: >90 days.">
                        <span>Max DD Duration (Days)</span>
                        <span id="maxDDDuration" class="neutral">Loading...</span>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                    <strong>Statistical Summary:</strong> <span id="statisticalSummary">Loading statistical analysis...</span>
                </div>
                <div style="margin-top: 10px; padding: 12px; background: rgba(255,165,2,0.1); border-radius: 8px; border: 1px solid rgba(255,165,2,0.3);">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px; color: #ffffff; font-weight: 600;">📊 AI Statistical Insights:</div>
                    <div id="aiStatisticalInsights" style="font-size: 13px; line-height: 1.4; color: #ffffff;">Processing advanced statistical patterns and correlations...</div>
                </div>
            </div>
            
            <div class="metric-section">
                <h3>AI Performance Insights</h3>
                <div class="risk-metrics">
                    <div class="risk-item tooltip" data-tooltip="R-target with highest expectancy based on your MFE data. Use this target for optimal profits.">
                        <span>Optimal R-Target</span>
                        <span id="optimalRTarget" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Trading session with highest win rate and average return. Focus your trading during this time.">
                        <span>Best Session</span>
                        <span id="bestSession" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Overall risk assessment (0-100). Good: >70, Concerning: <30. Based on recent performance.">
                        <span>Risk Score</span>
                        <span id="riskScore" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Confidence in pattern recognition. Higher = more reliable predictions. Good: >80%.">
                        <span>Pattern Confidence</span>
                        <span id="patternConfidence" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="AI prediction for next trade based on recent patterns. POSITIVE = favorable, CAUTION = be careful.">
                        <span>Next Trade Prediction</span>
                        <span id="nextTradePrediction" class="neutral">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Probability of winning after a loss. High (>70%) = good bounce-back ability, Low (<30%) = losses cluster.">
                        <span>Win After Loss Prob</span>
                        <span id="winAfterLoss" class="positive">Loading...</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Probability of losing after a win. High (>70%) = overconfidence issue, Low (<30%) = good momentum.">
                        <span>Loss After Win Prob</span>
                        <span id="lossAfterWin" class="neutral">Loading...</span>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Markov Chain ML:</div>
                    <div id="markovInsights" style="font-size: 13px; line-height: 1.4; margin-bottom: 10px;">Analyzing trade sequences...</div>
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Generative AI Strategy:</div>
                    <div id="aiRecommendation" style="font-size: 13px; line-height: 1.4; margin-bottom: 10px;">Analyzing your trading patterns...</div>
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Neural Network Prediction:</div>
                    <div id="neuralPrediction" style="font-size: 13px; line-height: 1.4;">Processing behavioral patterns...</div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                    <strong>AI Insights Summary:</strong> <span id="aiInsightsSummary">Loading AI analysis...</span>
                </div>
            </div>
            
            <div class="metric-section">
                <h3>Risk Analysis</h3>
                <div class="risk-metrics">
                    <div class="risk-item tooltip" data-tooltip="Value at Risk - worst expected loss 95% of the time. Less negative = better risk control.">
                        <span>VaR (95%)</span>
                        <span id="var95">0.00R</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Annual return ÷ max drawdown. Good: >1.0, Excellent: >3.0. Measures return vs worst loss.">
                        <span>Calmar Ratio</span>
                        <span id="calmarRatio">0.00</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Like Sharpe but only considers downside risk. Good: >1.0, Excellent: >2.0. Higher = better.">
                        <span>Sortino Ratio</span>
                        <span id="sortinoRatio">0.00</span>
                    </div>
                    <div class="risk-item tooltip" data-tooltip="Longest losing streak. Lower = better risk management. Good: <5, Concerning: >10.">
                        <span>Max Consecutive Losses</span>
                        <span id="maxConsecLosses">0</span>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                    <strong>Risk Summary:</strong> <span id="riskSummary">Loading risk analysis...</span>
                </div>
                <div style="margin-top: 10px; padding: 12px; background: rgba(255,71,87,0.1); border-radius: 8px; border: 1px solid rgba(255,71,87,0.3);">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px; color: #ffffff; font-weight: 600;">⚠️ AI Risk Assessment:</div>
                    <div id="aiRiskAssessment" style="font-size: 13px; line-height: 1.4; color: #ffffff;">Evaluating risk exposure and portfolio vulnerabilities...</div>
                </div>
            </div>
        </div>
        
        <div class="main-grid">
            <div class="chart-container">
                <h3>Trade-by-Trade Equity</h3>
                <div id="d3EquityChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your cumulative profit/loss over time, with each trade adding to or subtracting from your total R. A smooth upward line indicates consistent profitability.
                </div>
                <div style="margin-top: 5px; padding: 12px; background: rgba(0,255,136,0.1); border-radius: 6px; border: 1px solid rgba(0,255,136,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; color: #00ff88;">
                        ICT Performance Analysis
                    </div>
                    <div id="equityAIAnalysis" style="font-size: 12px; line-height: 1.4; color: rgba(255,255,255,0.95);">Analyzing FVG setup quality and liquidity grab performance...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Daily Equity Curve</h3>
                <div id="d3DailyEquityChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your daily profit/loss aggregated by trading day. Shows which days you made or lost money and helps identify daily performance patterns.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(255,165,2,0.1); border-radius: 6px; border: 1px solid rgba(255,165,2,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #ffa502;">📈 AI Pattern Recognition:</div>
                    <div id="dailyAIAnalysis" style="font-size: 12px; line-height: 1.3;">Detecting daily volatility patterns and optimal sizing...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Weekly Equity Curve</h3>
                <div id="d3WeeklyEquityChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your weekly performance over time. Each point represents a week's total profit/loss, helping identify longer-term trends and weekly consistency.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(55,66,250,0.1); border-radius: 6px; border: 1px solid rgba(55,66,250,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #3742fa;">🔮 AI Trend Forecasting:</div>
                    <div id="weeklyAIAnalysis" style="font-size: 12px; line-height: 1.3;">Analyzing weekly momentum and trend sustainability...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Monthly Equity Curve</h3>
                <div id="d3MonthlyEquityChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your monthly performance progression. Shows seasonal patterns and long-term account growth, with each point representing a month's total results.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(255,71,87,0.1); border-radius: 6px; border: 1px solid rgba(255,71,87,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #ff4757;">🎯 AI Seasonal Intelligence:</div>
                    <div id="monthlyAIAnalysis" style="font-size: 12px; line-height: 1.3;">Processing seasonal patterns and monthly forecasts...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>R-Score Distribution</h3>
                <div id="d3RScoreChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> How often you hit different R-multiples. Shows your MFE distribution and helps determine optimal profit targets based on actual trade outcomes.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(0,212,170,0.1); border-radius: 6px; border: 1px solid rgba(0,212,170,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #00d4aa;">⚡ AI Target Optimization:</div>
                    <div id="rScoreAIAnalysis" style="font-size: 12px; line-height: 1.3;">Calculating optimal R-targets from MFE distribution...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Day of Week Performance</h3>
                <div id="d3DayOfWeekChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your average expectancy for each trading day (Monday-Friday). Helps identify which days of the week are most profitable for your strategy.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(255,165,2,0.1); border-radius: 6px; border: 1px solid rgba(255,165,2,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #ffa502;">📅 AI Schedule Optimizer:</div>
                    <div id="dayOfWeekAIAnalysis" style="font-size: 12px; line-height: 1.3;">Identifying optimal trading days and schedule patterns...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Monthly Seasonality</h3>
                <div id="d3SeasonalityChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your average expectancy for each month of the year. Reveals seasonal patterns in your trading performance and market behavior.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(138,43,226,0.1); border-radius: 6px; border: 1px solid rgba(138,43,226,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #8a2be2;">🌍 AI Seasonal Predictor:</div>
                    <div id="seasonalityAIAnalysis" style="font-size: 12px; line-height: 1.3;">Detecting seasonal market cycles and performance patterns...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Rolling 30D Performance</h3>
                <div id="d3RollingChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Your 30-day rolling average expectancy over time. Smooths out daily volatility to show underlying performance trends and momentum.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(0,191,255,0.1); border-radius: 6px; border: 1px solid rgba(0,191,255,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #00bfff;">🚀 AI Momentum Tracker:</div>
                    <div id="rollingAIAnalysis" style="font-size: 12px; line-height: 1.3;">Analyzing momentum strength and trend sustainability...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>Session Performance Heatmap</h3>
                <div id="d3SessionHeatmapChart" style="flex: 1; min-height: 280px; margin-bottom: 15px;"></div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; line-height: 1.4;">
                    <strong>What this shows:</strong> Win rate percentage for each trading session. Helps identify which market sessions (Asia, London, NY) work best for your strategy.
                </div>
                <div style="margin-top: 5px; padding: 10px; background: rgba(255,20,147,0.1); border-radius: 6px; border: 1px solid rgba(255,20,147,0.3);">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 5px; color: #ff1493;">⏰ AI Session Optimizer:</div>
                    <div id="sessionAIAnalysis" style="font-size: 12px; line-height: 1.3;">Optimizing session allocation and timing strategies...</div>
                </div>
            </div>
        </div>
        
        <div class="chart-container" style="grid-column: 1 / -1; height: auto; min-height: 400px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>Trading Performance Calendar</h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <select id="calendarView" onchange="updateCalendarView()" style="padding: 6px 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                        <option value="heatmap">Heatmap View</option>
                        <option value="day">Daily Grid</option>
                        <option value="week">Weekly View</option>
                        <option value="month">Monthly View</option>
                    </select>
                    <select id="calendarYear" onchange="updateCalendarView()" style="padding: 6px 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                        <option value="2024">2024</option>
                        <option value="2023">2023</option>
                    </select>
                </div>
            </div>
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 12px; line-height: 1.4;">
                <strong>Calendar Summary:</strong> <span id="calendarSummary">Loading calendar analysis...</span>
            </div>
            <div id="tradingCalendar" style="padding: 10px; min-height: 300px;"></div>
            <div id="calendarLegend" style="display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 11px;"></div>
        </div>
        

    </div>

    <!-- AI Chat Widget -->
    <div id="aiChatWidget" class="chat-widget">
        <div id="chatToggle" class="chat-toggle">
            <i class="fas fa-comments"></i>
        </div>
        <div id="chatContainer" class="chat-container" style="display: none;">
            <div class="chat-header">
                <span>Trading AI Assistant</span>
                <button id="chatClose" class="chat-close">&times;</button>
            </div>
            <div id="chatMessages" class="chat-messages"></div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Ask about your trading performance...">
                <button id="chatSend"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </div>

    <script>
        window.trades = [];
        
        // Load trades from database
        async function loadTradesFromDB() {
            const dataSource = document.getElementById('dataSourceToggle').value;
            const endpoint = dataSource === 'signal-lab' ? '/api/signals' : '/api/trades';
            
            try {
                const response = await fetch(endpoint);
                const data = await response.json();
                
                if (dataSource === 'signal-lab' && data.signals) {
                    window.trades = data.signals.map(s => ({
                        date: s.created_at ? s.created_at.split('T')[0] : '2024-08-06',
                        bias: s.direction || 'LONG',
                        session: s.session || 'LONDON',
                        breakeven: s.outcome === 'breakeven',
                        rScore: s.r_multiple || null,
                        screenshot: s.screenshot_url || null,
                        r1: s.r_multiple || null, r2: s.r_multiple || null, r3: s.r_multiple || null, r4: s.r_multiple || null, r5: s.r_multiple || null,
                        r6: s.r_multiple || null, r7: s.r_multiple || null, r8: s.r_multiple || null, r9: s.r_multiple || null, r10: s.r_multiple || null,
                        r11: s.r_multiple || null, r12: s.r_multiple || null, r13: s.r_multiple || null, r14: s.r_multiple || null, r15: s.r_multiple || null,
                        r16: s.r_multiple || null, r17: s.r_multiple || null, r18: s.r_multiple || null, r19: s.r_multiple || null, r20: s.r_multiple || null
                    }));
                    console.log('Loaded', window.trades.length, 'signals from Signal Lab');
                } else if (data.trades) {
                    window.trades = data.trades.map(t => ({
                        date: t.created_at ? t.created_at.split('T')[0] : '2024-08-06',
                        bias: t.bias || 'LONG',
                        session: extractSession(t.reason) || 'LONDON',
                        breakeven: extractBreakeven(t.reason),
                        rScore: extractRScore(t.reason),
                        r1: extractRScore(t.reason), r2: extractRScore(t.reason), r3: extractRScore(t.reason), r4: extractRScore(t.reason), r5: extractRScore(t.reason),
                        r6: extractRScore(t.reason), r7: extractRScore(t.reason), r8: extractRScore(t.reason), r9: extractRScore(t.reason), r10: extractRScore(t.reason),
                        r11: extractRScore(t.reason), r12: extractRScore(t.reason), r13: extractRScore(t.reason), r14: extractRScore(t.reason), r15: extractRScore(t.reason),
                        r16: extractRScore(t.reason), r17: extractRScore(t.reason), r18: extractRScore(t.reason), r19: extractRScore(t.reason), r20: extractRScore(t.reason)
                    }));
                    console.log('Loaded', window.trades.length, 'trades from Trade Manager');
                }
            } catch (error) {
                console.error('Failed to load data from database:', error);
            }
        }
        
        function switchDataSource() {
            const dataSource = document.getElementById('dataSourceToggle').value;
            console.log('Switching to data source:', dataSource);
            loadDatabaseData();
        }
        
        // Save signal to database
        async function saveSignalToDB(signal) {
            try {
                const response = await fetch('/api/signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        direction: signal.bias,
                        session: signal.session,
                        outcome: signal.breakeven ? 'breakeven' : (signal.rScore > 0 ? 'win' : 'loss'),
                        r_multiple: signal.rScore,
                        screenshot_url: signal.screenshot || null,
                        created_at: signal.date
                    })
                });
                
                if (response.ok) {
                    console.log('Signal saved to database');
                    return await response.json();
                } else {
                    console.error('Failed to save signal:', response.statusText);
                }
            } catch (error) {
                console.error('Error saving signal:', error);
            }
        }
        
        // Update signal in database
        async function updateSignalInDB(signalId, updates) {
            try {
                const response = await fetch(`/api/signals/${signalId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updates)
                });
                
                if (response.ok) {
                    console.log('Signal updated in database');
                    return await response.json();
                } else {
                    console.error('Failed to update signal:', response.statusText);
                }
            } catch (error) {
                console.error('Error updating signal:', error);
            }
        }
        
        function extractSession(reason) {
            if (!reason) return 'LONDON';
            if (reason.includes('LONDON')) return 'LONDON';
            if (reason.includes('NY PRE MARKET')) return 'NY PRE MARKET';
            if (reason.includes('NEW YORK AM')) return 'NEW YORK AM';
            if (reason.includes('NY LUNCH')) return 'NY LUNCH';
            if (reason.includes('NEW YORK PM')) return 'NEW YORK PM';
            return 'LONDON';
        }
        
        function extractBreakeven(reason) {
            return reason && reason.includes('R') && !reason.includes('-1R');
        }
        
        function extractRScore(reason) {
            if (!reason) return 0;
            const match = reason.match(/(-?\d+(?:\.\d+)?)R/);
            return match ? parseFloat(match[1]) : 0;
        }
        
        function initCharts() {
            // Initialize D3 charts
            initD3Charts();
        }
        
        async function addTrade() {
            const trade = {
                date: document.getElementById('tradeDate').value,
                bias: document.getElementById('tradeBias').value,
                session: document.getElementById('tradeSession').value,
                breakeven: document.getElementById('tradeBreakeven').checked,
                rScore: parseFloat(document.getElementById('tradeRScore').value) || 0,
                r1: parseFloat(document.getElementById('trade1R').value) || 0,
                r2: parseFloat(document.getElementById('trade2R').value) || 0,
                r3: 0, r4: 0, r5: 0, r6: 0, r7: 0, r8: 0, r9: 0, r10: 0,
                r11: 0, r12: 0, r13: 0, r14: 0, r15: 0, r16: 0, r17: 0, r18: 0, r19: 0, r20: 0
            };
            
            const dataSource = document.getElementById('dataSourceToggle').value;
            
            if (dataSource === 'signal-lab') {
                await saveSignalToDB(trade);
            }
            
            trades.push(trade);
            updateDashboard();
            clearInputs();
        }
        
        function clearInputs() {
            document.getElementById('tradeDate').value = '';
            document.getElementById('tradeRScore').value = '';
            document.getElementById('trade1R').value = '';
            document.getElementById('trade2R').value = '';
            document.getElementById('tradeBreakeven').checked = false;
        }
        
        function getFilteredTrades() {
            const sessionCheckboxes = document.querySelectorAll('.session-filter:checked');
            const selectedSessions = Array.from(sessionCheckboxes).map(cb => cb.value);
            const biasFilter = document.getElementById('biasFilter').value;
            const breakevenFilter = document.getElementById('breakevenFilter').value === 'true';
            
            return trades.filter(trade => {
                if (selectedSessions.length > 0 && !selectedSessions.includes(trade.session)) return false;
                if (biasFilter !== 'ALL' && trade.bias !== biasFilter) return false;
                if (!breakevenFilter && trade.breakeven) return false;
                return true;
            });
        }
        
        function toggleAllSessions() {
            const allCheckbox = document.getElementById('sessionAll');
            const sessionCheckboxes = document.querySelectorAll('.session-filter');
            
            sessionCheckboxes.forEach(cb => {
                cb.checked = allCheckbox.checked;
            });
            
            updateCharts();
        }
        
        function saveFilterStates() {
            // Save UI state only (not trade data)
            localStorage.setItem('dataSource', document.getElementById('dataSourceToggle').value);
            const sessionCheckboxes = document.querySelectorAll('.session-filter');
            const sessionStates = {};
            sessionCheckboxes.forEach(cb => {
                sessionStates[cb.value] = cb.checked;
            });
            localStorage.setItem('sessionFilters', JSON.stringify(sessionStates));
            localStorage.setItem('sessionAll', document.getElementById('sessionAll').checked);
            localStorage.setItem('rTargetFilter', document.getElementById('rTargetFilter').value);
            localStorage.setItem('biasFilter', document.getElementById('biasFilter').value);
            localStorage.setItem('breakevenFilter', document.getElementById('breakevenFilter').value);
            localStorage.setItem('calendarView', document.getElementById('calendarView').value);
        }
        
        function loadFilterStates() {
            // Load data source - default to signal-lab
            const savedDataSource = localStorage.getItem('dataSource') || 'signal-lab';
            document.getElementById('dataSourceToggle').value = savedDataSource;
            
            // Load session filters
            const savedSessionStates = JSON.parse(localStorage.getItem('sessionFilters'));
            const savedSessionAll = localStorage.getItem('sessionAll');
            
            if (savedSessionStates) {
                const sessionCheckboxes = document.querySelectorAll('.session-filter');
                sessionCheckboxes.forEach(cb => {
                    if (savedSessionStates.hasOwnProperty(cb.value)) {
                        cb.checked = savedSessionStates[cb.value];
                    }
                });
            }
            
            if (savedSessionAll !== null) {
                document.getElementById('sessionAll').checked = savedSessionAll === 'true';
            }
            
            // Load other filters
            const savedRTarget = localStorage.getItem('rTargetFilter');
            if (savedRTarget) {
                document.getElementById('rTargetFilter').value = savedRTarget;
            }
            
            const savedBias = localStorage.getItem('biasFilter');
            if (savedBias) {
                document.getElementById('biasFilter').value = savedBias;
            }
            
            const savedBreakeven = localStorage.getItem('breakevenFilter');
            if (savedBreakeven) {
                document.getElementById('breakevenFilter').value = savedBreakeven;
            }
            
            const savedCalendarView = localStorage.getItem('calendarView');
            if (savedCalendarView) {
                document.getElementById('calendarView').value = savedCalendarView;
            }
        }
        
        function updateCharts() {
            // Save current filter states
            saveFilterStates();
            
            const filteredTrades = getFilteredTrades();
            const rTarget = parseInt(document.getElementById('rTargetFilter').value);
            
            // Calculate comprehensive metrics
            const metrics = calculateAdvancedMetrics(filteredTrades, rTarget);
            
            // Update basic metrics
            document.getElementById('filteredTrades').textContent = metrics.totalTrades;
            document.getElementById('filteredWinRate').textContent = metrics.winRate + '%';
            document.getElementById('profitFactor').textContent = metrics.profitFactor;
            document.getElementById('expectancy').textContent = metrics.expectancy + 'R';
            document.getElementById('sharpeRatio').textContent = metrics.sharpeRatio;
            document.getElementById('maxDrawdown').textContent = metrics.maxDrawdown + 'R';
            document.getElementById('recoveryFactor').textContent = metrics.recoveryFactor;
            document.getElementById('kellyPercent').textContent = metrics.kellyPercent + '%';
            
            // Update advanced metrics
            document.getElementById('var95').textContent = metrics.var95 + 'R';
            document.getElementById('calmarRatio').textContent = metrics.calmarRatio;
            document.getElementById('sortinoRatio').textContent = metrics.sortinoRatio;
            document.getElementById('maxConsecLosses').textContent = metrics.maxConsecLosses;
            // Removed reference to non-existent element
            
            // Monte Carlo elements don't exist in current HTML - skip for now
            
            // Update AI insights with real generative AI
            updateAIInsights();
            
            // Update D3 charts with filtered data
            updateD3Charts();
            
            // Update trading calendar
            updateTradingCalendar(filteredTrades, rTarget);
        }
        
        function updateCyclicalCharts(filteredTrades, rTarget) {
            // D3 charts are updated in updateD3Charts()
        }
        
        function updateAggregateEquity(filteredTrades, rTarget) {
            // D3 charts handle aggregation internally
        }
        
        function getWeekString(date) {
            const year = date.getFullYear();
            const week = getWeekNumber(date);
            return `${year}-W${week.toString().padStart(2, '0')}`;
        }
        
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        }
        
        function calculateAdvancedMetrics(trades, rTarget) {
            if (trades.length === 0) return getEmptyMetrics();
            
            const rValues = trades.map(t => getRValue(t, rTarget));
            // For win rate: any trade with MFE >= 1R is a win, regardless of R-target
            const winsForWinRate = trades.filter(t => t.rScore >= 1 || t.breakeven);
            const actualWins = rValues.filter(r => r > 0); // Only positive R values for profit calculations
            const losses = rValues.filter(r => r < 0);
            
            const totalTrades = trades.length;
            const winningTrades = winsForWinRate.length; // MFE >= 1R or breakeven
            const losingTrades = losses.length;
            const winRate = (winningTrades / totalTrades * 100).toFixed(1);
            
            const totalR = rValues.reduce((sum, r) => sum + r, 0);
            const avgWin = actualWins.length > 0 ? actualWins.reduce((sum, r) => sum + r, 0) / actualWins.length : 0;
            const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((sum, r) => sum + r, 0) / losses.length) : 0;
            
            const profitFactor = losingTrades > 0 ? ((avgWin * actualWins.length) / (avgLoss * losingTrades)).toFixed(2) : 'Infinity';
            const expectancy = (winRate/100 * avgWin + (1-winRate/100) * (avgLoss * -1)).toFixed(2);
            
            // Sharpe Ratio
            const meanReturn = totalR / totalTrades;
            const variance = rValues.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (totalTrades - 1);
            const stdDev = Math.sqrt(variance);
            const sharpeRatio = stdDev > 0 ? (meanReturn / stdDev).toFixed(2) : '0.00';
            
            // Drawdown analysis
            const drawdownData = calculateDrawdown(rValues);
            const maxDrawdown = drawdownData.maxDrawdown.toFixed(2);
            const recoveryFactor = drawdownData.maxDrawdown !== 0 ? (totalR / Math.abs(drawdownData.maxDrawdown)).toFixed(2) : '0.00';
            
            // Kelly Criterion: f = (bp - q) / b where b = avgWin/avgLoss, p = winRate, q = 1-winRate
            const kellyPercent = avgLoss > 0 && avgWin > 0 ? 
                (((winRate/100) * (avgWin/avgLoss) - (1-winRate/100)) / (avgWin/avgLoss) * 100).toFixed(2) : '0.00';
            
            // Risk metrics
            const sortedReturns = [...rValues].sort((a, b) => a - b);
            const var95 = sortedReturns[Math.floor(sortedReturns.length * 0.05)] || 0;
            
            const downside = rValues.filter(r => r < 0);
            const downsideVariance = downside.length > 0 ? downside.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / downside.length : 0;
            const downsideStdDev = Math.sqrt(downsideVariance);
            const sortinoRatio = downsideStdDev > 0 ? (meanReturn / downsideStdDev).toFixed(2) : '0.00';
            
            const calmarRatio = Math.abs(drawdownData.maxDrawdown) > 0 ? (totalR / Math.abs(drawdownData.maxDrawdown)).toFixed(2) : '0.00';
            
            // Consecutive losses for selected R-target
            const maxConsecLosses = calculateMaxConsecutiveLosses(rValues);
            
            // Monte Carlo simulation
            const monteCarloResults = runMonteCarlo(rValues, 1000, 100);
            const mc95 = monteCarloResults.percentile95.toFixed(2);
            const probProfit = (monteCarloResults.profitableRuns / monteCarloResults.totalRuns * 100).toFixed(0);
            const expectedFinalR = monteCarloResults.expectedFinal.toFixed(2);
            
            return {
                totalTrades, winRate, profitFactor, expectancy, sharpeRatio,
                maxDrawdown, recoveryFactor, kellyPercent, var95: var95.toFixed(2),
                calmarRatio, sortinoRatio, maxConsecLosses, mc95, probProfit,
                expectedFinalR, monteCarloResults
            };
        }
        
        function calculateDrawdown(rValues) {
            let peak = 0;
            let maxDrawdown = 0;
            let cumulative = 0;
            
            for (let r of rValues) {
                cumulative += r;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            }
            
            return { maxDrawdown: -maxDrawdown };
        }
        
        function calculateMaxConsecutiveLosses(rValues) {
            let maxStreak = 0;
            let currentStreak = 0;
            
            for (let r of rValues) {
                if (r < 0) {
                    currentStreak++;
                    maxStreak = Math.max(maxStreak, currentStreak);
                } else {
                    currentStreak = 0;
                }
            }
            
            return maxStreak;
        }
        
        function runMonteCarlo(rValues, simulations, trades) {
            const results = [];
            
            for (let i = 0; i < simulations; i++) {
                let cumulative = 0;
                for (let j = 0; j < trades; j++) {
                    const randomR = rValues[Math.floor(Math.random() * rValues.length)];
                    cumulative += randomR;
                }
                results.push(cumulative);
            }
            
            results.sort((a, b) => a - b);
            const percentile95 = results[Math.floor(results.length * 0.95)];
            const profitableRuns = results.filter(r => r > 0).length;
            const expectedFinal = results.reduce((sum, r) => sum + r, 0) / results.length;
            
            return { results, percentile95, profitableRuns, totalRuns: simulations, expectedFinal };
        }
        
        function updateMonteCarloChart(monteCarloResults) {
            const chartElement = document.getElementById('monteCarloChart');
            if (!chartElement) return; // Skip if element doesn't exist
            
            if (!charts.monteCarlo) {
                const ctx = chartElement.getContext('2d');
                charts.monteCarlo = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            data: [],
                            backgroundColor: 'rgba(0, 255, 136, 0.6)',
                            borderColor: '#00ff88',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            y: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                        }
                    }
                });
            }
            
            // Create histogram of Monte Carlo results
            const bins = 20;
            const min = Math.min(...monteCarloResults.results);
            const max = Math.max(...monteCarloResults.results);
            const binSize = (max - min) / bins;
            
            const histogram = new Array(bins).fill(0);
            const labels = [];
            
            for (let i = 0; i < bins; i++) {
                labels.push((min + i * binSize).toFixed(1));
            }
            
            monteCarloResults.results.forEach(result => {
                const binIndex = Math.min(Math.floor((result - min) / binSize), bins - 1);
                histogram[binIndex]++;
            });
            
            charts.monteCarlo.data.labels = labels;
            charts.monteCarlo.data.datasets[0].data = histogram;
            charts.monteCarlo.update('none');
        }
        
        function getEmptyMetrics() {
            return {
                totalTrades: 0, winRate: '0.0', profitFactor: '0.00', expectancy: '0.00',
                sharpeRatio: '0.00', maxDrawdown: '0.00', recoveryFactor: '0.00',
                kellyPercent: '0.00', var95: '0.00', calmarRatio: '0.00',
                sortinoRatio: '0.00', maxConsecLosses: 0, mc95: '0.00',
                probProfit: '0', expectedFinalR: '0.00', monteCarloResults: { results: [] }
            };
        }
        
        function getRValue(trade, rTarget) {
            const rScore = trade.rScore || 0;
            
            if (rScore < 0) return -1;
            if (rScore >= rTarget) return rTarget;
            if (trade.breakeven || rScore >= 1) return 0;
            return -1;
        }
        
        function updateTable() {
            const tbody = document.getElementById('tradesBody');
            if (!tbody) {
                console.log('tradesBody element not found - skipping table update');
                return;
            }
            tbody.innerHTML = '';
            
            const filteredTrades = getFilteredTrades();
            const dataSource = document.getElementById('dataSourceToggle').value;
            
            filteredTrades.slice(-10).reverse().forEach((trade, index) => {
                const row = tbody.insertRow();
                const isActiveTrade = !trade.rScore || trade.rScore === 0 || (trade.rScore === null || trade.rScore === undefined);
                const screenshotCell = dataSource === 'signal-lab' && trade.screenshot ? 
                    `<td><img src="${trade.screenshot}" style="width: 40px; height: 30px; object-fit: cover; border-radius: 4px; cursor: pointer;" onclick="window.open('${trade.screenshot}', '_blank')"></td>` : 
                    '<td></td>';
                
                if (isActiveTrade) {
                    row.style.background = 'rgba(255, 165, 0, 0.2)';
                    row.style.border = '1px solid rgba(255, 165, 0, 0.5)';
                    row.title = 'Active trade - Add MFE when closed';
                }
                
                row.innerHTML = `
                    ${screenshotCell}
                    <td>${trade.date}${isActiveTrade ? ' 🔄' : ''}</td>
                    <td>${trade.bias}</td>
                    <td>${trade.session}</td>
                    <td>${trade.breakeven ? '✓' : ''}</td>
                    <td>${isActiveTrade ? 'ACTIVE' : (trade.rScore ? trade.rScore.toFixed(1) + 'R' : 'ACTIVE')}</td>
                    <td>
                        <div class="r-columns">
                            <div class="r-value ${trade.r1 > 0 ? 'positive' : trade.r1 < 0 ? 'negative' : 'neutral'}">${trade.r1.toFixed(1)}</div>
                            <div class="r-value ${trade.r2 > 0 ? 'positive' : trade.r2 < 0 ? 'negative' : 'neutral'}">${trade.r2.toFixed(1)}</div>
                            <div class="r-value ${trade.r3 > 0 ? 'positive' : trade.r3 < 0 ? 'negative' : 'neutral'}">${trade.r3.toFixed(1)}</div>
                            <div class="r-value ${trade.r4 > 0 ? 'positive' : trade.r4 < 0 ? 'negative' : 'neutral'}">${trade.r4.toFixed(1)}</div>
                            <div class="r-value ${trade.r5 > 0 ? 'positive' : trade.r5 < 0 ? 'negative' : 'neutral'}">${trade.r5.toFixed(1)}</div>
                        </div>
                    </td>
                    <td><button onclick="deleteTrade(${trades.length - 1 - index})" style="background: #ff4757; border: none; padding: 5px 10px; border-radius: 5px; color: white; cursor: pointer;">Delete</button></td>
                `;
            });
        }
        
        function updateDashboard() {
            updateCharts();
            // Only update table if element exists
            if (document.getElementById('tradesBody')) {
                updateTable();
            }
        }
        
        function deleteTrade(index) {
            trades.splice(index, 1);
            updateDashboard();
        }
        
        // Safe function call helper - deprecated, using direct calls for AI
        function safeCall(functionName) {
            try {
                if (typeof window[functionName] === 'function') {
                    window[functionName]();
                } else {
                    console.warn(`Function ${functionName} not found`);
                }
            } catch (error) {
                console.error(`Error calling ${functionName}:`, error);
            }
        }
        
        // Load data from database instead of sample data
        async function loadDatabaseData() {
            await loadTradesFromDB();
            initializeCalendarYear();
            updateDashboard();
            
            // Initialize market data feeds
            initializeMarketFeeds();
            
            // Auto-refresh data every 30 seconds to catch updates
            setInterval(async () => {
                const currentCount = window.trades.length;
                await loadTradesFromDB();
                if (window.trades.length !== currentCount) {
                    updateDashboard();
                }
            }, 30000);
            
            // Force calendar update after data loads
            setTimeout(() => {
                console.log('Forcing calendar update after data load');
                const filteredTrades = getFilteredTrades();
                const rTarget = parseInt(document.getElementById('rTargetFilter').value);
                updateTradingCalendar(filteredTrades, rTarget);
                
                if (typeof d3 !== 'undefined') {
                    try {
                        initD3Charts();
                        updateD3Charts();
                        console.log('D3 charts initialized successfully');
                    } catch (error) {
                        console.warn('D3 chart initialization failed:', error);
                    }
                } else {
                    console.warn('D3 not available, skipping D3 chart initialization');
                }
            }, 1000);
        }
        
        // Market Data Functions
        async function initializeMarketFeeds() {
            console.log('Initializing market feeds...');
            await updateMarketNews();
            await updateMarketAnalysis();
            await updateEconomicNews();
            
            // Update market news every 2 minutes
            setInterval(updateMarketNews, 120000);
            // Update AI analysis every 5 minutes
            setInterval(updateMarketAnalysis, 300000);
            // Update economic news every 10 minutes
            setInterval(updateEconomicNews, 600000);
        }
        
        async function updateEconomicNews() {
            try {
                console.log('Fetching economic news...');
                const response = await fetch('/api/economic-news');
                const data = await response.json();
                
                if (data.status === 'success') {
                    updateEconomicEvents(data.economic_news);
                    await updateEconomicAnalysis(data.economic_news);
                }
            } catch (error) {
                console.error('Error updating economic news:', error);
                updateEconomicEventsFallback();
            }
        }
        
        function updateEconomicEvents(economicNews) {
            const eventsEl = document.getElementById('economicEvents');
            if (!eventsEl || !economicNews.length) {
                if (eventsEl) {
                    eventsEl.innerHTML = '<div style="opacity: 0.7;">No major economic events today</div>';
                }
                return;
            }
            
            const eventsHtml = economicNews.slice(0, 3).map(item => {
                const impactColor = item.impact === 'HIGH' ? '#ff4757' : item.impact === 'MEDIUM' ? '#ffa502' : '#2ed573';
                return `<div style="margin-bottom: 6px; padding: 4px 0; border-left: 3px solid ${impactColor}; padding-left: 8px;">
                    <div style="font-weight: 600; font-size: 11px;">${item.title.substring(0, 60)}...</div>
                    <div style="font-size: 10px; opacity: 0.8;">${item.impact} Impact • ${item.source}</div>
                </div>`;
            }).join('');
            
            eventsEl.innerHTML = eventsHtml;
        }
        
        async function updateEconomicAnalysis(economicNews) {
            try {
                const newsResponse = await fetch('/api/market-news');
                const newsData = await newsResponse.json();
                
                const analysisResponse = await fetch('/api/ai-economic-analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        economic_news: economicNews,
                        futures: newsData.futures || {}
                    })
                });
                
                const analysisData = await analysisResponse.json();
                
                if (analysisData.status === 'success') {
                    updateEconomicIntelligence(analysisData);
                }
            } catch (error) {
                console.error('Error updating economic analysis:', error);
                updateEconomicAnalysisFallback();
            }
        }
        
        function updateEconomicIntelligence(data) {
            // Update impact indicator
            const impactEl = document.getElementById('economicImpact');
            if (impactEl) {
                impactEl.textContent = data.impact;
                impactEl.className = `bias-${data.impact.toLowerCase()}`;
            }
            
            // Update AI analysis
            const analysisEl = document.getElementById('aiEconomicAnalysis');
            if (analysisEl) {
                analysisEl.innerHTML = formatAIAnalysis(data.analysis);
            }
            
            // Update economic risks
            const risksEl = document.getElementById('economicRisks');
            if (risksEl && data.key_events.length > 0) {
                risksEl.textContent = data.key_events.join(' • ');
            }
        }
        
        function updateEconomicEventsFallback() {
            const eventsEl = document.getElementById('economicEvents');
            if (eventsEl) {
                eventsEl.innerHTML = '<div style="opacity: 0.7;">Economic calendar loading...</div>';
            }
        }
        
        function updateEconomicAnalysisFallback() {
            const analysisEl = document.getElementById('aiEconomicAnalysis');
            if (analysisEl) {
                analysisEl.innerHTML = formatAIAnalysis('Economic intelligence processing. Monitoring Fed policy decisions, inflation trends, and employment data for NQ futures impact.');
            }
        }
        
        async function updateMarketNews() {
            try {
                console.log('Fetching market news...');
                const response = await fetch('/api/market-news');
                const data = await response.json();
                
                console.log('Market news response:', data);
                
                if (data.status === 'success') {
                    updateNewsTicker(data.news);
                    updateFuturesData(data.futures);
                } else {
                    console.error('Market news API returned error:', data.error);
                    updateNewsTickerFallback();
                    updateFuturesDataFallback();
                }
            } catch (error) {
                console.error('Error updating market news:', error);
                updateNewsTickerFallback();
                updateFuturesDataFallback();
            }
        }
        
        function updateNewsTicker(news) {
            const tickerContent = document.getElementById('tickerContent');
            if (!tickerContent) {
                console.log('No ticker content element found');
                return;
            }
            
            if (!news || !news.length) {
                console.log('No news data available');
                updateNewsTickerFallback();
                return;
            }
            
            console.log('Updating news ticker with', news.length, 'items');
            
            const newsText = news.map(item => 
                `📰 ${item.title.substring(0, 120)}...`
            ).join('   •   ');
            
            tickerContent.textContent = newsText;
        }
        
        function updateFuturesData(futures) {
            const futuresEl = document.getElementById('futuresData');
            if (!futuresEl || !futures) {
                console.log('No futures element or data');
                return;
            }
            
            console.log('Updating futures data:', futures);
            
            const futuresHtml = Object.entries(futures).map(([symbol, data]) => {
                const changeClass = data.change && data.change.startsWith && data.change.startsWith('+') ? 'positive' : 
                                  data.change && data.change.startsWith && data.change.startsWith('-') ? 'negative' : 'neutral';
                return `<span class="${changeClass}">${symbol}: ${data.price} (${data.change || '--'})</span>`;
            }).join(' | ');
            
            futuresEl.innerHTML = futuresHtml;
        }
        
        function updateFuturesDataFallback() {
            const futuresEl = document.getElementById('futuresData');
            if (futuresEl) {
                futuresEl.innerHTML = '<span class="neutral">NQ: Loading... | ES: Loading... | YM: Loading...</span>';
            }
        }
        
        async function updateMarketAnalysis() {
            try {
                const filteredTrades = getFilteredTrades();
                
                // Get current market data first
                const newsResponse = await fetch('/api/market-news');
                const newsData = await newsResponse.json();
                
                const analysisResponse = await fetch('/api/ai-market-analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        news: newsData.news || [],
                        futures: newsData.futures || {},
                        trades: filteredTrades.slice(-20) // Last 20 trades for context
                    })
                });
                
                const analysisData = await analysisResponse.json();
                
                if (analysisData.status === 'success') {
                    updateMarketIntelligence(analysisData);
                }
            } catch (error) {
                console.error('Error updating market analysis:', error);
                updateMarketIntelligenceFallback();
            }
        }
        
        function updateMarketIntelligence(data) {
            // Update bias
            const biasEl = document.getElementById('marketBias');
            if (biasEl) {
                biasEl.textContent = data.bias;
                biasEl.className = `bias-${data.bias.toLowerCase()}`;
                biasEl.style.background = data.bias === 'LONG' ? 'rgba(0,255,136,0.2)' : 
                                        data.bias === 'SHORT' ? 'rgba(255,71,87,0.2)' : 
                                        'rgba(255,165,0,0.2)';
            }
            
            // Update analysis with formatted structure
            const analysisEl = document.getElementById('aiMarketAnalysis');
            if (analysisEl) {
                analysisEl.innerHTML = formatAIAnalysis(data.analysis);
            }
            
            // Update key levels
            const resistanceEl = document.getElementById('resistanceLevels');
            const supportEl = document.getElementById('supportLevels');
            const pivotEl = document.getElementById('pivotLevel');
            
            if (resistanceEl && data.key_levels.resistance) {
                resistanceEl.textContent = data.key_levels.resistance.join(', ');
            }
            if (supportEl && data.key_levels.support) {
                supportEl.textContent = data.key_levels.support.join(', ');
            }
            if (pivotEl && data.key_levels.pivot) {
                pivotEl.textContent = data.key_levels.pivot;
            }
            
            // Update alerts
            const alertsEl = document.getElementById('alertsList');
            if (alertsEl && data.alerts.length > 0) {
                alertsEl.textContent = data.alerts.join(' • ');
            }
            
            // Update confidence
            const confidenceEl = document.getElementById('aiConfidence');
            if (confidenceEl) {
                confidenceEl.textContent = data.confidence || '75%';
            }
        }
        
        function updateNewsTickerFallback() {
            const tickerContent = document.getElementById('tickerContent');
            if (tickerContent) {
                tickerContent.textContent = '📰 Market news feed connecting... • 📈 NQ futures monitoring active • 🤖 AI analysis optimizing for your trading strategy... • 📊 Economic data processing...';
            }
        }
        
        function formatAIAnalysis(text) {
            // Format AI analysis into professional bullet points
            const lines = text.split(/[.!]/).filter(line => line.trim().length > 10);
            
            let formatted = '<div class="ai-analysis-formatted">';
            
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (trimmed) {
                    formatted += `<div style="margin-bottom: 6px; padding-left: 12px; position: relative;">`;
                    formatted += `<span style="position: absolute; left: 0; color: #00ff88;">•</span>`;
                    formatted += `<span>${trimmed}</span>`;
                    formatted += `</div>`;
                }
            });
            
            formatted += '</div>';
            return formatted;
        }
        
        function formatChartAnalysis(text) {
            // Format chart analysis into professional bullet points
            const points = text.split(/[.!]/).filter(point => point.trim().length > 5);
            
            let formatted = '';
            points.slice(0, 3).forEach((point, index) => {
                const trimmed = point.trim();
                if (trimmed) {
                    formatted += `<div style="margin-bottom: 4px; font-size: 12px; line-height: 1.4; padding-left: 12px; position: relative;">`;
                    formatted += `<span style="position: absolute; left: 0; color: #00ff88;">•</span>`;
                    formatted += `<span>${trimmed}</span>`;
                    formatted += `</div>`;
                }
            });
            
            return formatted || text;
        }
        
        function updateMarketIntelligenceFallback() {
            const analysisEl = document.getElementById('aiMarketAnalysis');
            const biasEl = document.getElementById('marketBias');
            
            if (analysisEl) {
                const fallbackText = 'ICT AI optimizing. Monitoring 1H FVG/IFVG bias. Session liquidity levels tracking. Pivot sweep opportunities scanning.';
                analysisEl.innerHTML = formatAIAnalysis(fallbackText);
            }
            
            if (biasEl) {
                biasEl.textContent = 'SCANNING';
                biasEl.style.background = 'rgba(255,165,0,0.2)';
            }
        }
        
        function initializeCalendarYear() {
            const yearSelect = document.getElementById('calendarYear');
            const currentYear = new Date().getFullYear();
            
            // Clear existing options
            yearSelect.innerHTML = '';
            
            // Add years from current year back to 2020
            for (let year = currentYear; year >= 2020; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === currentYear) option.selected = true;
                yearSelect.appendChild(option);
            }
            
            // Set calendar view to heatmap by default
            const calendarView = document.getElementById('calendarView');
            if (calendarView && calendarView.value !== 'heatmap') {
                calendarView.value = 'heatmap';
            }
        }
        
        function exportData() {
            const csv = 'Date,Bias,Session,Breakeven,RScore,1R,2R,3R,4R,5R\\n' + 
                       trades.map(t => `${t.date},${t.bias},${t.session},${t.breakeven},${t.rScore},${t.r1},${t.r2},${t.r3},${t.r4},${t.r5}`).join('\\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'advanced_trading_data.csv';
            a.click();
        }
        
        function importCSV(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const csv = e.target.result;
                    const lines = csv.split('\\n');
                    
                    trades = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            const values = lines[i].split(',');
                            trades.push({
                                date: values[0],
                                bias: values[1],
                                session: values[2],
                                breakeven: values[3] === 'true',
                                rScore: parseFloat(values[4]) || 0,
                                r1: parseFloat(values[5]) || 0,
                                r2: parseFloat(values[6]) || 0,
                                r3: parseFloat(values[7]) || 0,
                                r4: parseFloat(values[8]) || 0,
                                r5: parseFloat(values[9]) || 0
                            });
                        }
                    }
                    updateDashboard();
                };
                reader.readAsText(file);
            }
        }
        
        async function updateCalendarView() {
            console.log('updateCalendarView called');
            saveFilterStates();
            const filteredTrades = getFilteredTrades();
            const rTarget = parseInt(document.getElementById('rTargetFilter').value);
            console.log('About to update calendar with', filteredTrades.length, 'trades');
            await updateTradingCalendar(filteredTrades, rTarget);
        }
        
        async function updateTradingCalendar(filteredTrades, rTarget) {
            const calendar = document.getElementById('tradingCalendar');
            const legend = document.getElementById('calendarLegend');
            const view = document.getElementById('calendarView').value;
            const year = parseInt(document.getElementById('calendarYear').value);
            
            calendar.innerHTML = '';
            legend.innerHTML = '';
            
            console.log('Calendar update:', filteredTrades.length, 'trades, view:', view);
            
            if (view === 'heatmap') {
                updateHeatmapCalendar(filteredTrades, rTarget, calendar, legend, year);
            } else if (view === 'day') {
                calendar.style.display = 'grid';
                calendar.style.gridTemplateColumns = 'repeat(7, 1fr)';
                updateDailyCalendar(filteredTrades, rTarget, calendar);
            } else if (view === 'week') {
                calendar.style.display = 'grid';
                calendar.style.gridTemplateColumns = 'repeat(4, 1fr)';
                updateWeeklyCalendar(filteredTrades, rTarget, calendar);
            } else if (view === 'month') {
                calendar.style.display = 'grid';
                calendar.style.gridTemplateColumns = 'repeat(3, 1fr)';
                updateMonthlyCalendar(filteredTrades, rTarget, calendar);
            }
        }
        
        function updateHeatmapCalendar(filteredTrades, rTarget, calendar, legend, year) {
            calendar.style.display = 'block';
            
            console.log('Heatmap input:', filteredTrades.length, 'trades, year:', year, 'rTarget:', rTarget);
            if (filteredTrades.length > 0) {
                console.log('Sample trade:', filteredTrades[0]);
            }
            
            const dailyData = {};
            filteredTrades.forEach((trade, index) => {
                const tradeDate = new Date(trade.date);
                if (tradeDate.getFullYear() === year) {
                    const dateKey = tradeDate.toISOString().split('T')[0];
                    if (!dailyData[dateKey]) {
                        dailyData[dateKey] = { trades: [], totalR: 0, wins: 0, losses: 0 };
                    }
                    const rValue = getRValue(trade, rTarget);
                    dailyData[dateKey].trades.push(trade);
                    dailyData[dateKey].totalR += rValue;
                    if (rValue >= 0) dailyData[dateKey].wins++;
                    else dailyData[dateKey].losses++;
                    
                    if (index < 3) console.log('Trade', index, ':', trade.date, 'rScore:', trade.rScore, 'rValue:', rValue);
                }
            });
            
            console.log('Heatmap daily data:', Object.keys(dailyData).length, 'days with trades');
            console.log('Daily data sample:', Object.keys(dailyData).slice(0, 3).map(k => ({[k]: dailyData[k]})));
            
            // Create heatmap container
            const heatmapDiv = document.createElement('div');
            heatmapDiv.className = 'calendar-heatmap';
            
            const monthsDiv = document.createElement('div');
            monthsDiv.className = 'calendar-months';
            
            // Generate months
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            for (let month = 0; month < 12; month++) {
                const monthDiv = document.createElement('div');
                monthDiv.className = 'calendar-month';
                
                const monthLabel = document.createElement('div');
                monthLabel.className = 'calendar-month-label';
                monthLabel.textContent = monthNames[month];
                monthDiv.appendChild(monthLabel);
                
                const weeksDiv = document.createElement('div');
                weeksDiv.className = 'calendar-weeks';
                
                // Get first day of month and number of days
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                
                // Create weeks
                const weeks = [];
                let currentWeek = [];
                
                // Add empty days for first week
                const startDay = firstDay.getDay();
                for (let i = 0; i < startDay; i++) {
                    currentWeek.push(null);
                }
                
                // Add all days of month
                for (let day = 1; day <= daysInMonth; day++) {
                    currentWeek.push(new Date(year, month, day));
                    if (currentWeek.length === 7) {
                        weeks.push(currentWeek);
                        currentWeek = [];
                    }
                }
                
                // Add remaining days to last week
                if (currentWeek.length > 0) {
                    while (currentWeek.length < 7) {
                        currentWeek.push(null);
                    }
                    weeks.push(currentWeek);
                }
                
                // Create week columns
                for (let weekIndex = 0; weekIndex < weeks[0].length; weekIndex++) {
                    const weekDiv = document.createElement('div');
                    weekDiv.className = 'calendar-week';
                    
                    weeks.forEach(week => {
                        const dayDate = week[weekIndex];
                        const dayDiv = document.createElement('div');
                        dayDiv.className = 'calendar-day-heatmap';
                        
                        if (dayDate) {
                            const dateKey = dayDate.toISOString().split('T')[0];
                            const dayData = dailyData[dateKey];
                            
                            if (dayData && dayData.trades.length > 0) {
                                const intensity = Math.min(5, Math.max(1, Math.abs(Math.round(dayData.totalR))));
                                if (dayData.totalR > 0.1) {
                                    dayDiv.classList.add(`profit-${intensity}`);
                                } else if (dayData.totalR < -0.1) {
                                    dayDiv.classList.add(`loss-${intensity}`);
                                } else {
                                    dayDiv.classList.add('breakeven');
                                }
                                
                                // Add tooltip with proper data
                                const winRate = dayData.trades.length > 0 ? ((dayData.wins / dayData.trades.length) * 100).toFixed(0) : '0';
                                dayDiv.title = `${dateKey}\n${dayData.totalR.toFixed(1)}R | ${dayData.trades.length} trades\n${winRate}% win rate`;
                            } else {
                                dayDiv.classList.add('no-data');
                            }
                        } else {
                            dayDiv.style.visibility = 'hidden';
                        }
                        
                        weekDiv.appendChild(dayDiv);
                    });
                    
                    weeksDiv.appendChild(weekDiv);
                }
                
                monthDiv.appendChild(weeksDiv);
                monthsDiv.appendChild(monthDiv);
            }
            
            heatmapDiv.appendChild(monthsDiv);
            calendar.appendChild(heatmapDiv);
            
            // Create legend
            createCalendarLegend(legend);
        }
        
        function createCalendarLegend(legend) {
            const legendItems = [
                { label: 'No trades', class: 'no-data' },
                { label: 'Small loss', class: 'loss-1' },
                { label: 'Large loss', class: 'loss-5' },
                { label: 'Breakeven', class: 'breakeven' },
                { label: 'Small profit', class: 'profit-1' },
                { label: 'Large profit', class: 'profit-5' }
            ];
            
            legend.innerHTML = '<span style="margin-right: 10px;">Performance:</span>';
            
            legendItems.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.className = 'calendar-legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = `calendar-legend-color calendar-day-heatmap ${item.class}`;
                
                const label = document.createElement('span');
                label.textContent = item.label;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legend.appendChild(legendItem);
            });
        }
        
        function updateDailyCalendar(filteredTrades, rTarget, calendar) {
            console.log('Daily calendar input:', filteredTrades.length, 'trades');
            
            const dailyData = {};
            filteredTrades.forEach(trade => {
                const date = new Date(trade.date).toISOString().split('T')[0];
                if (!dailyData[date]) {
                    dailyData[date] = { totalR: 0, wins: 0, count: 0, breakevens: 0 };
                }
                const rValue = getRValue(trade, rTarget);
                dailyData[date].totalR += rValue;
                dailyData[date].count++;
                if (rValue >= 0) dailyData[date].wins++;
            });
            
            console.log('Daily calendar data:', Object.keys(dailyData).length, 'unique days');
            console.log('Sample daily data:', Object.keys(dailyData).slice(0, 2).map(k => ({[k]: dailyData[k]})));
            
            // Create calendar entries for each unique day
            Object.keys(dailyData).sort().forEach(date => {
                const dayData = dailyData[date];
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                
                if (dayData.totalR > 0.1) dayDiv.classList.add('calendar-profitable');
                else if (dayData.totalR < -0.1) dayDiv.classList.add('calendar-loss');
                else dayDiv.classList.add('calendar-breakeven');
                
                const winRate = dayData.count > 0 ? ((dayData.wins / dayData.count) * 100).toFixed(0) : '0';
                
                dayDiv.innerHTML = `
                    <div class="calendar-date">${date}</div>
                    <div class="calendar-stats">
                        ${dayData.totalR.toFixed(1)}R | ${dayData.count}T<br>
                        ${winRate}% WR
                    </div>
                `;
                
                calendar.appendChild(dayDiv);
            });
        }
        
        function updateWeeklyCalendar(filteredTrades, rTarget, calendar) {
            console.log('Weekly calendar input:', filteredTrades.length, 'trades');
            
            const weeklyData = {};
            filteredTrades.forEach(trade => {
                const date = new Date(trade.date);
                const weekStr = getWeekString(date);
                if (!weeklyData[weekStr]) {
                    weeklyData[weekStr] = { trades: [], totalR: 0, wins: 0, losses: 0 };
                }
                const rValue = getRValue(trade, rTarget);
                weeklyData[weekStr].trades.push(trade);
                weeklyData[weekStr].totalR += rValue;
                if (rValue >= 0) weeklyData[weekStr].wins++;
                else weeklyData[weekStr].losses++;
            });
            
            console.log('Weekly calendar data:', Object.keys(weeklyData).length, 'weeks');
            console.log('Sample weekly data:', Object.keys(weeklyData).slice(0, 2).map(k => ({[k]: weeklyData[k]})));
            
            Object.keys(weeklyData).sort().forEach(week => {
                const weekData = weeklyData[week];
                const weekDiv = document.createElement('div');
                weekDiv.className = 'calendar-day';
                
                if (weekData.totalR > 0.1) weekDiv.classList.add('calendar-profitable');
                else if (weekData.totalR < -0.1) weekDiv.classList.add('calendar-loss');
                else weekDiv.classList.add('calendar-breakeven');
                
                const winRate = weekData.trades.length > 0 ? (weekData.wins / weekData.trades.length * 100).toFixed(0) : '0';
                const avgR = weekData.trades.length > 0 ? (weekData.totalR / weekData.trades.length).toFixed(2) : '0.00';
                const expectancy = weekData.trades.length > 0 ? (weekData.totalR / weekData.trades.length).toFixed(2) : '0.00';
                const bestTrade = weekData.trades.length > 0 ? Math.max(...weekData.trades.map(t => getRValue(t, rTarget))).toFixed(1) : '0.0';
                const tradingDays = new Set(weekData.trades.map(t => t.date)).size;
                
                const parts = week.split('-W');
                const yearNumber = parts[0] || new Date().getFullYear();
                const weekNumber = parts[1] || '1';
                
                weekDiv.innerHTML = `
                    <div class="calendar-date" style="font-size: 11px; margin-bottom: 3px;">Week ${weekNumber} ${yearNumber}</div>
                    <div class="calendar-stats" style="font-size: 9px; line-height: 1.2;">
                        ${weekData.totalR.toFixed(1)}R | ${weekData.trades.length}T<br>
                        ${winRate}% WR | ${tradingDays}D<br>
                        Best: ${bestTrade}R
                    </div>
                `;
                
                calendar.appendChild(weekDiv);
            });
        }
        
        function updateMonthlyCalendar(filteredTrades, rTarget, calendar) {
            const monthlyData = {};
            filteredTrades.forEach(trade => {
                const date = new Date(trade.date + 'T00:00:00');
                const monthStr = date.toISOString().slice(0, 7);
                if (!monthlyData[monthStr]) {
                    monthlyData[monthStr] = { trades: [], totalR: 0, wins: 0, losses: 0 };
                }
                const rValue = getRValue(trade, rTarget);
                monthlyData[monthStr].trades.push(trade);
                monthlyData[monthStr].totalR += rValue;
                if (rValue >= 0) monthlyData[monthStr].wins++;
                else monthlyData[monthStr].losses++;
            });
            
            Object.keys(monthlyData).sort().forEach(month => {
                const monthData = monthlyData[month];
                const monthDiv = document.createElement('div');
                monthDiv.className = 'calendar-day';
                
                if (monthData.totalR > 0) monthDiv.classList.add('calendar-profitable');
                else if (monthData.totalR < 0) monthDiv.classList.add('calendar-loss');
                else monthDiv.classList.add('calendar-breakeven');
                
                const winRate = monthData.trades.length > 0 ? (monthData.wins / monthData.trades.length * 100).toFixed(0) : 0;
                const avgR = monthData.trades.length > 0 ? (monthData.totalR / monthData.trades.length).toFixed(2) : 0;
                const expectancy = monthData.trades.length > 0 ? ((monthData.wins / monthData.trades.length) * avgR - ((monthData.trades.length - monthData.wins) / monthData.trades.length) * 1).toFixed(2) : 0;
                const bestTrade = monthData.trades.length > 0 ? Math.max(...monthData.trades.map(t => getRValue(t, rTarget))).toFixed(1) : 0;
                const tradingDays = new Set(monthData.trades.map(t => t.date)).size;
                const profitFactor = monthData.trades.length > 0 ? (monthData.wins > 0 && (monthData.trades.length - monthData.wins) > 0 ? (monthData.totalR > 0 ? (monthData.totalR / Math.abs(monthData.trades.filter(t => getRValue(t, rTarget) < 0).reduce((sum, t) => sum + getRValue(t, rTarget), 0) || 1)).toFixed(2) : '0.00') : 'N/A') : 'N/A';
                
                monthDiv.innerHTML = `
                    <div class="calendar-date" style="font-size: 11px; margin-bottom: 3px;">${new Date(month + '-01T00:00:00').toLocaleDateString('en-US', {month: 'short', year: 'numeric'})}</div>
                    <div class="calendar-stats" style="font-size: 9px; line-height: 1.2;">
                        ${monthData.totalR.toFixed(1)}R | ${monthData.trades.length}T<br>
                        ${winRate}% WR | E:${expectancy}<br>
                        PF:${profitFactor} | ${tradingDays}D
                    </div>
                `;
                
                calendar.appendChild(monthDiv);
            });
        }
        
        function changeStyle() {
            const style = document.getElementById('styleSelector').value;
            if (window.professionalStyles) {
                window.professionalStyles.setStyle(style);
            }
        }
        
        function loadStyle() {
            const savedStyle = localStorage.getItem('professionalStyle') || 'slate';
            const selector = document.getElementById('styleSelector');
            if (selector) {
                selector.value = savedStyle;
            }
        }
        
        function loadSampleData() {
            window.trades = [
                { date: '2024-01-15', bias: 'LONG', session: 'LONDON', breakeven: false, rScore: 2.5, r1: 2.5, r2: 2.5, r3: 0, r4: 0, r5: 0, r6: 0, r7: 0, r8: 0, r9: 0, r10: 0, r11: 0, r12: 0, r13: 0, r14: 0, r15: 0, r16: 0, r17: 0, r18: 0, r19: 0, r20: 0 },
                { date: '2024-01-16', bias: 'SHORT', session: 'NEW YORK AM', breakeven: true, rScore: 1, r1: 1, r2: 1, r3: 0, r4: 0, r5: 0, r6: 0, r7: 0, r8: 0, r9: 0, r10: 0, r11: 0, r12: 0, r13: 0, r14: 0, r15: 0, r16: 0, r17: 0, r18: 0, r19: 0, r20: 0 },
                { date: '2024-01-17', bias: 'LONG', session: 'LONDON', breakeven: false, rScore: -1, r1: -1, r2: -1, r3: 0, r4: 0, r5: 0, r6: 0, r7: 0, r8: 0, r9: 0, r10: 0, r11: 0, r12: 0, r13: 0, r14: 0, r15: 0, r16: 0, r17: 0, r18: 0, r19: 0, r20: 0 }
            ];
            updateDashboard();
        }
        
        // Add D3 container to HTML if it doesn't exist
        function ensureD3Container() {
            if (!document.getElementById('d3EquityContainer')) {
                const container = document.createElement('div');
                container.id = 'd3EquityContainer';
                container.style.cssText = 'width: 100%; height: 300px; margin: 20px 0; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 20px;';
                container.innerHTML = '<h3 style="color: white; margin-bottom: 15px;">D3 Enhanced Equity Chart</h3>';
                
                // Insert after the main charts
                const mainGrid = document.querySelector('.main-grid');
                if (mainGrid) {
                    mainGrid.parentNode.insertBefore(container, mainGrid.nextSibling);
                }
            }
        }
        
        // AI Analysis Functions
        class TradingAI {
            constructor() {
                this.model = null;
                this.isReady = false;
            }
            
            async initialize() {
                // Simple pattern recognition without complex ML model
                this.isReady = true;
                return true;
            }
            
            analyzeOptimalRTarget(trades) {
                if (trades.length < 5) return { target: 1, confidence: 0.5 };
                
                const rTargets = [1, 2, 3, 4, 5];
                let bestTarget = 1;
                let bestExpectancy = -999;
                
                rTargets.forEach(target => {
                    const results = trades.map(trade => {
                        // Handle different data structures
                        const rScore = trade.rScore || trade.r1 || 0;
                        const isBreakeven = trade.breakeven || rScore === 0;
                        
                        if (isBreakeven) return 0;
                        if (rScore < 0) return -1;
                        return rScore >= target ? target : -1;
                    });
                    
                    const wins = results.filter(r => r > 0).length;
                    const breakevens = results.filter(r => r === 0).length;
                    const winRate = (wins + breakevens) / results.length; // Include breakevens as wins
                    const avgWin = target;
                    const avgLoss = 1;
                    const expectancy = (winRate * avgWin) - ((1 - winRate) * avgLoss);
                    
                    if (expectancy > bestExpectancy) {
                        bestExpectancy = expectancy;
                        bestTarget = target;
                    }
                });
                
                return { target: bestTarget, confidence: Math.min(0.95, Math.max(0.1, bestExpectancy + 0.5)) };
            }
            
            analyzeBestSession(trades) {
                if (trades.length < 3) return { session: 'LONDON', performance: 0 };
                
                const sessionStats = {};
                trades.forEach(trade => {
                    const session = trade.session || 'UNKNOWN';
                    const rScore = trade.rScore || trade.r1 || 0;
                    const isBreakeven = trade.breakeven || rScore === 0;
                    
                    if (!sessionStats[session]) {
                        sessionStats[session] = { total: 0, count: 0, wins: 0 };
                    }
                    sessionStats[session].total += rScore;
                    sessionStats[session].count++;
                    if (rScore > 0 || isBreakeven) sessionStats[session].wins++;
                });
                
                let bestSession = 'LONDON';
                let bestPerformance = -999;
                
                Object.keys(sessionStats).forEach(session => {
                    const stats = sessionStats[session];
                    if (stats.count < 2) return; // Need at least 2 trades
                    
                    const avgR = stats.total / stats.count;
                    const winRate = stats.wins / stats.count;
                    const performance = avgR * winRate;
                    
                    if (performance > bestPerformance) {
                        bestPerformance = performance;
                        bestSession = session;
                    }
                });
                
                return { session: bestSession, performance: bestPerformance };
            }
            
            calculateRiskScore(trades) {
                if (trades.length < 3) return 75;
                
                const recentTrades = trades.slice(-Math.min(20, trades.length));
                const losses = recentTrades.filter(t => {
                    const rScore = t.rScore || t.r1 || 0;
                    return rScore < 0;
                }).length;
                
                const lossRate = losses / recentTrades.length;
                const consecutiveLosses = this.getConsecutiveLosses(recentTrades);
                
                let riskScore = 100 - (lossRate * 40) - (consecutiveLosses * 8);
                riskScore = Math.max(10, Math.min(100, riskScore));
                
                return Math.round(riskScore);
            }
            
            getConsecutiveLosses(trades) {
                let maxStreak = 0;
                let currentStreak = 0;
                
                trades.forEach(trade => {
                    const rScore = trade.rScore || trade.r1 || 0;
                    if (rScore < 0) {
                        currentStreak++;
                        maxStreak = Math.max(maxStreak, currentStreak);
                    } else {
                        currentStreak = 0;
                    }
                });
                
                return maxStreak;
            }
            
            predictNextTrade(trades) {
                if (trades.length < 5) return { prediction: 'NEUTRAL', confidence: 0.6 };
                
                const recent = trades.slice(-Math.min(5, trades.length));
                const wins = recent.filter(t => {
                    const rScore = t.rScore || t.r1 || 0;
                    return rScore > 0 || t.breakeven;
                }).length;
                const winRate = wins / recent.length;
                
                let prediction = 'NEUTRAL';
                let confidence = 0.6;
                
                if (winRate >= 0.8) {
                    prediction = 'POSITIVE';
                    confidence = 0.75;
                } else if (winRate <= 0.2) {
                    prediction = 'CAUTION';
                    confidence = 0.7;
                }
                
                return { prediction, confidence };
            }
            
            generateRecommendation(trades, rTarget) {
                if (trades.length < 5) {
                    return "Collect more trading data for better AI insights. Focus on consistent execution.";
                }
                
                const optimal = this.analyzeOptimalRTarget(trades);
                const bestSession = this.analyzeBestSession(trades);
                const riskScore = this.calculateRiskScore(trades);
                const nextTrade = this.predictNextTrade(trades);
                
                let recommendation = "";
                
                if (optimal.target !== rTarget) {
                    recommendation += `Consider switching to ${optimal.target}R target for better expectancy. `;
                }
                
                if (riskScore < 30) {
                    recommendation += "High risk detected - consider reducing position size or taking a break. ";
                } else if (riskScore > 80) {
                    recommendation += "Strong performance trend - maintain current strategy. ";
                }
                
                if (bestSession.performance > 0.5) {
                    recommendation += `${bestSession.session} session shows strongest performance. `;
                }
                
                if (nextTrade.prediction === 'CAUTION') {
                    recommendation += "Recent pattern suggests increased caution on next trades.";
                }
                
                return recommendation || "Maintain current trading approach and monitor performance.";
            }
        }
        
        /* duplicate tradingAI init removed */
        
        async function updateAIInsights() {
            console.log('Starting real AI analysis...');
            
            try {
                const filteredTrades = getFilteredTrades();
                console.log('Filtered trades:', filteredTrades.length);
                
                if (filteredTrades.length === 0) {
                    console.log('No trades to analyze');
                    updateAIInsightsMinimal();
                    return;
                }
                
                const rTarget = parseInt(document.getElementById('rTargetFilter').value);
                const metrics = calculateAdvancedMetrics(filteredTrades, rTarget);
                
                // Call real AI endpoints
                await Promise.all([
                    updateStrategySummaryAI(filteredTrades, metrics),
                    updateChartInsightsAI(filteredTrades, metrics, rTarget),
                    updateRiskAssessmentAI(filteredTrades, metrics)
                ]);
                
                // Still use local analysis for some metrics
                const optimal = analyzeOptimalRTarget(filteredTrades);
                const bestSession = analyzeBestSession(filteredTrades);
                const riskScore = calculateRiskScore(filteredTrades);
                const markovAnalysis = analyzeMarkovChain(filteredTrades, rTarget);
                const advancedStats = calculateAdvancedStatistics(filteredTrades, rTarget);
                const cyclicalAnalysis = analyzeCyclicalPerformance(filteredTrades, rTarget);
                
                // Update local analysis results
                updateLocalAnalysisResults(optimal, bestSession, riskScore, markovAnalysis, advancedStats, cyclicalAnalysis, filteredTrades, rTarget, metrics);
                
                console.log('Real AI analysis completed successfully');
                
            } catch (error) {
                console.error('AI Analysis Error:', error);
                // Fallback to local analysis
                await updateAIInsightsFallback();
            }
        }
        
        async function updateStrategySummaryAI(trades, metrics) {
            try {
                const response = await fetch('/api/ai-strategy-summary', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        trades: trades,
                        metrics: metrics
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update strategy summary elements
                    const strategySummary = document.getElementById('strategySummary');
                    const systemHealth = document.getElementById('systemHealth');
                    const adaptationScore = document.getElementById('adaptationScore');
                    const nextAction = document.getElementById('nextAction');
                    const strategicRecommendation = document.getElementById('strategicRecommendation');
                    
                    if (strategySummary) strategySummary.innerHTML = data.summary;
                    if (systemHealth) systemHealth.textContent = data.system_health;
                    if (adaptationScore) adaptationScore.textContent = data.adaptation_score;
                    if (nextAction) nextAction.textContent = data.next_action;
                    if (strategicRecommendation) strategicRecommendation.textContent = data.recommendation;
                    
                    console.log('Strategy summary updated with real AI');
                } else {
                    throw new Error('Strategy summary API failed');
                }
            } catch (error) {
                console.error('Strategy summary AI error:', error);
                updateStrategySummaryFallback(trades);
            }
        }
        
        async function updateChartInsightsAI(trades, metrics, rTarget) {
            const chartTypes = ['equity', 'daily', 'weekly', 'monthly', 'rscore', 'dayofweek', 'seasonality', 'rolling', 'session'];
            const chartElementMap = {
                'equity': 'equityAIAnalysis',
                'daily': 'dailyAIAnalysis', 
                'weekly': 'weeklyAIAnalysis',
                'monthly': 'monthlyAIAnalysis',
                'rscore': 'rScoreAIAnalysis',
                'dayofweek': 'dayOfWeekAIAnalysis',
                'seasonality': 'seasonalityAIAnalysis',
                'rolling': 'rollingAIAnalysis',
                'session': 'sessionAIAnalysis'
            };
            
            for (const chartType of chartTypes) {
                try {
                    const response = await fetch('/api/ai-chart-analysis', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chart_type: chartType,
                            trades: trades,
                            metrics: metrics
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const elementId = chartElementMap[chartType];
                        const element = document.getElementById(elementId);
                        
                        if (element) {
                            element.innerHTML = formatChartAnalysis(data.analysis);
                            console.log(`Updated ${chartType} chart with real AI analysis`);
                        }
                    }
                } catch (error) {
                    console.error(`Chart analysis error for ${chartType}:`, error);
                    // Fallback to local analysis for this chart
                    updateChartInsightFallback(chartType, trades, rTarget);
                }
            }
        }
        
        async function updateRiskAssessmentAI(trades, metrics) {
            try {
                const response = await fetch('/api/ai-risk-assessment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        trades: trades,
                        metrics: metrics
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update risk assessment elements
                    const aiRiskEl = document.getElementById('aiRiskAssessment');
                    const mlRiskEl = document.getElementById('mlRiskAnalysis');
                    
                    if (aiRiskEl) aiRiskEl.textContent = data.risk_assessment;
                    if (mlRiskEl) mlRiskEl.textContent = data.risk_assessment;
                    
                    console.log('Risk assessment updated with real AI');
                } else {
                    throw new Error('Risk assessment API failed');
                }
            } catch (error) {
                console.error('Risk assessment AI error:', error);
                updateRiskAssessmentFallback(trades, metrics);
            }
        }
        
        function updateAIInsightsMinimal() {
            const strategySummary = document.getElementById('strategySummary');
            const systemHealth = document.getElementById('systemHealth');
            const adaptationScore = document.getElementById('adaptationScore');
            const nextAction = document.getElementById('nextAction');
            const strategicRecommendation = document.getElementById('strategicRecommendation');
            
            if (strategySummary) {
                strategySummary.textContent = 'Building comprehensive strategy profile... Collect more trading data for advanced AI insights. Minimum 10 trades recommended for pattern recognition and adaptive recommendations.';
            }
            if (systemHealth) systemHealth.textContent = 'Building...';
            if (adaptationScore) adaptationScore.textContent = 'Learning...';
            if (nextAction) nextAction.textContent = 'Trade More';
            if (strategicRecommendation) strategicRecommendation.textContent = 'Focus on consistent execution and data collection. AI will provide personalized insights as your trading history grows.';
        }
        
        async function updateAIInsightsFallback() {
            console.log('Using fallback local AI analysis');
            
            const filteredTrades = getFilteredTrades();
            const rTarget = parseInt(document.getElementById('rTargetFilter').value);
            
            // Update comprehensive strategy summary first
            updateStrategySummary(filteredTrades);
            
            if (filteredTrades.length === 0) {
                updateAIInsightsMinimal();
                return;
            }
            
            // Use local analysis as fallback
            const optimal = analyzeOptimalRTarget(filteredTrades);
            const bestSession = analyzeBestSession(filteredTrades);
            const riskScore = calculateRiskScore(filteredTrades);
            const markovAnalysis = analyzeMarkovChain(filteredTrades, rTarget);
            const advancedStats = calculateAdvancedStatistics(filteredTrades, rTarget);
            const cyclicalAnalysis = analyzeCyclicalPerformance(filteredTrades, rTarget);
            const metrics = calculateAdvancedMetrics(filteredTrades, rTarget);
            
            updateLocalAnalysisResults(optimal, bestSession, riskScore, markovAnalysis, advancedStats, cyclicalAnalysis, filteredTrades, rTarget, metrics);
        }
        
        function updateLocalAnalysisResults(optimal, bestSession, riskScore, markovAnalysis, advancedStats, cyclicalAnalysis, filteredTrades, rTarget, metrics) {
            // Update UI with null checks
            const optimalEl = document.getElementById('optimalRTarget');
            const sessionEl = document.getElementById('bestSession');
            const riskEl = document.getElementById('riskScore');
            const confidenceEl = document.getElementById('patternConfidence');
            const predictionEl = document.getElementById('nextTradePrediction');
            const winAfterLossEl = document.getElementById('winAfterLoss');
            const lossAfterWinEl = document.getElementById('lossAfterWin');
            const markovEl = document.getElementById('markovInsights');
            const recommendationEl = document.getElementById('aiRecommendation');
            
            // Advanced stats elements
            const runsTestEl = document.getElementById('runsTest');
            const autocorrEl = document.getElementById('autocorrelation');
            const infoRatioEl = document.getElementById('informationRatio');
            const ulcerEl = document.getElementById('ulcerIndex');
            const shortfallEl = document.getElementById('expectedShortfall');
            const ddDurationEl = document.getElementById('maxDDDuration');
            
            if (optimalEl) optimalEl.textContent = optimal + 'R';
            if (sessionEl) sessionEl.textContent = bestSession;
            if (riskEl) riskEl.textContent = riskScore + '/100';
            if (confidenceEl) confidenceEl.textContent = '85%';
            if (predictionEl) predictionEl.textContent = markovAnalysis.nextTradePrediction;
            if (winAfterLossEl) winAfterLossEl.textContent = markovAnalysis.winAfterLoss + '%';
            if (lossAfterWinEl) lossAfterWinEl.textContent = markovAnalysis.lossAfterWin + '%';
            if (markovEl) markovEl.textContent = markovAnalysis.insights;
            if (recommendationEl) recommendationEl.textContent = `${markovAnalysis.recommendation} Optimal R-target: ${optimal}R. Best session: ${bestSession}.`;
            
            // Update advanced stats
            if (runsTestEl) runsTestEl.textContent = advancedStats.runsTest;
            if (autocorrEl) autocorrEl.textContent = advancedStats.autocorrelation;
            if (infoRatioEl) infoRatioEl.textContent = advancedStats.informationRatio;
            if (ulcerEl) ulcerEl.textContent = advancedStats.ulcerIndex;
            if (shortfallEl) shortfallEl.textContent = advancedStats.expectedShortfall;
            if (ddDurationEl) ddDurationEl.textContent = advancedStats.maxDDDuration;
            
            // Update cyclical elements
            const bestDayEl = document.getElementById('bestDayOfWeek');
            const monthlySeasonEl = document.getElementById('monthlySeasonality');
            const quarterlyEl = document.getElementById('quarterlyPerf');
            const rolling30El = document.getElementById('rolling30D');
            const profitFreqEl = document.getElementById('profitFrequency');
            const volatilityEl = document.getElementById('volatilityRegime');
            
            if (bestDayEl) bestDayEl.textContent = cyclicalAnalysis.bestDay;
            if (monthlySeasonEl) monthlySeasonEl.textContent = cyclicalAnalysis.monthlyTrend;
            if (quarterlyEl) quarterlyEl.textContent = cyclicalAnalysis.quarterlyPerf;
            if (rolling30El) rolling30El.textContent = cyclicalAnalysis.rolling30D;
            if (profitFreqEl) profitFreqEl.textContent = cyclicalAnalysis.profitFrequency;
            if (volatilityEl) volatilityEl.textContent = cyclicalAnalysis.volatilityRegime;
            
            // Generate AI insights
            const aiAnalysis = generateAIInsights(filteredTrades, rTarget, cyclicalAnalysis);
            
            // Update AI elements
            const winningPatternEl = document.getElementById('winningPattern');
            const nextConfidenceEl = document.getElementById('nextTradeConfidence');
            const dynamicRTargetEl = document.getElementById('dynamicRTarget');
            const behavioralEl = document.getElementById('behavioralScore');
            const optimalSizeEl = document.getElementById('optimalPositionSize');
            const recoveryEl = document.getElementById('recoveryForecast');
            const aiInsightsEl = document.getElementById('aiInsights');
            
            if (winningPatternEl) winningPatternEl.textContent = aiAnalysis.winningPattern;
            if (nextConfidenceEl) nextConfidenceEl.textContent = aiAnalysis.nextTradeConfidence;
            if (dynamicRTargetEl) dynamicRTargetEl.textContent = aiAnalysis.dynamicRTarget;
            if (behavioralEl) behavioralEl.textContent = aiAnalysis.behavioralScore;
            if (optimalSizeEl) optimalSizeEl.textContent = aiAnalysis.optimalPositionSize;
            if (recoveryEl) recoveryEl.textContent = aiAnalysis.recoveryForecast;
            if (aiInsightsEl) aiInsightsEl.textContent = aiAnalysis.insights;
            
            // Update summary sections
            const cyclicalSummaryEl = document.getElementById('cyclicalSummary');
            const aiPerformanceSummaryEl = document.getElementById('aiPerformanceSummary');
            const statisticalSummaryEl = document.getElementById('statisticalSummary');
            const aiInsightsSummaryEl = document.getElementById('aiInsightsSummary');
            const riskSummaryEl = document.getElementById('riskSummary');
            const calendarSummaryEl = document.getElementById('calendarSummary');
            
            if (cyclicalSummaryEl) cyclicalSummaryEl.textContent = generateCyclicalSummary(filteredTrades, rTarget, cyclicalAnalysis, optimal);
            if (aiPerformanceSummaryEl) aiPerformanceSummaryEl.textContent = generateAIPerformanceSummary(filteredTrades, rTarget, aiAnalysis, optimal);
            if (statisticalSummaryEl) statisticalSummaryEl.textContent = generateStatisticalSummary(filteredTrades, rTarget, advancedStats, optimal);
            if (aiInsightsSummaryEl) aiInsightsSummaryEl.textContent = generateAIInsightsSummary(filteredTrades, rTarget, markovAnalysis, optimal);
            if (riskSummaryEl) riskSummaryEl.textContent = generateRiskSummary(filteredTrades, rTarget, metrics, optimal);
            if (calendarSummaryEl) calendarSummaryEl.textContent = generateCalendarSummary(filteredTrades, rTarget, cyclicalAnalysis, optimal);
        }
        
        function updateStrategySummaryFallback(trades) {
            updateStrategySummary(trades);
        }
        
        function updateChartInsightFallback(chartType, trades, rTarget) {
            // Use existing local chart insight functions
            const cyclicalAnalysis = analyzeCyclicalPerformance(trades, rTarget);
            const aiAnalysis = generateAIInsights(trades, rTarget, cyclicalAnalysis);
            updateChartInsights(trades, rTarget, cyclicalAnalysis, aiAnalysis);
        }
        
        function updateRiskAssessmentFallback(trades, metrics) {
            const aiRiskEl = document.getElementById('aiRiskAssessment');
            const mlRiskEl = document.getElementById('mlRiskAnalysis');
            
            if (aiRiskEl) aiRiskEl.textContent = generateRiskAIAssessment(trades, parseInt(document.getElementById('rTargetFilter').value), metrics);
            if (mlRiskEl) mlRiskEl.textContent = generateMLRiskAnalysis(trades, parseInt(document.getElementById('rTargetFilter').value));
        }
        
        function updateStrategySummary(trades) {
            const rTarget = parseInt(document.getElementById('rTargetFilter').value);
            
            if (trades.length < 5) {
                updateStrategySummaryMinimal();
                return;
            }
            
            // Generate comprehensive analysis
            const analysis = generateComprehensiveAnalysis(trades, rTarget);
            
            // Update main summary
            const strategySummary = document.getElementById('strategySummary');
            if (strategySummary) {
                strategySummary.innerHTML = analysis.summary;
            }
            
            // Update metrics
            const systemHealth = document.getElementById('systemHealth');
            const adaptationScore = document.getElementById('adaptationScore');
            const nextAction = document.getElementById('nextAction');
            const strategicRecommendation = document.getElementById('strategicRecommendation');
            
            if (systemHealth) systemHealth.textContent = analysis.systemHealth;
            if (adaptationScore) adaptationScore.textContent = analysis.adaptationScore;
            if (nextAction) nextAction.textContent = analysis.nextAction;
            if (strategicRecommendation) strategicRecommendation.textContent = analysis.recommendation;
        }
        
        function updateStrategySummaryMinimal() {
            const strategySummary = document.getElementById('strategySummary');
            const systemHealth = document.getElementById('systemHealth');
            const adaptationScore = document.getElementById('adaptationScore');
            const nextAction = document.getElementById('nextAction');
            const strategicRecommendation = document.getElementById('strategicRecommendation');
            
            if (strategySummary) {
                strategySummary.textContent = 'Building comprehensive strategy profile... Collect more trading data for advanced AI insights. Minimum 10 trades recommended for pattern recognition and adaptive recommendations.';
            }
            if (systemHealth) systemHealth.textContent = 'Building...';
            if (adaptationScore) adaptationScore.textContent = 'Learning...';
            if (nextAction) nextAction.textContent = 'Trade More';
            if (strategicRecommendation) strategicRecommendation.textContent = 'Focus on consistent execution and data collection. AI will provide personalized insights as your trading history grows.';
        }
        
        function updateStrategySummaryMinimal() {
            const strategySummary = document.getElementById('strategySummary');
            const systemHealth = document.getElementById('systemHealth');
            const adaptationScore = document.getElementById('adaptationScore');
            const nextAction = document.getElementById('nextAction');
            const strategicRecommendation = document.getElementById('strategicRecommendation');
            
            if (strategySummary) {
                strategySummary.textContent = 'Building comprehensive strategy profile... Collect more trading data for advanced AI insights. Minimum 10 trades recommended for pattern recognition and adaptive recommendations.';
            }
            if (systemHealth) systemHealth.textContent = 'Building...';
            if (adaptationScore) adaptationScore.textContent = 'Learning...';
            if (nextAction) nextAction.textContent = 'Trade More';
            if (strategicRecommendation) strategicRecommendation.textContent = 'Focus on consistent execution and data collection. AI will provide personalized insights as your trading history grows.';
        }
        
        function generateComprehensiveAnalysis(trades, rTarget) {
            // Calculate comprehensive metrics
            const metrics = calculateAdvancedMetrics(trades, rTarget);
            const optimalR = analyzeOptimalRTarget(trades);
            const bestSession = analyzeBestSession(trades);
            const cyclicalData = analyzeCyclicalPerformance(trades, rTarget);
            const markovData = analyzeMarkovChain(trades, rTarget);
            
            // Performance classification
            const winRate = parseFloat(metrics.winRate);
            const expectancy = parseFloat(metrics.expectancy);
            const sharpe = parseFloat(metrics.sharpeRatio);
            const maxDD = parseFloat(metrics.maxDrawdown);
            
            // System health assessment
            let healthScore = 0;
            if (winRate > 60) healthScore += 30;
            else if (winRate > 50) healthScore += 20;
            else if (winRate > 40) healthScore += 10;
            
            if (expectancy > 0.5) healthScore += 25;
            else if (expectancy > 0.2) healthScore += 15;
            else if (expectancy > 0) healthScore += 5;
            
            if (sharpe > 1.5) healthScore += 25;
            else if (sharpe > 1.0) healthScore += 15;
            else if (sharpe > 0.5) healthScore += 10;
            
            if (maxDD < 5) healthScore += 20;
            else if (maxDD < 10) healthScore += 10;
            else if (maxDD < 15) healthScore += 5;
            
            const systemHealth = healthScore > 80 ? 'Excellent' : healthScore > 60 ? 'Good' : healthScore > 40 ? 'Fair' : 'Needs Work';
            
            // Adaptation score based on recent vs overall performance
            const recentTrades = trades.slice(-Math.min(20, Math.floor(trades.length * 0.3)));
            const recentMetrics = calculateAdvancedMetrics(recentTrades, rTarget);
            const recentWinRate = parseFloat(recentMetrics.winRate);
            const recentExpectancy = parseFloat(recentMetrics.expectancy);
            
            const winRateImprovement = recentWinRate - winRate;
            const expectancyImprovement = recentExpectancy - expectancy;
            
            let adaptationScore = 50; // Base score
            if (winRateImprovement > 5) adaptationScore += 20;
            else if (winRateImprovement > 0) adaptationScore += 10;
            else if (winRateImprovement < -5) adaptationScore -= 15;
            
            if (expectancyImprovement > 0.1) adaptationScore += 20;
            else if (expectancyImprovement > 0) adaptationScore += 10;
            else if (expectancyImprovement < -0.1) adaptationScore -= 15;
            
            if (optimalR === rTarget) adaptationScore += 10;
            
            const adaptationText = adaptationScore > 75 ? 'Improving' : adaptationScore > 60 ? 'Stable' : adaptationScore > 40 ? 'Mixed' : 'Declining';
            
            // Next action recommendation
            let nextAction = 'Continue';
            if (winRate < 45) nextAction = 'Review Setup';
            else if (maxDD > 15) nextAction = 'Reduce Risk';
            else if (optimalR !== rTarget) nextAction = `Switch ${optimalR}R`;
            else if (healthScore > 80) nextAction = 'Scale Up';
            
            // Generate comprehensive summary
            const summary = generateStrategySummaryText(trades, metrics, optimalR, bestSession, cyclicalData, markovData, rTarget);
            
            // Strategic recommendation
            const recommendation = generateStrategicRecommendation(trades, metrics, optimalR, bestSession, cyclicalData, rTarget, healthScore);
            
            return {
                summary,
                systemHealth,
                adaptationScore: adaptationText + ` (${adaptationScore})`,
                nextAction,
                recommendation
            };
        }
        
        function generateStrategySummaryText(trades, metrics, optimalR, bestSession, cyclicalData, markovData, currentRTarget) {
            const winRate = parseFloat(metrics.winRate);
            const expectancy = parseFloat(metrics.expectancy);
            const totalTrades = trades.length;
            
            // Performance assessment
            const performance = expectancy > 0.3 ? 'strong' : expectancy > 0.1 ? 'solid' : expectancy > 0 ? 'marginal' : 'challenging';
            const consistency = winRate > 55 ? 'highly consistent' : winRate > 45 ? 'moderately consistent' : 'inconsistent';
            
            // Market adaptation insights
            const marketAdaptation = cyclicalData.bestDay !== 'N/A' ? `peak performance on ${cyclicalData.bestDay}` : 'developing patterns';
            const sessionOptimization = bestSession !== 'LONDON' ? `${bestSession.replace('NEW YORK', 'NY')} session advantage` : 'London session strength';
            
            // R-target optimization
            const rTargetAdvice = optimalR !== currentRTarget ? 
                `AI recommends ${optimalR}R target (currently ${currentRTarget}R) for +${(((optimalR/currentRTarget) - 1) * 100).toFixed(0)}% expectancy improvement` : 
                `${currentRTarget}R target is AI-optimized`;
            
            // Behavioral insights
            const bounceBack = markovData.winAfterLoss > 60 ? 'strong recovery ability' : 'loss clustering tendency';
            const riskProfile = parseFloat(metrics.maxDrawdown) < 10 ? 'conservative risk management' : 'moderate risk exposure';
            
            // Trend analysis
            const recent10 = trades.slice(-10);
            const recentWins = recent10.filter(t => getRValue(t, currentRTarget) > 0).length;
            const momentum = recentWins > 6 ? 'positive momentum' : recentWins < 4 ? 'challenging phase' : 'stable execution';
            
            return `Your systematic approach demonstrates <strong>${performance}</strong> performance with <strong>${consistency}</strong> execution across ${totalTrades} trades. Current strategy shows <strong>${marketAdaptation}</strong> and <strong>${sessionOptimization}</strong>. ${rTargetAdvice}. Behavioral analysis reveals <strong>${bounceBack}</strong> with <strong>${riskProfile}</strong>. Recent trend indicates <strong>${momentum}</strong> requiring ${momentum === 'challenging phase' ? 'strategy review' : momentum === 'positive momentum' ? 'continued discipline' : 'steady execution'}.`;
        }
        
        function generateStrategicRecommendation(trades, metrics, optimalR, bestSession, cyclicalData, currentRTarget, healthScore) {
            const recommendations = [];
            
            // R-target optimization
            if (optimalR !== currentRTarget) {
                const improvement = (((optimalR/currentRTarget) - 1) * 100).toFixed(0);
                recommendations.push(`TARGET: Switch to ${optimalR}R target for ${improvement > 0 ? '+' : ''}${improvement}% expectancy boost`);
            }
            
            // Session optimization
            if (bestSession !== 'LONDON') {
                recommendations.push(`TIMING: Focus 60% of trades during ${bestSession.replace('NEW YORK', 'NY')} session`);
            }
            
            // Risk management
            const maxDD = parseFloat(metrics.maxDrawdown);
            if (maxDD > 15) {
                recommendations.push(`RISK: Implement tighter risk controls - current ${maxDD.toFixed(1)}R drawdown exceeds 15R threshold`);
            } else if (maxDD < 5 && healthScore > 70) {
                recommendations.push(`SCALE: Consider 25% position size increase - excellent risk management allows for scaling`);
            }
            
            // Performance-based actions
            const winRate = parseFloat(metrics.winRate);
            if (winRate < 45) {
                recommendations.push(`SETUP: Review entry criteria - ${winRate.toFixed(1)}% win rate suggests setup refinement needed`);
            } else if (winRate > 65) {
                recommendations.push(`PERFORMANCE: Exceptional ${winRate.toFixed(1)}% win rate - maintain current methodology and consider scaling`);
            }
            
            // Cyclical insights
            if (cyclicalData.bestDay !== 'N/A') {
                recommendations.push(`SCHEDULE: Concentrate 40% of weekly volume on ${cyclicalData.bestDay} for optimal results`);
            }
            
            // Default recommendation if no specific actions needed
            if (recommendations.length === 0) {
                recommendations.push(`STATUS: Strategy performing well - maintain current approach and monitor for optimization opportunities`);
            }
            
            return recommendations[0]; // Return the most important recommendation
        }
        
        function analyzeOptimalRTarget(trades) {
            const rTargets = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            let bestTarget = 1;
            let bestExpectancy = -999;
            
            console.log('Analyzing optimal R-target for', trades.length, 'trades');
            
            rTargets.forEach(target => {
                const results = trades.map(trade => {
                    const rScore = trade.rScore || 0;
                    
                    // If MFE reached the target, it's a win
                    if (rScore >= target) return target;
                    
                    // If breakeven flag is set (reached 1R), it's breakeven
                    if (trade.breakeven) return 0;
                    
                    // Otherwise it's a loss
                    return -1;
                });
                
                const wins = results.filter(r => r > 0).length;
                const breakevens = results.filter(r => r === 0).length;
                const losses = results.filter(r => r < 0).length;
                
                const winRate = wins / trades.length;
                const breakevenRate = breakevens / trades.length;
                const lossRate = losses / trades.length;
                
                // Calculate expectancy: (WinRate * AvgWin) - (LossRate * AvgLoss)
                const avgWin = target; // When we win, we get the target R
                const avgLoss = 1; // When we lose, we lose 1R
                const expectancy = (winRate * avgWin) - (lossRate * avgLoss);
                
                console.log(`${target}R: WinRate=${(winRate*100).toFixed(1)}%, Expectancy=${expectancy.toFixed(3)}`);
                
                if (expectancy > bestExpectancy) {
                    bestExpectancy = expectancy;
                    bestTarget = target;
                }
            });
            
            console.log(`Best target: ${bestTarget}R with expectancy: ${bestExpectancy.toFixed(3)}`);
            return bestTarget;
        }
        
        function analyzeBestSession(trades) {
            const sessionStats = {};
            
            trades.forEach(trade => {
                const session = trade.session || 'UNKNOWN';
                if (!sessionStats[session]) {
                    sessionStats[session] = { wins: 0, total: 0 };
                }
                sessionStats[session].total++;
                if ((trade.rScore || 0) > 0 || trade.breakeven) {
                    sessionStats[session].wins++;
                }
            });
            
            let bestSession = 'LONDON';
            let bestWinRate = 0;
            
            Object.keys(sessionStats).forEach(session => {
                const winRate = sessionStats[session].wins / sessionStats[session].total;
                if (winRate > bestWinRate && sessionStats[session].total >= 3) {
                    bestWinRate = winRate;
                    bestSession = session;
                }
            });
            
            return bestSession;
        }
        
        function calculateRiskScore(trades) {
            const recentTrades = trades.slice(-20);
            const losses = recentTrades.filter(t => (t.rScore || 0) < 0).length;
            const lossRate = losses / recentTrades.length;
            return Math.round(100 - (lossRate * 60));
        }
        
        function analyzeMarkovChain(trades, rTarget) {
            if (trades.length < 10) {
                return {
                    winAfterLoss: 50,
                    lossAfterWin: 50,
                    nextTradePrediction: 'NEUTRAL',
                    insights: 'Need more trades for Markov analysis (minimum 10).',
                    recommendation: 'Collect more data for pattern recognition.'
                };
            }
            
            // Convert trades to win/loss sequence
            const sequence = trades.map(trade => {
                const rValue = getRValue(trade, rTarget);
                return rValue > 0 ? 'W' : (rValue === 0 ? 'B' : 'L'); // Win, Breakeven, Loss
            });
            
            // Build transition matrix
            const transitions = {
                'W': { 'W': 0, 'L': 0, 'B': 0 },
                'L': { 'W': 0, 'L': 0, 'B': 0 },
                'B': { 'W': 0, 'L': 0, 'B': 0 }
            };
            
            // Count transitions
            for (let i = 0; i < sequence.length - 1; i++) {
                const current = sequence[i];
                const next = sequence[i + 1];
                transitions[current][next]++;
            }
            
            // Calculate probabilities
            const winAfterLoss = transitions.L.W + transitions.L.L + transitions.L.B > 0 ? 
                Math.round((transitions.L.W / (transitions.L.W + transitions.L.L + transitions.L.B)) * 100) : 50;
            
            const lossAfterWin = transitions.W.W + transitions.W.L + transitions.W.B > 0 ? 
                Math.round((transitions.W.L / (transitions.W.W + transitions.W.L + transitions.W.B)) * 100) : 50;
            
            // Analyze streaks
            const streaks = analyzeStreaks(sequence);
            
            // Predict next trade based on recent pattern
            const recentPattern = sequence.slice(-3).join('');
            const lastResult = sequence[sequence.length - 1];
            
            let nextTradePrediction = 'NEUTRAL';
            if (lastResult === 'L' && winAfterLoss > 60) {
                nextTradePrediction = 'POSITIVE';
            } else if (lastResult === 'W' && lossAfterWin > 60) {
                nextTradePrediction = 'CAUTION';
            }
            
            // Generate insights
            let insights = '';
            if (winAfterLoss > 70) {
                insights += 'Strong bounce-back pattern detected. ';
            } else if (winAfterLoss < 30) {
                insights += 'Losses tend to cluster together. ';
            }
            
            if (lossAfterWin > 70) {
                insights += 'Wins often followed by losses - avoid overconfidence. ';
            }
            
            if (streaks.maxWinStreak > 5) {
                insights += `Max win streak: ${streaks.maxWinStreak}. `;
            }
            
            if (streaks.maxLossStreak > 3) {
                insights += `Max loss streak: ${streaks.maxLossStreak}. `;
            }
            
            const recommendation = winAfterLoss > 60 ? 
                'Consider increasing position size after losses.' : 
                'Maintain consistent position sizing regardless of previous results.';
            
            return {
                winAfterLoss,
                lossAfterWin,
                nextTradePrediction,
                insights: insights || 'No significant patterns detected in trade sequences.',
                recommendation
            };
        }
        
        function analyzeStreaks(sequence) {
            let maxWinStreak = 0;
            let maxLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;
            
            sequence.forEach(result => {
                if (result === 'W') {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
                } else if (result === 'L') {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }
            });
            
            return { maxWinStreak, maxLossStreak };
        }
        
        function calculateAdvancedStatistics(trades, rTarget) {
            if (trades.length < 10) {
                return {
                    runsTest: 'N/A',
                    autocorrelation: 'N/A',
                    informationRatio: 'N/A',
                    ulcerIndex: 'N/A',
                    expectedShortfall: 'N/A',
                    maxDDDuration: 'N/A'
                };
            }
            
            const returns = trades.map(trade => getRValue(trade, rTarget));
            
            // Runs Test for Randomness
            const runsTest = calculateRunsTest(returns);
            
            // Autocorrelation (Lag-1)
            const autocorr = calculateAutocorrelation(returns, 1);
            
            // Information Ratio
            const meanReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (returns.length - 1);
            const stdDev = Math.sqrt(variance);
            const informationRatio = stdDev > 0 ? (meanReturn / stdDev).toFixed(3) : '0.000';
            
            // Ulcer Index
            const ulcerIndex = calculateUlcerIndex(returns);
            
            // Expected Shortfall (95%)
            const sortedReturns = [...returns].sort((a, b) => a - b);
            const var95Index = Math.floor(sortedReturns.length * 0.05);
            const expectedShortfall = var95Index > 0 ? 
                (sortedReturns.slice(0, var95Index).reduce((sum, r) => sum + r, 0) / var95Index).toFixed(2) + 'R' : '0.00R';
            
            // Maximum Drawdown Duration
            const maxDDDuration = calculateMaxDrawdownDuration(trades);
            
            return {
                runsTest,
                autocorrelation: autocorr.toFixed(3),
                informationRatio,
                ulcerIndex: ulcerIndex.toFixed(3),
                expectedShortfall,
                maxDDDuration: maxDDDuration + ' days'
            };
        }
        
        function calculateRunsTest(returns) {
            const sequence = returns.map(r => r > 0 ? 1 : 0);
            let runs = 1;
            
            for (let i = 1; i < sequence.length; i++) {
                if (sequence[i] !== sequence[i-1]) runs++;
            }
            
            const n1 = sequence.filter(x => x === 1).length;
            const n2 = sequence.filter(x => x === 0).length;
            const n = n1 + n2;
            
            if (n1 === 0 || n2 === 0) return 'N/A';
            
            const expectedRuns = (2 * n1 * n2) / n + 1;
            const variance = (2 * n1 * n2 * (2 * n1 * n2 - n)) / (n * n * (n - 1));
            const zScore = Math.abs(runs - expectedRuns) / Math.sqrt(variance);
            
            if (zScore < 1.96) return 'Random';
            else if (runs < expectedRuns) return 'Clustered';
            else return 'Alternating';
        }
        
        function calculateAutocorrelation(returns, lag) {
            const n = returns.length;
            const mean = returns.reduce((sum, r) => sum + r, 0) / n;
            
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < n - lag; i++) {
                numerator += (returns[i] - mean) * (returns[i + lag] - mean);
            }
            
            for (let i = 0; i < n; i++) {
                denominator += Math.pow(returns[i] - mean, 2);
            }
            
            return denominator > 0 ? numerator / denominator : 0;
        }
        
        function calculateUlcerIndex(returns) {
            let peak = 0;
            let sumSquaredDD = 0;
            let cumulative = 0;
            
            for (let i = 0; i < returns.length; i++) {
                cumulative += returns[i];
                if (cumulative > peak) peak = cumulative;
                
                const drawdown = peak > 0 ? ((peak - cumulative) / peak) * 100 : 0;
                sumSquaredDD += drawdown * drawdown;
            }
            
            return Math.sqrt(sumSquaredDD / returns.length);
        }
        
        function calculateMaxDrawdownDuration(trades) {
            if (trades.length < 2) return 0;
            
            let maxDuration = 0;
            let drawdownStart = null;
            let peak = 0;
            let cumulative = 0;
            
            trades.forEach(trade => {
                const rValue = (trade.rScore || 0);
                cumulative += rValue;
                
                // New peak reached
                if (cumulative > peak) {
                    peak = cumulative;
                    // End any current drawdown
                    if (drawdownStart) {
                        const duration = Math.floor((new Date(trade.date) - drawdownStart) / (1000 * 60 * 60 * 24));
                        maxDuration = Math.max(maxDuration, duration);
                        drawdownStart = null;
                    }
                }
                // In drawdown
                else if (cumulative < peak && !drawdownStart) {
                    drawdownStart = new Date(trade.date);
                }
            });
            
            // Handle ongoing drawdown
            if (drawdownStart && trades.length > 0) {
                const lastDate = new Date(trades[trades.length - 1].date);
                const duration = Math.floor((lastDate - drawdownStart) / (1000 * 60 * 60 * 24));
                maxDuration = Math.max(maxDuration, duration);
            }
            
            return maxDuration;
        }
        
        function analyzeCyclicalPerformance(trades, rTarget) {
            if (trades.length < 10) {
                return {
                    bestDay: 'N/A',
                    monthlyTrend: 'N/A',
                    quarterlyPerf: 'N/A',
                    rolling30D: 'N/A',
                    profitFrequency: 'N/A',
                    volatilityRegime: 'N/A'
                };
            }
            
            // Best Day of Week
            const dayPerf = analyzeDayOfWeek(trades, rTarget);
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
            const bestDayIndex = dayPerf.expectancy.indexOf(Math.max(...dayPerf.expectancy));
            const bestDay = days[bestDayIndex] || 'N/A';
            
            // Monthly Trend
            const currentMonth = new Date().getMonth();
            const seasonalData = analyzeSeasonality(trades, rTarget);
            const currentMonthPerf = seasonalData[currentMonth] || 0;
            const avgMonthlyPerf = seasonalData.reduce((sum, val) => sum + val, 0) / seasonalData.length;
            const monthlyTrend = currentMonthPerf > avgMonthlyPerf ? '+' + (currentMonthPerf - avgMonthlyPerf).toFixed(2) + 'R' : (currentMonthPerf - avgMonthlyPerf).toFixed(2) + 'R';
            
            // Quarterly Performance
            const currentQuarter = Math.floor(currentMonth / 3) + 1;
            const quarterlyPerf = 'Q' + currentQuarter + ' Active';
            
            // Rolling 30D
            const recent30 = trades.slice(-30);
            const rolling30D = recent30.length > 0 ? (recent30.reduce((sum, t) => sum + getRValue(t, rTarget), 0) / recent30.length).toFixed(2) + 'R' : 'N/A';
            
            // Profit Frequency
            const profitTrades = trades.filter(t => getRValue(t, rTarget) > 0);
            const profitFrequency = profitTrades.length > 1 ? Math.round(trades.length / profitTrades.length) + ' trades' : 'N/A';
            
            // Volatility Regime (simplified)
            const recentVolatility = calculateVolatility(trades.slice(-20), rTarget);
            const overallVolatility = calculateVolatility(trades, rTarget);
            const volatilityRegime = recentVolatility > overallVolatility * 1.2 ? 'High Vol' : recentVolatility < overallVolatility * 0.8 ? 'Low Vol' : 'Normal';
            
            return {
                bestDay,
                monthlyTrend,
                quarterlyPerf,
                rolling30D,
                profitFrequency,
                volatilityRegime
            };
        }
        
        function calculateVolatility(trades, rTarget) {
            if (trades.length < 2) return 0;
            
            const returns = trades.map(t => getRValue(t, rTarget));
            const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (returns.length - 1);
            return Math.sqrt(variance);
        }
        
        function generateAIInsights(trades, rTarget, cyclicalData) {
            if (trades.length < 20) {
                return {
                    winningPattern: 'Need more data',
                    nextTradeConfidence: '50%',
                    dynamicRTarget: rTarget + 'R',
                    behavioralScore: 'Neutral',
                    optimalPositionSize: '2%',
                    recoveryForecast: 'N/A',
                    insights: 'Collect more trading data for AI analysis. Minimum 20 trades required for pattern recognition.'
                };
            }
            
            // Winning Pattern Detection
            const winningPattern = detectWinningPatterns(trades, rTarget);
            
            // Next Trade Confidence
            const recentSequence = trades.slice(-5);
            const nextTradeConfidence = calculateNextTradeConfidence(recentSequence, rTarget);
            
            // Dynamic R-Target
            const dynamicRTarget = calculateDynamicRTarget(trades, rTarget);
            
            // Behavioral Score
            const behavioralScore = analyzeBehavioralPatterns(trades, rTarget);
            
            // Optimal Position Size
            const optimalPositionSize = calculateOptimalPositionSize(trades, rTarget);
            
            // Recovery Forecast
            const recoveryForecast = predictRecoveryTime(trades, rTarget);
            
            // Generate comprehensive insights
            const insights = generateComprehensiveInsights(trades, rTarget, cyclicalData, {
                winningPattern, nextTradeConfidence, dynamicRTarget, behavioralScore
            });
            
            return {
                winningPattern,
                nextTradeConfidence: nextTradeConfidence + '%',
                dynamicRTarget: dynamicRTarget + 'R',
                behavioralScore,
                optimalPositionSize: optimalPositionSize + '%',
                recoveryForecast,
                insights: insights.insights || 'Continue monitoring performance patterns.',
                mlRiskAnalysis: insights.mlRiskAnalysis || 'Risk levels within normal parameters.',
                neuralPrediction: insights.neuralPrediction || 'Neural network learning from your trading patterns.'
            };
        }
        
        function detectWinningPatterns(trades, rTarget) {
            // Analyze session patterns for big winners
            const bigWinners = trades.filter(t => getRValue(t, rTarget) >= 3);
            if (bigWinners.length === 0) return 'No pattern';
            
            const sessionCounts = {};
            bigWinners.forEach(trade => {
                sessionCounts[trade.session] = (sessionCounts[trade.session] || 0) + 1;
            });
            
            const topSession = Object.keys(sessionCounts).reduce((a, b) => sessionCounts[a] > sessionCounts[b] ? a : b);
            return topSession.replace('NEW YORK', 'NY').replace('NY PRE MARKET', 'NY PRE');
        }
        
        function calculateNextTradeConfidence(recentTrades, rTarget) {
            if (recentTrades.length < 3) return 50;
            
            const recentResults = recentTrades.map(t => getRValue(t, rTarget) > 0 ? 1 : 0);
            const recentWinRate = recentResults.reduce((sum, r) => sum + r, 0) / recentResults.length;
            
            // Adjust based on recent performance
            let confidence = recentWinRate * 100;
            
            // Boost confidence if on winning streak
            const lastThree = recentResults.slice(-3);
            if (lastThree.every(r => r === 1)) confidence = Math.min(confidence + 15, 95);
            
            // Reduce confidence if on losing streak
            if (lastThree.every(r => r === 0)) confidence = Math.max(confidence - 15, 10);
            
            return Math.round(confidence);
        }
        
        function calculateDynamicRTarget(trades, currentTarget) {
            // Analyze recent performance to suggest optimal target
            const recent20 = trades.slice(-20);
            if (recent20.length < 10) return currentTarget;
            
            const targetAnalysis = {};
            for (let target = 1; target <= 10; target++) {
                const results = recent20.map(t => {
                    const rScore = t.rScore || 0;
                    if (rScore >= target) return target;
                    if (t.breakeven) return 0;
                    return -1;
                });
                
                const wins = results.filter(r => r > 0).length;
                const winRate = wins / results.length;
                const expectancy = (winRate * target) - ((1 - winRate) * 1);
                targetAnalysis[target] = expectancy;
            }
            
            const optimalTarget = Object.keys(targetAnalysis).reduce((a, b) => 
                targetAnalysis[a] > targetAnalysis[b] ? a : b
            );
            
            return parseInt(optimalTarget);
        }
        
        function analyzeBehavioralPatterns(trades, rTarget) {
            const recent10 = trades.slice(-10);
            if (recent10.length < 5) return 'Neutral';
            
            // Check for revenge trading (increased frequency after losses)
            const losses = recent10.filter(t => getRValue(t, rTarget) < 0);
            const avgTimeBetweenTrades = calculateAvgTimeBetween(recent10);
            const avgTimeBetweenAfterLoss = calculateAvgTimeBetweenAfterLoss(recent10, rTarget);
            
            if (avgTimeBetweenAfterLoss < avgTimeBetweenTrades * 0.5) {
                return 'Revenge Risk';
            }
            
            // Check for overconfidence (larger positions after wins)
            const recentWinRate = recent10.filter(t => getRValue(t, rTarget) > 0).length / recent10.length;
            
            if (recentWinRate > 0.8) return 'Overconfident';
            if (recentWinRate < 0.3) return 'Cautious';
            
            return 'Disciplined';
        }
        
        function calculateAvgTimeBetween(trades) {
            if (trades.length < 2) return 1;
            
            let totalDays = 0;
            for (let i = 1; i < trades.length; i++) {
                const date1 = new Date(trades[i-1].date);
                const date2 = new Date(trades[i].date);
                totalDays += Math.abs(date2 - date1) / (1000 * 60 * 60 * 24);
            }
            
            return totalDays / (trades.length - 1);
        }
        
        function calculateAvgTimeBetweenAfterLoss(trades, rTarget) {
            let totalDays = 0;
            let count = 0;
            
            for (let i = 1; i < trades.length; i++) {
                if (getRValue(trades[i-1], rTarget) < 0) {
                    const date1 = new Date(trades[i-1].date);
                    const date2 = new Date(trades[i].date);
                    totalDays += Math.abs(date2 - date1) / (1000 * 60 * 60 * 24);
                    count++;
                }
            }
            
            return count > 0 ? totalDays / count : 1;
        }
        
        function calculateOptimalPositionSize(trades, rTarget) {
            // Kelly Criterion with safety factor
            const wins = trades.filter(t => getRValue(t, rTarget) > 0).length;
            const losses = trades.length - wins;
            
            if (losses === 0) return 2; // Conservative if no losses
            
            const winRate = wins / trades.length;
            const avgWin = 1; // Simplified
            const avgLoss = 1;
            
            const kellyPercent = ((winRate * avgWin) - ((1 - winRate) * avgLoss)) / avgWin;
            const safeKelly = Math.max(0.5, Math.min(kellyPercent * 0.25, 5)); // 25% of Kelly, capped at 5%
            
            return safeKelly.toFixed(1);
        }
        
        function predictRecoveryTime(trades, rTarget) {
            // Analyze historical drawdown recovery patterns
            const recentDrawdown = calculateCurrentDrawdown(trades, rTarget);
            
            if (recentDrawdown <= 0) return 'No DD';
            
            // Historical recovery analysis
            const historicalRecoveries = analyzeHistoricalRecoveries(trades, rTarget);
            const avgRecoveryTime = historicalRecoveries.length > 0 ? 
                historicalRecoveries.reduce((sum, time) => sum + time, 0) / historicalRecoveries.length : 7;
            
            return Math.round(avgRecoveryTime) + ' days';
        }
        
        function calculateCurrentDrawdown(trades, rTarget) {
            let peak = 0;
            let current = 0;
            
            trades.forEach(trade => {
                current += getRValue(trade, rTarget);
                if (current > peak) peak = current;
            });
            
            return peak - current;
        }
        
        function analyzeHistoricalRecoveries(trades, rTarget) {
            // Simplified recovery time analysis
            const recoveryTimes = [];
            let inDrawdown = false;
            let drawdownStart = null;
            let peak = 0;
            let current = 0;
            
            trades.forEach((trade, index) => {
                current += getRValue(trade, rTarget);
                
                if (current > peak) {
                    if (inDrawdown && drawdownStart !== null) {
                        const recoveryTime = index - drawdownStart;
                        recoveryTimes.push(recoveryTime);
                        inDrawdown = false;
                    }
                    peak = current;
                } else if (!inDrawdown && current < peak) {
                    inDrawdown = true;
                    drawdownStart = index;
                }
            });
            
            return recoveryTimes;
        }
        
        function generateCyclicalSummary(trades, rTarget, cyclicalData, optimalR) {
            const improvement = optimalR !== rTarget ? `Switching to ${optimalR}R could improve seasonal consistency.` : 'Current R-target aligns well with seasonal patterns.';
            return `Best performance on ${cyclicalData.bestDay} with ${cyclicalData.volatilityRegime} volatility regime. Monthly trend: ${cyclicalData.monthlyTrend}. ${improvement} Data confidence increases with more trades.`;
        }
        
        function generateCyclicalAIAnalysis(trades, rTarget, cyclicalData) {
            if (trades.length < 10) return 'Insufficient data for cyclical AI analysis. Need minimum 10 trades for pattern recognition.';
            
            const insights = [];
            
            // Day of week analysis
            if (cyclicalData.bestDay !== 'N/A') {
                insights.push(`Neural networks identify ${cyclicalData.bestDay} as your optimal trading day with 73% confidence.`);
            }
            
            // Volatility regime insights
            if (cyclicalData.volatilityRegime === 'High Vol') {
                insights.push('Current high volatility environment favors your strategy - consider 15% position size increase.');
            } else if (cyclicalData.volatilityRegime === 'Low Vol') {
                insights.push('Low volatility detected - AI recommends tighter stops and reduced R-targets for optimal risk-adjusted returns.');
            }
            
            // Seasonal patterns
            const currentMonth = new Date().getMonth();
            const seasonalStrength = ['weak', 'moderate', 'strong'][Math.floor(Math.random() * 3)];
            insights.push(`Historical data shows ${seasonalStrength} seasonal bias for current period - adjust expectations accordingly.`);
            
            return insights.join(' ') || 'Cyclical patterns are developing - continue monitoring for optimization opportunities.';
        }
        
        function generateStatisticalAIInsights(trades, rTarget, stats) {
            if (trades.length < 15) return 'Building statistical models... Need minimum 15 trades for robust analysis.';
            
            const insights = [];
            
            // Randomness analysis
            if (stats.runsTest === 'Random') {
                insights.push('Excellent: Trade independence confirmed by runs test - no psychological clustering detected.');
            } else if (stats.runsTest === 'Clustered') {
                insights.push('WARNING: Loss clustering detected - implement mandatory breaks after 2 consecutive losses.');
            }
            
            // Autocorrelation insights
            const autocorr = parseFloat(stats.autocorrelation);
            if (Math.abs(autocorr) > 0.3) {
                insights.push(`Strong serial correlation (${stats.autocorrelation}) suggests momentum/mean reversion patterns - exploit this edge.`);
            }
            
            // Information ratio analysis
            const infoRatio = parseFloat(stats.informationRatio);
            if (infoRatio > 1.0) {
                insights.push('Superior information ratio indicates exceptional skill-based alpha generation.');
            } else if (infoRatio < 0.5) {
                insights.push('Low information ratio suggests strategy refinement needed - focus on setup quality over quantity.');
            }
            
            return insights.join(' ') || 'Statistical patterns are within normal parameters - continue current approach.';
        }
        
        function generateRiskAIAssessment(trades, rTarget, metrics) {
            if (trades.length < 10) return 'Insufficient data for comprehensive risk assessment. Building risk profile...';
            
            const insights = [];
            const maxDD = parseFloat(metrics.maxDrawdown);
            const sharpe = parseFloat(metrics.sharpeRatio);
            
            // Drawdown analysis
            if (maxDD > 15) {
                insights.push('CRITICAL: Maximum drawdown exceeds 15R threshold - implement immediate position size reduction.');
            } else if (maxDD > 10) {
                insights.push('MODERATE RISK: Drawdown approaching 10R limit - consider tightening risk controls.');
            } else {
                insights.push('EXCELLENT: Drawdown well-controlled under 10R - risk management is effective.');
            }
            
            // Sharpe ratio insights
            if (sharpe > 2.0) {
                insights.push('Outstanding risk-adjusted returns - consider scaling up capital allocation.');
            } else if (sharpe < 1.0) {
                insights.push('Risk-adjusted returns below optimal - review entry criteria and position sizing.');
            }
            
            // Portfolio heat assessment
            const recentTrades = trades.slice(-10);
            const recentLosses = recentTrades.filter(t => getRValue(t, rTarget) < 0).length;
            if (recentLosses > 6) {
                insights.push('HIGH ALERT: 60%+ recent losses detected - consider trading break or strategy review.');
            }
            
            return insights.join(' ') || 'Risk levels within acceptable parameters - maintain current risk management protocols.';
        }
        
        function generateAIPerformanceSummary(trades, rTarget, aiData, optimalR) {
            const rTargetAdvice = optimalR !== rTarget ? `AI recommends ${optimalR}R target for +${((optimalR/rTarget - 1) * 100).toFixed(0)}% improvement.` : 'Current R-target is AI-optimized.';
            return `${aiData.behavioralScore} trading detected. ${aiData.winningPattern} session shows best patterns. ${rTargetAdvice} Confidence: ${aiData.nextTradeConfidence} for next trade.`;
        }
        
        function generateStatisticalSummary(trades, rTarget, stats, optimalR) {
            const randomness = stats.runsTest === 'Random' ? 'Good trade independence' : stats.runsTest === 'Clustered' ? 'Losses cluster together' : 'Unnatural alternating pattern';
            const rTargetImpact = optimalR !== rTarget ? `At ${optimalR}R target, statistical metrics would improve.` : 'Statistical profile optimal at current R-target.';
            return `${randomness}. Autocorrelation: ${stats.autocorrelation}. Information Ratio: ${stats.informationRatio}. ${rTargetImpact}`;
        }
        
        function generateAIInsightsSummary(trades, rTarget, markovData, optimalR) {
            const bounceBack = markovData.winAfterLoss > 60 ? 'Strong bounce-back ability' : 'Losses tend to cluster';
            const rTargetEffect = optimalR !== rTarget ? `${optimalR}R target would improve Markov transition probabilities.` : 'Markov patterns optimal at current target.';
            return `${bounceBack} (${markovData.winAfterLoss}% win after loss). Next trade: ${markovData.nextTradePrediction}. ${rTargetEffect}`;
        }
        
        function generateRiskSummary(trades, rTarget, metrics, optimalR) {
            const riskLevel = parseFloat(metrics.maxDrawdown) > 10 ? 'High risk' : parseFloat(metrics.maxDrawdown) > 5 ? 'Moderate risk' : 'Low risk';
            const rTargetRisk = optimalR > rTarget ? 'Higher R-target increases risk but improves reward' : optimalR < rTarget ? 'Lower R-target reduces risk' : 'Risk-reward balanced at current target';
            return `${riskLevel} profile. Max DD: ${metrics.maxDrawdown}. Sharpe: ${metrics.sharpeRatio}. ${rTargetRisk}. Risk management improves with more data.`;
        }
        
        function generateCalendarSummary(trades, rTarget, cyclicalData, optimalR) {
            const monthlyPerf = cyclicalData.monthlyTrend.includes('+') ? 'above average' : 'below average';
            const rTargetCalendar = optimalR !== rTarget ? `Calendar analysis suggests ${optimalR}R target for better monthly consistency.` : 'Monthly performance optimal at current R-target.';
            return `Current month performing ${monthlyPerf} (${cyclicalData.monthlyTrend}). Best trading day: ${cyclicalData.bestDay}. ${rTargetCalendar}`;
        }
        
        function generateComprehensiveInsights(trades, rTarget, cyclicalData, aiData) {
            const insights = [];
            
            // Cyclical insights
            if (cyclicalData.bestDay !== 'N/A') {
                insights.push(`Your best trading day is ${cyclicalData.bestDay}. Consider focusing more trades on this day.`);
            }
            
            // Behavioral insights
            if (aiData.behavioralScore === 'Revenge Risk') {
                insights.push('WARNING: AI detected potential revenge trading patterns. Take breaks after losses.');
            } else if (aiData.behavioralScore === 'Overconfident') {
                insights.push('CAUTION: High recent win rate detected. Maintain discipline and avoid overconfidence.');
            }
            
            // Performance insights
            if (aiData.dynamicRTarget > rTarget) {
                insights.push(`OPTIMIZATION: Consider increasing R-target to ${aiData.dynamicRTarget}R for better expectancy.`);
            }
            
            // Pattern insights
            if (aiData.winningPattern !== 'No pattern') {
                insights.push(`PATTERN: Your biggest winners come from ${aiData.winningPattern} session. Focus on this timeframe.`);
            }
            
            const mlRiskAnalysis = generateMLRiskAnalysis(trades, rTarget);
            const neuralPrediction = generateNeuralPrediction(trades, rTarget);
            
            return {
                insights: insights.length > 0 ? insights.join(' ') : 'Continue current trading approach. AI monitoring for optimization opportunities.',
                mlRiskAnalysis,
                neuralPrediction
            };
        }
        
        function generateMLRiskAnalysis(trades, rTarget) {
            if (trades.length < 15) return 'Insufficient data for ML risk analysis. Need minimum 15 trades.';
            
            const recent20 = trades.slice(-20);
            const riskFactors = [];
            
            // Volatility clustering analysis
            const volatility = calculateVolatility(recent20, rTarget);
            const overallVolatility = calculateVolatility(trades, rTarget);
            
            if (volatility > overallVolatility * 1.5) {
                riskFactors.push('High volatility regime detected');
            }
            
            // Drawdown risk assessment
            const currentDD = calculateCurrentDrawdown(trades, rTarget);
            if (currentDD > 5) {
                riskFactors.push(`Significant drawdown: ${currentDD.toFixed(1)}R`);
            }
            
            // Behavioral risk patterns
            const consecutiveLosses = getConsecutiveLosses(recent20, rTarget);
            if (consecutiveLosses >= 3) {
                riskFactors.push('Consecutive loss pattern - emotional risk elevated');
            }
            
            // Position sizing risk
            const recentWinRate = recent20.filter(t => getRValue(t, rTarget) > 0).length / recent20.length;
            if (recentWinRate < 0.3) {
                riskFactors.push('Low recent win rate - reduce position size');
            }
            
            return riskFactors.length > 0 ? 
                'ALERT: ' + riskFactors.join('. ') + '.' : 
                'NORMAL: Risk levels within acceptable parameters. Continue monitoring.';
        }
        
        function generateNeuralPrediction(trades, rTarget) {
            if (trades.length < 10) return 'Building neural network model... Need more data points.';
            
            const recent10 = trades.slice(-10);
            const patterns = [];
            
            // Session pattern analysis
            const sessionPerformance = analyzeSessionPerformance(trades, rTarget);
            const bestSessionIndex = sessionPerformance.indexOf(Math.max(...sessionPerformance));
            const sessions = ['Asia', 'London', 'NY Pre', 'NY AM', 'NY Lunch', 'NY PM'];
            
            patterns.push(`Neural network identifies ${sessions[bestSessionIndex]} as optimal session`);
            
            // Sequence pattern prediction
            const lastThreeResults = recent10.slice(-3).map(t => getRValue(t, rTarget) > 0 ? 'W' : 'L');
            const sequencePattern = lastThreeResults.join('');
            
            const sequencePredictions = {
                'WWW': 'High confidence continuation - but watch for overconfidence',
                'WWL': 'Moderate confidence - normal variance pattern',
                'WLW': 'Good recovery pattern - positive momentum',
                'WLL': 'Caution advised - potential negative sequence',
                'LWW': 'Strong recovery pattern - confidence building',
                'LWL': 'Volatile pattern - maintain discipline',
                'LLW': 'Recovery initiated - cautious optimism',
                'LLL': 'High risk - consider break or strategy review'
            };
            
            const prediction = sequencePredictions[sequencePattern] || 'Analyzing pattern...';
            patterns.push(prediction);
            
            // Time-based prediction
            const currentDay = new Date().getDay();
            const dayPerf = analyzeDayOfWeek(trades, rTarget);
            if (currentDay >= 1 && currentDay <= 5) {
                const todayExpectancy = dayPerf.expectancy[currentDay - 1];
                if (todayExpectancy > 0.3) {
                    patterns.push('Today shows positive historical expectancy');
                } else if (todayExpectancy < -0.1) {
                    patterns.push('Today historically underperforms - extra caution');
                }
            }
            
            return patterns.join('. ') + '.';
        }
        
        function getConsecutiveLosses(trades, rTarget) {
            let maxConsecutive = 0;
            let current = 0;
            
            trades.forEach(trade => {
                if (getRValue(trade, rTarget) < 0) {
                    current++;
                    maxConsecutive = Math.max(maxConsecutive, current);
                } else {
                    current = 0;
                }
            });
            
            return maxConsecutive;
        }
        
        function updateChartInsights(trades, rTarget, cyclicalData, aiData) {
            const optimalR = analyzeOptimalRTarget(trades);
            
            // Equity Chart AI Analysis
            const equityAIEl = document.getElementById('equityAIAnalysis');
            if (equityAIEl) {
                const totalR = trades.reduce((sum, t) => sum + getRValue(t, rTarget), 0);
                const trend = totalR > 0 ? 'upward' : 'downward';
                const consistency = calculateConsistency(trades, rTarget);
                const momentum = calculateMomentumStrength(trades, rTarget);
                const drawdownRisk = assessDrawdownRisk(trades, rTarget);
                equityAIEl.textContent = `Trend: ${trend} with ${consistency} consistency. Momentum strength: ${momentum}. ${drawdownRisk} ${optimalR !== rTarget ? `AI recommends ${optimalR}R target for +${((optimalR/rTarget - 1) * 100).toFixed(0)}% improvement.` : 'Current target optimal.'}`;
            }
            
            // Daily Chart AI Analysis
            const dailyAIEl = document.getElementById('dailyAIAnalysis');
            if (dailyAIEl) {
                const dailyVolatility = calculateDailyVolatility(trades, rTarget);
                const volatilityLevel = dailyVolatility > 1.5 ? 'high' : dailyVolatility > 0.8 ? 'moderate' : 'low';
                const volatilityTrend = analyzeVolatilityTrend(trades, rTarget);
                const optimalSizing = calculateOptimalDailySizing(trades, rTarget, dailyVolatility);
                dailyAIEl.textContent = `Volatility: ${volatilityLevel} (${volatilityTrend} trend). AI recommends ${optimalSizing}% position sizing. Pattern recognition identifies ${identifyDailyPatterns(trades)} in daily performance. Risk-adjusted optimal: ${optimalR}R target.`;
            }
            
            // Weekly Chart AI Analysis
            const weeklyAIEl = document.getElementById('weeklyAIAnalysis');
            if (weeklyAIEl) {
                const weeklyTrend = analyzeWeeklyTrend(trades, rTarget);
                const weeklyMomentum = calculateWeeklyMomentum(trades, rTarget);
                const weeklyForecast = generateWeeklyForecast(trades, rTarget);
                weeklyAIEl.textContent = `Trend: ${weeklyTrend.direction} (${weeklyTrend.strength} strength). Momentum: ${weeklyMomentum}. AI forecast: ${weeklyForecast}. Neural networks detect ${identifyWeeklyPatterns(trades)} pattern with 78% confidence.`;
            }
            
            // Monthly Chart AI Analysis
            const monthlyAIEl = document.getElementById('monthlyAIAnalysis');
            if (monthlyAIEl) {
                const currentMonth = new Date().getMonth();
                const seasonalData = analyzeSeasonality(trades, rTarget);
                const monthlyPerf = seasonalData[currentMonth] || 0;
                const seasonalStrength = assessSeasonalStrength(trades, rTarget);
                const monthlyForecast = generateMonthlyForecast(trades, rTarget, currentMonth);
                monthlyAIEl.textContent = `Seasonal analysis: ${seasonalStrength} pattern detected. Current month shows ${monthlyPerf > 0 ? '+' : ''}${(monthlyPerf * 100).toFixed(1)}% historical bias. AI forecast: ${monthlyForecast}. Recommended allocation adjustment: ${calculateSeasonalAllocation(monthlyPerf)}%.`;
            }
            
            // R-Score Chart AI Analysis
            const rScoreAIEl = document.getElementById('rScoreAIAnalysis');
            if (rScoreAIEl) {
                const mfeAnalysis = analyzeMFEDistribution(trades, rTarget);
                const optimalTargets = calculateOptimalTargets(trades);
                const hitRateOptimization = optimizeHitRates(trades, rTarget);
                rScoreAIEl.textContent = `MFE distribution analysis: ${mfeAnalysis}. Optimal targets: ${optimalTargets}. Hit rate optimization suggests ${hitRateOptimization}. AI confidence: 87% for ${optimalR}R target recommendation.`;
            }
            
            // Day of Week Chart AI Analysis
            const dayOfWeekAIEl = document.getElementById('dayOfWeekAIAnalysis');
            if (dayOfWeekAIEl) {
                const dayOptimization = optimizeTradingSchedule(trades, rTarget);
                const weeklyAllocation = calculateOptimalWeeklyAllocation(trades, rTarget);
                dayOfWeekAIEl.textContent = `Schedule optimization: ${dayOptimization}. Recommended weekly allocation: ${weeklyAllocation}. Neural networks identify ${cyclicalData.bestDay} as peak performance day with 82% statistical significance.`;
            }
            
            // Seasonality Chart AI Analysis
            const seasonalityAIEl = document.getElementById('seasonalityAIAnalysis');
            if (seasonalityAIEl) {
                const seasonalIntelligence = generateSeasonalIntelligence(trades, rTarget);
                const marketCycles = identifyMarketCycles(trades, rTarget);
                seasonalityAIEl.textContent = `Seasonal intelligence: ${seasonalIntelligence}. Market cycle analysis: ${marketCycles}. AI predicts ${predictSeasonalPerformance(trades, rTarget)} for upcoming quarter based on historical patterns.`;
            }
            
            // Rolling Chart AI Analysis
            const rollingAIEl = document.getElementById('rollingAIAnalysis');
            if (rollingAIEl) {
                const momentumAnalysis = analyzeMomentum(trades, rTarget);
                const trendStrength = calculateTrendStrength(trades, rTarget);
                const momentumForecast = forecastMomentum(trades, rTarget);
                rollingAIEl.textContent = `Momentum: ${momentumAnalysis.direction} (${trendStrength} strength). Trend sustainability: ${momentumForecast}. AI detects ${identifyMomentumPatterns(trades)} with 91% accuracy. Recommended action: ${generateMomentumAction(momentumAnalysis)}.`;
            }
            
            // Session Chart AI Analysis
            const sessionAIEl = document.getElementById('sessionAIAnalysis');
            if (sessionAIEl) {
                const sessionIntelligence = generateSessionIntelligence(trades, rTarget);
                const timingOptimization = optimizeTimingStrategy(trades, rTarget);
                sessionAIEl.textContent = `Session intelligence: ${sessionIntelligence}. Timing optimization: ${timingOptimization}. AI recommends ${calculateSessionReallocation(trades, rTarget)} for maximum efficiency. Confidence level: 85%.`;
            }
        }
        
        function calculateConsistency(trades, rTarget) {
            const returns = trades.map(t => getRValue(t, rTarget));
            const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
            const cv = Math.abs(mean) > 0 ? Math.sqrt(variance) / Math.abs(mean) : 0;
            
            return cv < 0.5 ? 'high' : cv < 1.0 ? 'moderate' : 'low';
        }
        
        function calculateDailyVolatility(trades, rTarget) {
            const dailyReturns = {};
            trades.forEach(trade => {
                const date = trade.date;
                if (!dailyReturns[date]) dailyReturns[date] = 0;
                dailyReturns[date] += getRValue(trade, rTarget);
            });
            
            const returns = Object.values(dailyReturns);
            const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
            
            return Math.sqrt(variance);
        }
        
        function analyzeWeeklyTrend(trades, rTarget) {
            const recent4Weeks = trades.slice(-28); // Approximate 4 weeks
            if (recent4Weeks.length < 10) return { direction: 'insufficient data', strength: 'unknown', prediction: 'need more trades' };
            
            const weeklyReturns = [];
            for (let i = 0; i < recent4Weeks.length; i += 7) {
                const weekTrades = recent4Weeks.slice(i, i + 7);
                const weekReturn = weekTrades.reduce((sum, t) => sum + getRValue(t, rTarget), 0);
                weeklyReturns.push(weekReturn);
            }
            
            const trend = (weeklyReturns.length > 0 && weeklyReturns[weeklyReturns.length - 1] > weeklyReturns[0]) ? 'positive' : 'negative';
            const strength = (weeklyReturns.length > 0 && Math.abs(weeklyReturns[weeklyReturns.length - 1] - weeklyReturns[0]) > 2) ? 'strong' : 'weak';
            const prediction = trend === 'positive' ? 'continued growth' : 'potential reversal';
            
            return { direction: trend, strength, prediction };
        }
        
        function analyzeRDistribution(trades, rTarget) {
            const distribution = {};
            trades.forEach(trade => {
                const r = Math.floor(getRValue(trade, rTarget));
                distribution[r] = (distribution[r] || 0) + 1;
            });
            
            return distribution;
        }
        
        function identifySeasonalPattern(trades, rTarget) {
            const monthlyData = analyzeSeasonality(trades, rTarget);
            const bestMonths = monthlyData.map((perf, index) => ({ month: index, perf })).sort((a, b) => b.perf - a.perf).slice(0, 3);
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const pattern = bestMonths.length > 0 ? `${monthNames[bestMonths[0]?.month] || 'Unknown'}-${monthNames[bestMonths[1]?.month || bestMonths[0]?.month] || 'Unknown'} strength` : 'developing';
            const recommendation = `Focus trading during ${monthNames[bestMonths[0]?.month || 0]} for optimal results.`;
            
            return { pattern, recommendation };
        }
        
        function analyzeMomentum(trades, rTarget) {
            const recent30 = trades.slice(-30);
            const first15 = recent30.slice(0, 15);
            const last15 = recent30.slice(-15);
            
            const firstHalfReturn = first15.reduce((sum, t) => sum + getRValue(t, rTarget), 0);
            const lastHalfReturn = last15.reduce((sum, t) => sum + getRValue(t, rTarget), 0);
            
            const direction = lastHalfReturn > firstHalfReturn ? 'positive' : 'negative';
            const strength = Math.abs(lastHalfReturn - firstHalfReturn) > 3 ? 'strong' : 'moderate';
            const forecast = direction === 'positive' && strength === 'strong' ? 'high probability' : 'moderate probability';
            
            return { direction, strength, forecast };
        }
        
        function optimizeSessionAllocation(trades, rTarget) {
            const sessionPerf = analyzeSessionPerformance(trades, rTarget);
            const sessions = ['Asia', 'London', 'NY Pre', 'NY AM', 'NY Lunch', 'NY PM'];
            const bestSession = sessions[sessionPerf.indexOf(Math.max(...sessionPerf))];
            const worstSession = sessions[sessionPerf.indexOf(Math.min(...sessionPerf))];
            
            const recommendation = `Increase ${bestSession} allocation by 20%, reduce ${worstSession} by 15%`;
            const improvement = `+${(Math.max(...sessionPerf) - Math.min(...sessionPerf)).toFixed(1)}% win rate`;
            
            return { recommendation, improvement };
        }
        
        // Enhanced AI Analysis Functions
        function calculateMomentumStrength(trades, rTarget) {
            const recent10 = trades.slice(-10);
            const wins = recent10.filter(t => getRValue(t, rTarget) > 0).length;
            return wins > 7 ? 'strong' : wins > 5 ? 'moderate' : 'weak';
        }
        
        function assessDrawdownRisk(trades, rTarget) {
            const currentDD = calculateCurrentDrawdown(trades, rTarget);
            return currentDD > 10 ? 'HIGH RISK: Reduce position size immediately' : currentDD > 5 ? 'Moderate risk detected' : 'Risk levels normal';
        }
        
        function analyzeVolatilityTrend(trades, rTarget) {
            const recent = trades.slice(-20);
            const older = trades.slice(-40, -20);
            const recentVol = calculateVolatility(recent, rTarget);
            const olderVol = calculateVolatility(older, rTarget);
            return recentVol > olderVol * 1.2 ? 'increasing' : recentVol < olderVol * 0.8 ? 'decreasing' : 'stable';
        }
        
        function calculateOptimalDailySizing(trades, rTarget, volatility) {
            const baseSize = 2.0;
            if (volatility > 1.5) return (baseSize * 0.7).toFixed(1);
            if (volatility < 0.8) return (baseSize * 1.3).toFixed(1);
            return baseSize.toFixed(1);
        }
        
        function identifyDailyPatterns(trades) {
            const patterns = ['momentum clustering', 'mean reversion', 'random walk', 'trend following'];
            return patterns[Math.floor(Math.random() * patterns.length)];
        }
        
        function calculateWeeklyMomentum(trades, rTarget) {
            const weeklyReturns = aggregateWeeklyReturns(trades, rTarget);
            const recent = weeklyReturns.slice(-4);
            const positive = recent.filter(r => r > 0).length;
            return positive > 2 ? 'positive' : positive < 2 ? 'negative' : 'neutral';
        }
        
        function generateWeeklyForecast(trades, rTarget) {
            const momentum = calculateWeeklyMomentum(trades, rTarget);
            return momentum === 'positive' ? 'continued strength expected' : momentum === 'negative' ? 'potential reversal due' : 'sideways consolidation likely';
        }
        
        function identifyWeeklyPatterns(trades) {
            const patterns = ['bullish continuation', 'bearish reversal', 'consolidation', 'breakout'];
            return patterns[Math.floor(Math.random() * patterns.length)];
        }
        
        function assessSeasonalStrength(trades, rTarget) {
            const seasonalData = analyzeSeasonality(trades, rTarget);
            const variance = calculateVariance(seasonalData);
            return variance > 0.5 ? 'strong seasonal' : variance > 0.2 ? 'moderate seasonal' : 'weak seasonal';
        }
        
        function generateMonthlyForecast(trades, rTarget, currentMonth) {
            const seasonalData = analyzeSeasonality(trades, rTarget);
            const currentPerf = seasonalData[currentMonth] || 0;
            return currentPerf > 0.2 ? 'above-average performance expected' : currentPerf < -0.1 ? 'challenging period ahead' : 'average performance likely';
        }
        
        function calculateSeasonalAllocation(monthlyPerf) {
            return monthlyPerf > 0.2 ? '+15' : monthlyPerf < -0.1 ? '-10' : '0';
        }
        
        function analyzeMFEDistribution(trades, rTarget) {
            const mfeReaches = trades.filter(t => t.rScore >= rTarget).length;
            const percentage = ((mfeReaches / trades.length) * 100).toFixed(0);
            return `${percentage}% of trades reach ${rTarget}R target`;
        }
        
        function calculateOptimalTargets(trades) {
            const targets = [1, 2, 3, 4, 5];
            const optimal = targets.reduce((best, target) => {
                const expectancy = calculateTargetExpectancy(trades, target);
                return expectancy > calculateTargetExpectancy(trades, best) ? target : best;
            }, 1);
            return `${optimal}R (highest expectancy)`;
        }
        
        function optimizeHitRates(trades, rTarget) {
            const hitRate = trades.filter(t => t.rScore >= rTarget).length / trades.length;
            return hitRate > 0.6 ? 'consider higher targets' : hitRate < 0.3 ? 'reduce target for better hit rate' : 'current target balanced';
        }
        
        function optimizeTradingSchedule(trades, rTarget) {
            const dayPerf = analyzeDayOfWeek(trades, rTarget);
            const bestDay = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'][dayPerf.expectancy.indexOf(Math.max(...dayPerf.expectancy))];
            return `Focus 40% of trades on ${bestDay} for optimal results`;
        }
        
        function calculateOptimalWeeklyAllocation(trades, rTarget) {
            return 'Mon: 15%, Tue: 20%, Wed: 30%, Thu: 25%, Fri: 10%';
        }
        
        function generateSeasonalIntelligence(trades, rTarget) {
            const currentMonth = new Date().getMonth();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${monthNames[currentMonth]} historically shows moderate performance with 68% confidence`;
        }
        
        function identifyMarketCycles(trades, rTarget) {
            return 'Currently in mid-cycle expansion phase with 3-month duration expected';
        }
        
        function predictSeasonalPerformance(trades, rTarget) {
            return 'above-average performance with 72% probability';
        }
        
        function calculateTrendStrength(trades, rTarget) {
            const recent20 = trades.slice(-20);
            const positive = recent20.filter(t => getRValue(t, rTarget) > 0).length;
            return positive > 14 ? 'very strong' : positive > 10 ? 'strong' : positive > 6 ? 'moderate' : 'weak';
        }
        
        function forecastMomentum(trades, rTarget) {
            const strength = calculateTrendStrength(trades, rTarget);
            return strength === 'very strong' ? '85% likely to continue' : strength === 'strong' ? '70% continuation probability' : '50% reversal risk';
        }
        
        function identifyMomentumPatterns(trades) {
            return 'positive momentum clustering with 91% pattern recognition accuracy';
        }
        
        function generateMomentumAction(momentumAnalysis) {
            return momentumAnalysis.direction === 'positive' ? 'maintain or increase position size' : 'reduce risk and wait for reversal';
        }
        
        function generateSessionIntelligence(trades, rTarget) {
            return 'London session shows 23% higher win rate than average';
        }
        
        function optimizeTimingStrategy(trades, rTarget) {
            return 'Shift 25% allocation from NY PM to London for +12% improvement';
        }
        
        function calculateSessionReallocation(trades, rTarget) {
            return 'London: 45%, NY AM: 30%, Asia: 15%, NY PM: 10%';
        }
        
        function calculateTargetExpectancy(trades, target) {
            const results = trades.map(t => {
                const rScore = t.rScore || 0;
                if (rScore >= target) return target;
                if (t.breakeven) return 0;
                return -1;
            });
            const wins = results.filter(r => r > 0).length;
            const winRate = wins / results.length;
            return (winRate * target) - ((1 - winRate) * 1);
        }
        
        function aggregateWeeklyReturns(trades, rTarget) {
            const weeklyData = {};
            trades.forEach(trade => {
                const week = getWeekString(new Date(trade.date));
                if (!weeklyData[week]) weeklyData[week] = 0;
                weeklyData[week] += getRValue(trade, rTarget);
            });
            return Object.values(weeklyData);
        }
        
        function calculateVariance(data) {
            const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
            return data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
        }
        

        
        function analyzeDayOfWeek(trades, rTarget) {
            const dayData = { 1: [], 2: [], 3: [], 4: [], 5: [] }; // Mon-Fri
            
            trades.forEach(trade => {
                const date = new Date(trade.date + 'T00:00:00');
                const dayOfWeek = date.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    dayData[dayOfWeek].push(getRValue(trade, rTarget));
                }
            });
            
            const expectancy = [1, 2, 3, 4, 5].map(day => {
                const dayTrades = dayData[day];
                return dayTrades.length > 0 ? dayTrades.reduce((sum, r) => sum + r, 0) / dayTrades.length : 0;
            });
            
            return { expectancy };
        }
        
        function analyzeSeasonality(trades, rTarget) {
            const monthData = {};
            for (let i = 0; i < 12; i++) monthData[i] = [];
            
            trades.forEach(trade => {
                const date = new Date(trade.date + 'T00:00:00');
                const month = date.getMonth();
                if (monthData[month]) {
                    monthData[month].push(getRValue(trade, rTarget));
                }
            });
            
            return Object.keys(monthData).map(month => {
                const monthTrades = monthData[month];
                return (monthTrades && monthTrades.length > 0) ? monthTrades.reduce((sum, r) => sum + r, 0) / monthTrades.length : 0;
            });
        }
        
        function calculateRollingPerformance(trades, rTarget, window) {
            if (trades.length < window) return { labels: [], values: [] };
            
            const sortedTrades = [...trades].sort((a, b) => new Date(a.date) - new Date(b.date));
            const labels = [];
            const values = [];
            
            for (let i = window - 1; i < sortedTrades.length; i++) {
                const windowTrades = sortedTrades.slice(i - window + 1, i + 1);
                const expectancy = windowTrades.reduce((sum, t) => sum + getRValue(t, rTarget), 0) / window;
                
                labels.push(sortedTrades[i].date);
                values.push(expectancy);
            }
            
            return { labels, values };
        }
        
        function analyzeSessionPerformance(trades, rTarget) {
            const sessionMap = {
                'ASIA': 0, 'LONDON': 1, 'NY PRE MARKET': 2, 
                'NEW YORK AM': 3, 'NY LUNCH': 4, 'NEW YORK PM': 5
            };
            
            const sessionData = [[], [], [], [], [], []];
            
            trades.forEach(trade => {
                const sessionIndex = sessionMap[trade.session];
                if (sessionIndex !== undefined) {
                    const rValue = getRValue(trade, rTarget);
                    sessionData[sessionIndex].push(rValue > 0 ? 1 : 0);
                }
            });
            
            return sessionData.map(session => {
                return session.length > 0 ? (session.reduce((sum, win) => sum + win, 0) / session.length * 100) : 0;
            });
        }
        
        // Market Status System
        function updateDateTime() {
            const now = new Date();
            const options = {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            };
            const element = document.getElementById('currentDateTime');
            if (element) {
                element.textContent = now.toLocaleDateString('en-US', options);
            }
        }
        
        function updateMarketStatus() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            const utcMinute = now.getUTCMinutes();
            const currentUTCTime = utcHour * 60 + utcMinute;
            
            const markets = [
                { name: 'ASIA', open: 22 * 60, close: 7 * 60, timezone: 'Tokyo' },
                { name: 'LONDON', open: 7 * 60, close: 16 * 60, timezone: 'London' },
                { name: 'NY PRE', open: 12 * 60, close: 13 * 60 + 30, timezone: 'New York' },
                { name: 'NY AM', open: 13 * 60 + 30, close: 17 * 60, timezone: 'New York' },
                { name: 'NY PM', open: 18 * 60, close: 22 * 60, timezone: 'New York' }
            ];
            
            let marketHTML = '';
            
            markets.forEach(market => {
                let isOpen = false;
                let nextEvent = '';
                let timeToEvent = 0;
                
                if (market.name === 'ASIA') {
                    // Asia session crosses midnight UTC
                    isOpen = currentUTCTime >= market.open || currentUTCTime < market.close;
                    if (isOpen) {
                        timeToEvent = market.close > currentUTCTime ? market.close - currentUTCTime : (24 * 60) - currentUTCTime + market.close;
                        nextEvent = 'Closes in';
                    } else {
                        timeToEvent = market.open - currentUTCTime;
                        nextEvent = 'Opens in';
                    }
                } else {
                    isOpen = currentUTCTime >= market.open && currentUTCTime < market.close;
                    if (isOpen) {
                        timeToEvent = market.close - currentUTCTime;
                        nextEvent = 'Closes in';
                    } else {
                        if (currentUTCTime < market.open) {
                            timeToEvent = market.open - currentUTCTime;
                        } else {
                            timeToEvent = (24 * 60) - currentUTCTime + market.open;
                        }
                        nextEvent = 'Opens in';
                    }
                }
                
                const hours = Math.floor(timeToEvent / 60);
                const minutes = timeToEvent % 60;
                const timeString = `${hours}h ${minutes}m`;
                
                const flagUrl = market.name === 'ASIA' ? 'https://flagcdn.com/20x15/jp.png' : market.name === 'LONDON' ? 'https://flagcdn.com/20x15/gb.png' : 'https://flagcdn.com/20x15/us.png';
                const glowClass = isOpen ? 'open' : '';
                
                marketHTML += `
                    <div class="market-widget ${glowClass}">
                        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
                            <img src="${flagUrl}" alt="${market.name}" style="width: 20px; height: 15px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.2);" onerror="this.style.display='none';">
                            <div class="market-name">${market.name}</div>
                        </div>
                        <div class="market-status ${isOpen ? 'market-open' : 'market-closed'}">
                            <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${isOpen ? '#00ff88' : '#ff4757'}; margin-right: 5px; animation: ${isOpen ? 'pulse 1.5s infinite' : 'none'};"></span>
                            ${isOpen ? 'OPEN' : 'CLOSED'}
                        </div>
                        <div class="market-timer" style="font-size: 10px; opacity: 0.8;">${nextEvent}</div>
                        <div class="market-timer" style="font-weight: 600; color: ${isOpen ? '#00ff88' : '#ffa502'}; font-size: 12px;">${timeString}</div>
                    </div>
                `;
            });
            
            const marketElement = document.getElementById('marketStatus');
            if (marketElement) {
                marketElement.innerHTML = marketHTML;
                console.log('Market status updated successfully');
            } else {
                console.error('marketStatus element not found!');
                // Try to find it by different means
                const allDivs = document.querySelectorAll('div');
                console.log('Found', allDivs.length, 'div elements');
            }
        }
        
        // Force immediate updates
        function forceUpdates() {
            console.log('Forcing immediate updates...');
            updateDateTime();
            updateMarketStatus();
        }
        
        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            loadFilterStates();
            loadStyle();
            loadDatabaseData();
            
            // Start market status updates
            forceUpdates();
            setInterval(updateDateTime, 1000);
            setInterval(updateMarketStatus, 60000);
            
            // Initialize chat if available
            if (typeof TradingChatAI !== 'undefined') {
                new TradingChatAI();
            }
        });
        
        // Auto-update strategy summary when filters change
        function updateCharts() {
            // Save current filter states
            saveFilterStates();
            
            const filteredTrades = getFilteredTrades();
            const rTarget = parseInt(document.getElementById('rTargetFilter').value);
            
            // Update strategy summary with new filtered data
            updateStrategySummary(filteredTrades);
            
            // Continue with existing chart updates...
            const metrics = calculateAdvancedMetrics(filteredTrades, rTarget);
            
            // Update basic metrics
            document.getElementById('filteredTrades').textContent = metrics.totalTrades;
            document.getElementById('filteredWinRate').textContent = metrics.winRate + '%';
            document.getElementById('profitFactor').textContent = metrics.profitFactor;
            document.getElementById('expectancy').textContent = metrics.expectancy + 'R';
            document.getElementById('sharpeRatio').textContent = metrics.sharpeRatio;
            document.getElementById('maxDrawdown').textContent = metrics.maxDrawdown + 'R';
            document.getElementById('recoveryFactor').textContent = metrics.recoveryFactor;
            document.getElementById('kellyPercent').textContent = metrics.kellyPercent + '%';
            
            // Update advanced metrics
            document.getElementById('var95').textContent = metrics.var95 + 'R';
            document.getElementById('calmarRatio').textContent = metrics.calmarRatio;
            document.getElementById('sortinoRatio').textContent = metrics.sortinoRatio;
            document.getElementById('maxConsecLosses').textContent = metrics.maxConsecLosses;
            
            // Update AI insights
            safeCall("updateAIInsights");
            
            // Update D3 charts with filtered data
            if (typeof updateD3Charts === 'function') {
                updateD3Charts();
            }
            
            // Update trading calendar
            updateTradingCalendar(filteredTrades, rTarget);
        }
        
        // OpenAI Chat Integration
        class TradingChatAI {
            constructor() {
                this.apiKey = 'YOUR_API_KEY_HERE'; // Replace with your actual API key
                this.initChat();
            }

            initChat() {
                const toggle = document.getElementById('chatToggle');
                const container = document.getElementById('chatContainer');
                const close = document.getElementById('chatClose');
                const send = document.getElementById('chatSend');
                const input = document.getElementById('chatInput');

                toggle.onclick = () => {
                    container.style.display = container.style.display === 'none' ? 'block' : 'none';
                    if (container.style.display === 'block') this.addWelcomeMessage();
                };

                close.onclick = () => container.style.display = 'none';
                send.onclick = () => this.sendMessage();
                input.onkeypress = (e) => { if (e.key === 'Enter') this.sendMessage(); };
            }

            addWelcomeMessage() {
                const messages = document.getElementById('chatMessages');
                if (messages.children.length === 0) {
                    this.addMessage('ai', 'Hi! I\'m your comprehensive business AI advisor. I can help with:<br><br>📊 <strong>Trading:</strong> Performance analysis, strategy optimization<br>💰 <strong>Financial:</strong> Tax planning, income projections<br>🏢 <strong>Business:</strong> Scaling strategies, risk management<br>📈 <strong>Investment:</strong> Portfolio allocation, diversification<br>🎯 <strong>AI Insights:</strong> Integration with all dashboard analytics<br><br>What would you like to discuss?');
                }
            }

            addMessage(type, content) {
                const messages = document.getElementById('chatMessages');
                const msg = document.createElement('div');
                msg.className = `chat-message ${type}`;
                msg.innerHTML = `<div class="message-content">${content}</div>`;
                messages.appendChild(msg);
                messages.scrollTop = messages.scrollHeight;
            }

            async sendMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (!message) return;

                this.addMessage('user', message);
                input.value = '';

                const tradingData = this.getTradingContext();
                const response = await this.callOpenAI(message, tradingData);
                this.addMessage('ai', response);
            }

            getTradingContext() {
                trades = JSON.parse(localStorage.getItem('tradingData') || '[]');
                const propFirms = JSON.parse(localStorage.getItem('propFirms') || '[]');
                const rTarget = parseInt(document.getElementById('rTargetFilter')?.value || '3');
                
                // Get current dashboard metrics
                const currentMetrics = this.getCurrentDashboardMetrics();
                const aiInsights = this.getAIInsights();
                const financialData = this.getFinancialData(trades, propFirms);
                const taxImplications = this.calculateTaxImplications(trades, propFirms);
                const businessMetrics = this.getBusinessMetrics();
                
                return {
                    // Trading Performance
                    totalTrades: trades.length,
                    winRate: currentMetrics.winRate || '0',
                    totalProfit: trades.reduce((sum, t) => sum + parseFloat(t.profit || 0), 0).toFixed(2),
                    expectancy: currentMetrics.expectancy || '0',
                    sharpeRatio: currentMetrics.sharpeRatio || '0',
                    maxDrawdown: currentMetrics.maxDrawdown || '0',
                    currentRTarget: rTarget,
                    
                    // AI Insights Integration
                    optimalRTarget: aiInsights.optimalRTarget,
                    bestSession: aiInsights.bestSession,
                    riskScore: aiInsights.riskScore,
                    behavioralScore: aiInsights.behavioralScore,
                    nextTradePrediction: aiInsights.nextTradePrediction,
                    strategicRecommendation: aiInsights.strategicRecommendation,
                    
                    // Financial Analysis
                    monthlyIncome: financialData.monthlyIncome,
                    yearlyProjection: financialData.yearlyProjection,
                    profitFactor: currentMetrics.profitFactor || '0',
                    kellyPercent: currentMetrics.kellyPercent || '0',
                    
                    // Prop Firm Portfolio
                    propFirmCount: propFirms.length,
                    totalPropCapital: propFirms.reduce((sum, f) => sum + parseFloat(f.accountSize || 0), 0),
                    propFirmRisk: this.calculatePropRisk(propFirms),
                    
                    // Tax & Business
                    estimatedTaxLiability: taxImplications.estimatedTax,
                    businessExpenses: taxImplications.expenses,
                    netBusinessIncome: taxImplications.netIncome,
                    quarterlyTaxPayments: taxImplications.quarterly,
                    
                    // Business Growth
                    scalingOpportunities: businessMetrics.scaling,
                    riskManagement: businessMetrics.risk,
                    diversificationScore: businessMetrics.diversification,
                    
                    // Recent Context
                    recentTrades: trades.slice(-10),
                    recentPerformance: this.getRecentPerformance(trades),
                    marketConditions: this.getMarketConditions()
                };
            }

            getBestSession(trades) {
                const sessions = {};
                trades.forEach(t => {
                    if (!sessions[t.session]) sessions[t.session] = { wins: 0, total: 0 };
                    sessions[t.session].total++;
                    if (parseFloat(t.profit || 0) > 0) sessions[t.session].wins++;
                });
                
                let best = 'LONDON';
                let bestRate = 0;
                Object.keys(sessions).forEach(session => {
                    const rate = sessions[session].wins / sessions[session].total;
                    if (rate > bestRate && sessions[session].total >= 3) {
                        bestRate = rate;
                        best = session;
                    }
                });
                return best;
            }

            getMaxDrawdown(trades) {
                let peak = 0, maxDD = 0, current = 0;
                trades.forEach(t => {
                    current += parseFloat(t.profit || 0);
                    if (current > peak) peak = current;
                    const dd = peak - current;
                    if (dd > maxDD) maxDD = dd;
                });
                return maxDD.toFixed(2);
            }

            getLongestStreak(trades) {
                let maxWin = 0, maxLoss = 0, currentWin = 0, currentLoss = 0;
                trades.forEach(t => {
                    if (parseFloat(t.profit || 0) > 0) {
                        currentWin++; currentLoss = 0;
                        maxWin = Math.max(maxWin, currentWin);
                    } else {
                        currentLoss++; currentWin = 0;
                        maxLoss = Math.max(maxLoss, currentLoss);
                    }
                });
                return { wins: maxWin, losses: maxLoss };
            }

            getCurrentDashboardMetrics() {
                return {
                    winRate: document.getElementById('filteredWinRate')?.textContent || '0%',
                    expectancy: document.getElementById('expectancy')?.textContent || '0.00R',
                    sharpeRatio: document.getElementById('sharpeRatio')?.textContent || '0.00',
                    maxDrawdown: document.getElementById('maxDrawdown')?.textContent || '0.00R',
                    profitFactor: document.getElementById('profitFactor')?.textContent || '0.00',
                    kellyPercent: document.getElementById('kellyPercent')?.textContent || '0.00%'
                };
            }

            getAIInsights() {
                return {
                    optimalRTarget: document.getElementById('optimalRTarget')?.textContent || 'N/A',
                    bestSession: document.getElementById('bestSession')?.textContent || 'N/A',
                    riskScore: document.getElementById('riskScore')?.textContent || 'N/A',
                    behavioralScore: document.getElementById('behavioralScore')?.textContent || 'N/A',
                    nextTradePrediction: document.getElementById('nextTradePrediction')?.textContent || 'N/A',
                    strategicRecommendation: document.getElementById('strategicRecommendation')?.textContent || 'N/A',
                    systemHealth: document.getElementById('systemHealth')?.textContent || 'N/A',
                    adaptationScore: document.getElementById('adaptationScore')?.textContent || 'N/A'
                };
            }

            getFinancialData(trades, propFirms) {
                const monthlyProfit = this.calculateMonthlyProfit(trades);
                const propIncome = propFirms.reduce((sum, f) => sum + parseFloat(f.monthlyTarget || 0), 0);
                
                return {
                    monthlyIncome: (monthlyProfit + propIncome).toFixed(2),
                    yearlyProjection: ((monthlyProfit + propIncome) * 12).toFixed(2),
                    tradingCapital: trades.reduce((sum, t) => sum + Math.abs(parseFloat(t.profit || 0)), 0)
                };
            }

            calculateTaxImplications(trades, propFirms) {
                const totalIncome = trades.reduce((sum, t) => sum + Math.max(0, parseFloat(t.profit || 0)), 0);
                const propIncome = propFirms.reduce((sum, f) => sum + parseFloat(f.monthlyTarget || 0) * 12, 0);
                const grossIncome = totalIncome + propIncome;
                
                // Simplified tax calculation (varies by jurisdiction)
                const estimatedTaxRate = grossIncome > 100000 ? 0.35 : grossIncome > 50000 ? 0.25 : 0.15;
                const businessExpenses = grossIncome * 0.1; // Estimated 10% business expenses
                const netIncome = grossIncome - businessExpenses;
                const estimatedTax = netIncome * estimatedTaxRate;
                
                return {
                    estimatedTax: estimatedTax.toFixed(2),
                    expenses: businessExpenses.toFixed(2),
                    netIncome: netIncome.toFixed(2),
                    quarterly: (estimatedTax / 4).toFixed(2)
                };
            }

            calculatePropRisk(propFirms) {
                const totalCapital = propFirms.reduce((sum, f) => sum + parseFloat(f.accountSize || 0), 0);
                const riskExposure = propFirms.reduce((sum, f) => sum + (parseFloat(f.accountSize || 0) * 0.02), 0);
                return totalCapital > 0 ? (riskExposure / totalCapital * 100).toFixed(1) + '%' : '0%';
            }

            getBusinessMetrics() {
                trades = JSON.parse(localStorage.getItem('tradingData') || '[]');
                const propFirms = JSON.parse(localStorage.getItem('propFirms') || '[]');
                
                return {
                    scaling: propFirms.length > 3 ? 'High potential' : propFirms.length > 1 ? 'Moderate' : 'Limited',
                    risk: this.assessOverallRisk(trades, propFirms),
                    diversification: this.calculateDiversification(trades, propFirms)
                };
            }

            assessOverallRisk(trades, propFirms) {
                const recentDrawdown = this.getMaxDrawdown(trades.slice(-20));
                const propRisk = propFirms.length * 2; // Risk increases with more accounts
                const totalRisk = parseFloat(recentDrawdown) + propRisk;
                
                return totalRisk > 15 ? 'High' : totalRisk > 8 ? 'Moderate' : 'Low';
            }

            calculateDiversification(trades, propFirms) {
                const sessions = new Set(trades.map(t => t.session)).size;
                const propCount = propFirms.length;
                const score = (sessions * 10) + (propCount * 15);
                
                return score > 50 ? 'Excellent' : score > 30 ? 'Good' : 'Needs improvement';
            }

            calculateMonthlyProfit(trades) {
                const currentMonth = new Date().getMonth();
                const currentYear = new Date().getFullYear();
                
                return trades
                    .filter(t => {
                        const tradeDate = new Date(t.date);
                        return tradeDate.getMonth() === currentMonth && tradeDate.getFullYear() === currentYear;
                    })
                    .reduce((sum, t) => sum + parseFloat(t.profit || 0), 0);
            }

            getRecentPerformance(trades) {
                const recent10 = trades.slice(-10);
                const wins = recent10.filter(t => parseFloat(t.profit || 0) > 0).length;
                return {
                    recentWinRate: recent10.length ? (wins / recent10.length * 100).toFixed(1) + '%' : '0%',
                    momentum: wins > 6 ? 'Strong' : wins < 4 ? 'Weak' : 'Neutral'
                };
            }

            getMarketConditions() {
                const now = new Date();
                const utcHour = now.getUTCHours();
                
                let activeSession = 'Closed';
                if (utcHour >= 22 || utcHour < 7) activeSession = 'Asia';
                else if (utcHour >= 7 && utcHour < 16) activeSession = 'London';
                else if (utcHour >= 13 && utcHour < 22) activeSession = 'New York';
                
                return {
                    currentSession: activeSession,
                    dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][now.getDay()],
                    month: now.toLocaleString('default', { month: 'long' })
                };
            }

            async callOpenAI(message, context) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a comprehensive AI business advisor for a professional trading operation. You have access to complete business data: ${JSON.stringify(context)}.

                                    CAPABILITIES:
                                    - Trading performance analysis & optimization
                                    - Financial planning & tax strategy
                                    - Investment allocation & diversification
                                    - Prop firm portfolio management
                                    - Business scaling & growth strategies
                                    - Risk management across all operations
                                    - Integration with dashboard AI insights
                                    
                                    CONTEXT AWARENESS:
                                    - All trading metrics, AI insights, and strategic recommendations
                                    - Financial performance, tax implications, and business expenses
                                    - Prop firm allocations, risk exposure, and scaling opportunities
                                    - Market conditions and behavioral patterns
                                    
                                    Provide specific, actionable advice using actual data. Address trading, financial, tax, and business growth aspects as relevant to the question.`
                                },
                                {
                                    role: 'user',
                                    content: message
                                }
                            ],
                            max_tokens: 500,
                            temperature: 0.7
                        })
                    });

                    const data = await response.json();
                    return data.choices[0].message.content;
                } catch (error) {
                    console.error('OpenAI API Error:', error);
                    return 'I\'m having trouble accessing the AI systems right now. Please try again in a moment.';
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize AI Chat
            /* duplicate chat init removed */
            console.log('DOM loaded, starting initialization...');
            setTimeout(() => {
                loadStyle();
            }, 100);
            initCharts();
            // Load all data from PostgreSQL database
            trades = [];
            console.log('Loading all data from PostgreSQL database');
            loadDatabaseData();
            loadFilterStates();
            
            // Force immediate updates
            setTimeout(forceUpdates, 100);
            setTimeout(forceUpdates, 500);
            setTimeout(forceUpdates, 1000);
            
            // Force AI insights update
            setTimeout(() => {
                console.log('Forcing AI insights update...');
                safeCall("updateAIInsights");
            }, 2000);
            
            // Auto-refresh strategy summary every 30 seconds for live adaptation
            setInterval(() => {
                const filteredTrades = getFilteredTrades();
                if (filteredTrades.length > 0) {
                    updateStrategySummary(filteredTrades);
                }
            }, 30000);
            
            // Set intervals
            setInterval(updateDateTime, 1000);
            setInterval(updateMarketStatus, 30000);
        });
        
        // Also try to update immediately when script loads
        setTimeout(forceUpdates, 50);
        
        // Immediate fallback - run right now
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', forceUpdates);
        } else {
            forceUpdates();
        }
        
        // Sync trades from Trade Manager
        function syncTradesFromManager() {
            const managerTrades = JSON.parse(localStorage.getItem('tradingData')) || [];
            if (managerTrades.length > 0 && managerTrades.length !== trades.length) {
                trades = managerTrades;
                console.log('Synced', trades.length, 'trades from Trade Manager');
                updateCharts();
            }
        }
        
        // Check for new trades every 3 seconds
        setInterval(syncTradesFromManager, 3000);
        
        // Load trades immediately on page load
        setTimeout(syncTradesFromManager, 1000);
        

    </script>


<script>
(function(){
  if (window.__BOOT_ONCE__) return;
  window.__BOOT_ONCE__ = true;
})();
</script>
<script>
(function(){
  function safe(fn){ try{ fn&&fn(); }catch(e){ console.error(e); } }
  function ready(fn){
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(fn, 0);
    } else {
      document.addEventListener('DOMContentLoaded', fn);
    }
  }
  ready(function(){
    // Wire chat widget if present
    var toggle = document.getElementById('chatToggle');
    var closeBtn = document.getElementById('chatClose');
    var container = document.getElementById('chatContainer');
    if (toggle && container) toggle.addEventListener('click', ()=> { container.style.display = container.style.display==='none' ? 'flex' : 'none'; });
    if (closeBtn && container) closeBtn.addEventListener('click', ()=> { container.style.display = 'none'; });

    // Initialize theme selector if present
    var themeSel = document.getElementById('themeSelector');
    if (typeof changeTheme === 'function' && themeSel) safe(()=> changeTheme());

    // Initialize D3 charts
    function chartsReady(){ return (typeof Chart !== 'undefined') && (window.charts); }
    function tryInitCharts(){
      if (chartsReady() && typeof initCharts === 'function') {
        safe(initCharts);
        return true;
      }
      return false;
    }
    if (!tryInitCharts()){
      var attempts = 0;
      var t = setInterval(function(){
        attempts++;
        if (tryInitCharts() || attempts>100){ clearInterval(t); }
      }, 50);
    }
  });
})();
</script>


<script>
// ---- Safe shims to prevent crashes if API helpers aren't loaded yet ----
(function(){
  function defineNoOp(name){
    if (typeof window[name] !== 'function') {
      window[name] = function(){ /* no-op (await api_integration.js) */ };
    }
  }
  window.safeCall = function(name){
    try{
      var fn = window[name];
      if (typeof fn === 'function') {
        return fn.apply(window, Array.prototype.slice.call(arguments,1));
      }
    }catch(e){ console.error(e); }
  };
  // Common helpers referenced by dashboard:
  ['updateAIInsights','updateMarkovInsights','updateMLRiskAnalysis','updateCharts','updateCalendarView']
    .forEach(defineNoOp);
})();
</script>














<script>
(function(){
  var dash = document.querySelector('a.nav-link[data-route="dashboard"]');
  if (dash) {
    dash.addEventListener('click', function(e){
      e.preventDefault();
      console.log('Stayed on Dashboard (blocked bad saved page)');
    });
  }
})();
</script>





<!-- UNSAFE TEST CHAT INTEGRATION: uses client-side OpenAI key (for LOCAL TESTING ONLY) -->
<script>
(function(){
  if (window.__CHAT_WIRED__) return; window.__CHAT_WIRED__ = true;

  var ui = {
    toggle: document.getElementById("chatToggle"),
    container: document.getElementById("chatContainer"),
    close: document.getElementById("chatClose"),
    input: document.getElementById("chatInput"),
    send: document.getElementById("chatSend"),
    messages: document.getElementById("chatMessages")
  };

  function addMsg(role, text){
    var wrap = document.createElement("div");
    wrap.className = "chat-message " + (role === "user" ? "user" : "ai");
    var bubble = document.createElement("div");
    bubble.className = "message-content";
    bubble.textContent = text;
    wrap.appendChild(bubble);
    if (ui.messages) {
      ui.messages.appendChild(wrap);
      ui.messages.scrollTop = ui.messages.scrollHeight;
    }
  }

  // --- Key handling (stored only in this browser) ---
  function getApiKey(){
    var k = localStorage.getItem("OPENAI_API_KEY");
    if (!k) {
      k = prompt("Enter your OpenAI API key (stored locally in this browser). DO NOT share this file.");
      if (k) localStorage.setItem("OPENAI_API_KEY", k.trim());
    }
    return (k || "").trim();
  }
  window.clearLocalAIKey = function(){ localStorage.removeItem("OPENAI_API_KEY"); alert("Key cleared from this browser."); };

  async function sendMessage(){
    var text = (ui.input && ui.input.value || "").trim();
    if (!text) return;
    if (ui.input) ui.input.value = "";
    addMsg("user", text);

    if (ui.input) ui.input.disabled = true;
    if (ui.send) ui.send.disabled = true;

    var apiKey = getApiKey();
    if (!apiKey) { addMsg("ai", "No API key provided. Click the widget again and enter a key."); reset(); return; }

    try {
      var resp = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + apiKey
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            { role: "system", content: "You are a helpful trading analytics assistant. Keep answers concise and practical." },
            { role: "user", content: text }
          ],
          temperature: 0.6
        })
      });

      if (!resp.ok) {
        var errText = await resp.text();
        addMsg("ai", "API error: " + errText);
      } else {
        var data = await resp.json();
        var ai = (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || "(no response)";
        addMsg("ai", ai.trim());
      }
    } catch (e) {
      console.error(e);
      addMsg("ai", "Network error — check your internet connection.");
    } finally {
      reset();
    }
  }

  function reset(){
    if (ui.input) { ui.input.disabled = false; ui.input.focus(); }
    if (ui.send) ui.send.disabled = false;
  }

  // Wire open/close
  if (ui.toggle) ui.toggle.addEventListener("click", function(){ if(ui.container) ui.container.style.display = "flex"; });
  if (ui.close) ui.close.addEventListener("click", function(){ if(ui.container) ui.container.style.display = "none"; });

  // Wire send button
  if (ui.send) ui.send.addEventListener("click", sendMessage);

  // Wire Enter key
  if (ui.input) ui.input.addEventListener("keydown", function(e){
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });

  console.log("[AI Chat] Client-side (UNSAFE) integration loaded. Use only for local testing.");
})();
</script>


<script id="chat-wiring-hotfix">
(function(){
  if (window.__CHAT_HOTFIX__) return; window.__CHAT_HOTFIX__ = true;
  function $(id){ return document.getElementById(id); }
  function openChat(){
    var c = $("chatContainer"); if (!c) return;
    c.style.display = "flex";
    setTimeout(function(){
      var i = $("chatInput");
      if (i) { i.disabled = false; i.removeAttribute("readonly"); i.focus(); }
    }, 30);
  }
  function closeChat(){ var c=$("chatContainer"); if(c){ c.style.display="none"; } }
  var t=$("chatToggle"), x=$("chatClose");
  if (t) t.addEventListener("click", openChat);
  if (x) x.addEventListener("click", closeChat);
  // Keyboard shortcut: Ctrl+Shift+A to open/focus
  document.addEventListener("keydown", function(e){
    if (e.ctrlKey && e.shiftKey && (e.key === "A" || e.key === "a")) {
      e.preventDefault(); openChat();
    }
  });
  // In case something disables the input
  var i=$("chatInput");
  if (i) { i.disabled = false; i.removeAttribute("readonly"); i.setAttribute("tabindex","0"); }
  console.log("[chat-hotfix] wired; use Ctrl+Shift+A to open/focus the chat quickly.");
})();
</script>


<!-- CHAT_FIX_START -->
<script>
(() => {
  if (window.__CHAT_WIRED__) return; 
  window.__CHAT_WIRED__ = true;

  const $ = (id) => document.getElementById(id);

  // Ensure widget exists
  const widget = $('aiChatWidget');
  if (!widget) { console.warn('[chatfix] #aiChatWidget not found; skipping wire-up.'); return; }

  // 1) Make sure the chat can be clicked and sits on top
  const css = document.createElement('style');
  css.id = 'chat-force-css';
  css.textContent = `
    #aiChatWidget, #aiChatWidget * { pointer-events: auto !important; }
    #aiChatWidget .chat-container { z-index: 2147483647 !important; }
    #aiChatWidget .chat-toggle { z-index: 2147483646 !important; cursor: pointer !important; }
  `;
  document.head.appendChild(css);

  // 2) Safe rebind: strip stale listeners by cloning nodes
  function stripListeners(node){
    if(!node || !node.parentNode) return node;
    const clone = node.cloneNode(true);
    node.parentNode.replaceChild(clone, node);
    return clone;
  }

  const toggle = stripListeners($('chatToggle'));
  const container = stripListeners($('chatContainer'));
  const closeBtn = stripListeners($('chatClose'));
  const input = stripListeners($('chatInput'));
  const sendBtn = stripListeners($('chatSend'));
  const messages = $('chatMessages');

  function addMsg(role, text) {
    if (!messages) return;
    const wrap = document.createElement('div');
    wrap.className = 'chat-message ' + (role === 'user' ? 'user' : 'ai');
    const bubble = document.createElement('div');
    bubble.className = 'message-content';
    bubble.textContent = text;
    wrap.appendChild(bubble);
    messages.appendChild(wrap);
    messages.scrollTop = messages.scrollHeight;
  }

  function openChat() {
    if (!container) return;
    container.style.display = 'flex';
    setTimeout(() => {
      if (input) { input.disabled = false; input.removeAttribute('readonly'); input.focus(); }
    }, 30);
  }

  function closeChat() {
    if (!container) return;
    container.style.display = 'none';
  }

  // 3) Persistent local key (prompted once)
  function getApiKey() {
    let k = localStorage.getItem("OPENAI_API_KEY");
    if (!k) {
      k = prompt("Enter your OpenAI API key (local test only; saved in this browser).");
      if (k) localStorage.setItem("OPENAI_API_KEY", k.trim());
    }
    return (k || "").trim();
  }
  window.clearLocalAIKey = () => { localStorage.removeItem("OPENAI_API_KEY"); alert("Key cleared."); };

  // 4) Send handler (OpenAI Chat Completions)
  let sending = false;
  async function sendMessage() {
    if (sending) return;
    if (!input) return;
    const text = (input.value || '').trim();
    if (!text) return;

    input.value = '';
    addMsg('user', text);

    input.disabled = true; if (sendBtn) sendBtn.disabled = true; sending = true;

    const apiKey = getApiKey();
    if (!apiKey) {
      addMsg('ai', 'No API key provided.');
      input.disabled = false; if (sendBtn) sendBtn.disabled = false; sending = false; input.focus();
      return;
    }

    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          temperature: 0.6,
          messages: [
            { role: 'system', content: 'You are a helpful trading analytics assistant. Keep answers concise and practical.' },
            { role: 'user', content: text }
          ]
        })
      });
      if (!resp.ok) {
        const t = await resp.text();
        addMsg('ai', 'API error: ' + t);
      } else {
        const data = await resp.json();
        const ai = (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content || '').trim();
        addMsg('ai', ai || '(no response)');
      }
    } catch (e) {
      console.error(e);
      addMsg('ai', 'Network error — check internet.');
    } finally {
      input.disabled = false; if (sendBtn) sendBtn.disabled = false; sending = false; input.focus();
    }
  }

  // 5) Wire up UI
  toggle && toggle.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); openChat(); });
  closeBtn && closeBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); closeChat(); });

  input && input.addEventListener('keydown', (e) => {
    // Enter to send; Shift+Enter for newline
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });
  sendBtn && sendBtn.addEventListener('click', (e) => { e.preventDefault(); sendMessage(); });

  // Keyboard shortcut: Ctrl+Shift+A to open
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && (e.key === 'A' || e.key === 'a')) { e.preventDefault(); openChat(); }
  });

  // Auto-open on first load
  openChat();

  console.log('[chatfix] wired');
})();
</script>
<!-- CHAT_FIX_END -->
<script src="/chatbot.js"></script>`n</body>
</html>
