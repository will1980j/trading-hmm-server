{%extends 'layout.html' %}

{% block page_title %}Financial Summary â€” Second Skies{% endblock %}

{% block extra_head %}
<script src="https://d3js.org/d3.v7.min.js"></script>
{% endblock %}

{% block content %}
<div class="financial-grid">
            <div class="financial-card">
                <div class="financial-label">Total Portfolio Value</div>
                <div class="financial-value positive" id="totalPortfolio">$0</div>
                <div style="font-size: 12px; opacity: 0.7;">All funded accounts</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">Monthly Revenue</div>
                <div class="financial-value positive" id="monthlyRevenue">$0</div>
                <div style="font-size: 12px; opacity: 0.7;">Gross profit</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">Net Profit After Tax</div>
                <div class="financial-value positive" id="netProfit">$0</div>
                <div style="font-size: 12px; opacity: 0.7;">After 25% tax</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">Annual Projection</div>
                <div class="financial-value neutral" id="annualProjection">$0</div>
                <div style="font-size: 12px; opacity: 0.7;">Based on current</div>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div class="chart-container">
                <h3>Monthly Performance Trend</h3>
                <div id="d3PerformanceChart" style="height: 300px;"></div>
            </div>
            <div class="chart-container">
                <h3>Portfolio Allocation</h3>
                <div id="d3AllocationChart" style="height: 300px;"></div>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <div class="chart-container">
                <h3>Revenue Growth</h3>
                <div id="d3RevenueChart" style="height: 300px;"></div>
            </div>
            <div class="chart-container">
                <h3>Profit Distribution</h3>
                <div id="d3ProfitChart" style="height: 300px;"></div>
            </div>
        </div>
        
        <div class="financial-grid">
            <div class="financial-card">
                <div class="financial-label">Active Challenges</div>
                <div class="financial-value neutral" id="activeChallenges">0</div>
                <div style="font-size: 12px; opacity: 0.7;">In progress</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">Funded Accounts</div>
                <div class="financial-value positive" id="fundedAccounts">0</div>
                <div style="font-size: 12px; opacity: 0.7;">Generating revenue</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">Success Rate</div>
                <div class="financial-value" id="successRate">0%</div>
                <div style="font-size: 12px; opacity: 0.7;">Challenge to funded</div>
            </div>
            <div class="financial-card">
                <div class="financial-label">ROI</div>
                <div class="financial-value positive" id="portfolioROI">0%</div>
                <div style="font-size: 12px; opacity: 0.7;">Monthly return</div>
            </div>
        </div>
    </div>

    

</div><!-- container -->
{% endblock %}

{% block extra_js %}
<script>
let d3Charts = {};
        
        function updateDateTime() {
            const now = new Date();
            const options = {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                timeZoneName: 'short'
            };
            const element = document.getElementById('currentDateTime');
            if (element) {
                element.textContent = now.toLocaleDateString('en-US', options);
            }
        }
        
        function loadFinancialData() {
            // Load data from prop firms
            const currentMonth = '2024-01';
            const propFirms = JSON.parse(localStorage.getItem(`propFirmsV2_${currentMonth}`)) || [];
            const exchangeRates = { USD: 1.5, EUR: 1.65, GBP: 1.9, AUD: 1.0 };
            
            // Calculate metrics
            const fundedFirms = propFirms.filter(f => f.status === 'funded');
            const challengeFirms = propFirms.filter(f => f.status === 'challenge');
            
            const totalPortfolio = fundedFirms.reduce((sum, f) => sum + f.accountSize * exchangeRates[f.currency], 0);
            const monthlyRevenue = fundedFirms.reduce((sum, f) => sum + (f.monthlyProfit || 0) * exchangeRates[f.currency], 0);
            const netProfit = monthlyRevenue * 0.75; // After 25% tax
            const annualProjection = netProfit * 12;
            const successRate = propFirms.length > 0 ? ((fundedFirms.length / propFirms.length) * 100).toFixed(1) : 0;
            const portfolioROI = totalPortfolio > 0 ? ((monthlyRevenue / totalPortfolio) * 100).toFixed(2) : 0;
            
            // Update display
            document.getElementById('totalPortfolio').textContent = '$' + totalPortfolio.toLocaleString();
            document.getElementById('monthlyRevenue').textContent = '$' + monthlyRevenue.toLocaleString();
            document.getElementById('netProfit').textContent = '$' + netProfit.toLocaleString();
            document.getElementById('annualProjection').textContent = '$' + annualProjection.toLocaleString();
            document.getElementById('activeChallenges').textContent = challengeFirms.length;
            document.getElementById('fundedAccounts').textContent = fundedFirms.length;
            document.getElementById('successRate').textContent = successRate + '%';
            document.getElementById('portfolioROI').textContent = portfolioROI + '%';
            
            // Update charts
            updateCharts(fundedFirms, monthlyRevenue);
        }
        
        function updateCharts(fundedFirms, monthlyRevenue) {
            if (typeof d3 === 'undefined') {
                console.warn('D3.js not loaded');
                return;
            }
            
            // Performance Chart
            createD3LineChart('d3PerformanceChart', 
                [monthlyRevenue * 0.6, monthlyRevenue * 0.8, monthlyRevenue, monthlyRevenue * 1.1, monthlyRevenue * 0.9, monthlyRevenue * 1.2],
                ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                '#00ff88'
            );
            
            // Allocation Chart
            createD3PieChart('d3AllocationChart',
                [30, 25, 15, 15, 10, 5],
                ['Salary', 'Investments', 'SMSF', 'Property', 'Emergency', 'Other'],
                ['#00ff88', '#00d4aa', '#17a2b8', '#ffa502', '#ff4757', '#3742fa']
            );
            
            // Revenue Growth Chart
            const revenueData = Array.from({length: 12}, (_, i) => monthlyRevenue * (0.8 + Math.random() * 0.4));
            createD3AreaChart('d3RevenueChart', revenueData, 
                ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                '#ffa502'
            );
            
            // Profit Distribution Chart
            createD3BarChart('d3ProfitChart',
                fundedFirms.map(f => f.monthlyProfit || Math.random() * 5000),
                fundedFirms.map(f => f.name || 'Firm'),
                '#3742fa'
            );
        }
        
        function createD3LineChart(containerId, data, labels, color) {
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 250 - margin.top - margin.bottom;
            
            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleBand().domain(labels).range([0, width]).padding(0.1);
            const yScale = d3.scaleLinear().domain([0, d3.max(data)]).nice().range([height, 0]);
            
            const line = d3.line()
                .x((d, i) => xScale(labels[i]) + xScale.bandwidth() / 2)
                .y(d => yScale(d))
                .curve(d3.curveMonotoneX);
            
            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', color)
                .attr('stroke-width', 2)
                .attr('d', line);
            
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text').style('fill', 'white');
            
            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text').style('fill', 'white');
        }
        
        function createD3PieChart(containerId, data, labels, colors) {
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = 250;
            const radius = Math.min(width, height) / 2 - 10;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${width/2},${height/2})`);
            
            const pie = d3.pie().value(d => d);
            const arc = d3.arc().innerRadius(0).outerRadius(radius);
            
            const arcs = g.selectAll('.arc')
                .data(pie(data))
                .enter().append('g')
                .attr('class', 'arc');
            
            arcs.append('path')
                .attr('d', arc)
                .attr('fill', (d, i) => colors[i]);
            
            arcs.append('text')
                .attr('transform', d => `translate(${arc.centroid(d)})`)
                .attr('text-anchor', 'middle')
                .style('fill', 'white')
                .style('font-size', '12px')
                .text((d, i) => labels[i]);
        }
        
        function createD3AreaChart(containerId, data, labels, color) {
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 250 - margin.top - margin.bottom;
            
            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleBand().domain(labels).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, d3.max(data)]).nice().range([height, 0]);
            
            const area = d3.area()
                .x((d, i) => xScale(labels[i]))
                .y0(height)
                .y1(d => yScale(d))
                .curve(d3.curveMonotoneX);
            
            g.append('path')
                .datum(data)
                .attr('fill', color + '40')
                .attr('d', area);
            
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text').style('fill', 'white');
            
            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text').style('fill', 'white');
        }
        
        function createD3BarChart(containerId, data, labels, color) {
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 250 - margin.top - margin.bottom;
            
            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleBand().domain(labels).range([0, width]).padding(0.1);
            const yScale = d3.scaleLinear().domain([0, d3.max(data)]).nice().range([height, 0]);
            
            g.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', (d, i) => xScale(labels[i]))
                .attr('width', xScale.bandwidth())
                .attr('y', d => yScale(d))
                .attr('height', d => height - yScale(d))
                .attr('fill', color);
            
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text').style('fill', 'white');
            
            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text').style('fill', 'white');
        }
        
        function changeTheme() {
            const theme = document.getElementById('themeSelector').value;
            const body = document.body;
            
            body.className = body.className.replace(/theme-\w+/g, '');
            body.classList.add(`theme-${theme}`);
            
            const root = document.documentElement;
            switch(theme) {
                case 'dark': root.style.setProperty('--accent-color', '#4a9eff'); break;
                case 'minimal': root.style.setProperty('--accent-color', '#007bff'); break;
                case 'neon': root.style.setProperty('--accent-color', '#ff0080'); break;
                case 'gold': root.style.setProperty('--accent-color', '#ffd700'); break;
                default: root.style.setProperty('--accent-color', '#00ff88');
            }
            
            localStorage.setItem('selectedTheme', theme);
        }
        
        function loadTheme() {
            const savedTheme = localStorage.getItem('selectedTheme') || 'gradient';
            document.getElementById('themeSelector').value = savedTheme;
            changeTheme();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            loadTheme();
            updateDateTime();
            loadFinancialData();
            setInterval(updateDateTime, 30000);
        });
</script>

<script>
function changeStyle() {
    const style = document.getElementById('styleSelector').value;
    if (window.professionalStyles) {
        window.professionalStyles.setStyle(style);
    }
}

function loadStyle() {
    const savedStyle = localStorage.getItem('professionalStyle') || 'slate';
    const selector = document.getElementById('styleSelector');
    if (selector) {
        selector.value = savedStyle;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        loadStyle();
    }, 100);
});
</script>

{% endblock %}
