//@version=5
indicator("NASDAQ Real-Time Price Streamer - Optimized", overlay=false)

// ============================================================================
// OPTIMIZED REAL-TIME PRICE STREAMING INDICATOR
// ============================================================================
// This indicator reduces alert frequency to avoid TradingView limits while
// still providing near real-time price data for your automation system
// ============================================================================

// Configuration
webhook_url = input.string("https://web-production-cd33.up.railway.app/api/realtime-price", "Real-Time Price Webhook URL")
enable_streaming = input.bool(true, "Enable Real-Time Price Streaming")

// FREQUENCY CONTROL - Key to avoiding "triggered too often"
update_frequency = input.int(5, "Update Frequency (seconds)", minval=1, maxval=60)
price_threshold = input.float(0.50, "Minimum Price Change to Send Update (points)", minval=0.1)

// Session filtering
enable_session_filter = input.bool(true, "Only Stream During Active Sessions")

// ============================================================================
// SESSION DETECTION
// ============================================================================

get_current_session() =>
    current_hour = hour(time, "America/New_York")
    current_minute = minute(time, "America/New_York")
    
    session_name = ""
    
    // ASIA: 20:00-23:59
    if current_hour >= 20 and current_hour <= 23
        session_name := "ASIA"
    // LONDON: 00:00-05:59  
    else if current_hour >= 0 and current_hour <= 5
        session_name := "LONDON"
    // NY PRE: 06:00-08:29
    else if current_hour >= 6 and (current_hour < 8 or (current_hour == 8 and current_minute <= 29))
        session_name := "NY PRE"
    // NY AM: 08:30-11:59
    else if (current_hour == 8 and current_minute >= 30) or (current_hour >= 9 and current_hour <= 11)
        session_name := "NY AM"
    // NY LUNCH: 12:00-12:59
    else if current_hour == 12
        session_name := "NY LUNCH"
    // NY PM: 13:00-15:59
    else if current_hour >= 13 and current_hour <= 15
        session_name := "NY PM"
    else
        session_name := "INVALID"
    
    session_name

// ============================================================================
// SMART FREQUENCY CONTROL
// ============================================================================

// Track last update time and price
var float last_sent_price = na
var int last_sent_time = na

// Check if enough time has passed since last update
time_threshold_met() =>
    if na(last_sent_time)
        true  // First update
    else
        (time - last_sent_time) >= (update_frequency * 1000)  // Convert seconds to milliseconds

// Check if price change is significant
price_change_significant() =>
    if na(last_sent_price)
        true  // First price
    else
        math.abs(close - last_sent_price) >= price_threshold

// ============================================================================
// ENHANCED STREAMING LOGIC
// ============================================================================

should_stream_update() =>
    current_session = get_current_session()
    
    // Basic checks
    if not enable_streaming
        false
    else if enable_session_filter and current_session == "INVALID"
        false
    else if not time_threshold_met() and not price_change_significant()
        false  // Wait for time threshold OR significant price change
    else
        true

// Create optimized price payload
create_optimized_payload() =>
    current_session = get_current_session()
    price_change = na(last_sent_price) ? 0 : close - last_sent_price
    
    payload = '{"type":"realtime_price",' +
              '"symbol":"NQ",' +
              '"price":' + str.tostring(close) + ',' +
              '"timestamp":' + str.tostring(time) + ',' +
              '"session":"' + current_session + '",' +
              '"volume":' + str.tostring(volume) + ',' +
              '"change":' + str.tostring(price_change) + ',' +
              '"bid":' + str.tostring(close - 0.25) + ',' +
              '"ask":' + str.tostring(close + 0.25) + '}'
    
    payload

// ============================================================================
// OPTIMIZED STREAMING EXECUTION
// ============================================================================

if should_stream_update() and barstate.isconfirmed
    // Send the update
    payload = create_optimized_payload()
    alert(payload, alert.freq_once_per_bar)
    
    // Update tracking variables
    last_sent_price := close
    last_sent_time := time
    
    // Visual confirmation
    if barstate.islast
        label.new(bar_index, close, "SENT: $" + str.tostring(close), 
                  color=color.green, textcolor=color.white, size=size.tiny)

// ============================================================================
// VISUAL ELEMENTS
// ============================================================================

// Plot price with color coding
price_color = close > (last_sent_price ? last_sent_price : close) ? color.green : color.red
plot(close, title="NASDAQ Price", color=price_color, linewidth=2)

// Plot update frequency indicator
seconds_since_last = na(last_sent_time) ? 0 : (time - last_sent_time) / 1000
plot(seconds_since_last, title="Seconds Since Last Update", color=color.blue, display=display.data_window)

// ============================================================================
// ENHANCED STATUS DASHBOARD
// ============================================================================

if barstate.islast
    var table status_table = table.new(position.top_right, 2, 8, bgcolor=color.white, border_width=1)
    
    current_session = get_current_session()
    session_color = current_session == "INVALID" ? color.red : color.green
    
    // Session
    table.cell(status_table, 0, 0, "Session", text_color=color.black, bgcolor=color.yellow)
    table.cell(status_table, 1, 0, current_session, text_color=color.white, bgcolor=session_color)
    
    // Current price
    table.cell(status_table, 0, 1, "Price", text_color=color.black)
    table.cell(status_table, 1, 1, "$" + str.tostring(close), text_color=color.black)
    
    // Price change since last sent
    price_change = na(last_sent_price) ? 0 : close - last_sent_price
    change_color = price_change > 0 ? color.green : price_change < 0 ? color.red : color.gray
    table.cell(status_table, 0, 2, "Change", text_color=color.black)
    table.cell(status_table, 1, 2, str.tostring(price_change), text_color=color.white, bgcolor=change_color)
    
    // Update frequency setting
    table.cell(status_table, 0, 3, "Frequency", text_color=color.black)
    table.cell(status_table, 1, 3, str.tostring(update_frequency) + "s", text_color=color.black)
    
    // Time since last update
    seconds_since = na(last_sent_time) ? 0 : (time - last_sent_time) / 1000
    time_color = seconds_since >= update_frequency ? color.orange : color.green
    table.cell(status_table, 0, 4, "Last Update", text_color=color.black)
    table.cell(status_table, 1, 4, str.tostring(math.round(seconds_since)) + "s ago", text_color=color.white, bgcolor=time_color)
    
    // Streaming status
    streaming_status = enable_streaming ? "ON" : "OFF"
    streaming_color = enable_streaming ? color.green : color.red
    table.cell(status_table, 0, 5, "Streaming", text_color=color.black)
    table.cell(status_table, 1, 5, streaming_status, text_color=color.white, bgcolor=streaming_color)
    
    // Price threshold
    table.cell(status_table, 0, 6, "Threshold", text_color=color.black)
    table.cell(status_table, 1, 6, str.tostring(price_threshold) + " pts", text_color=color.black)
    
    // Volume
    table.cell(status_table, 0, 7, "Volume", text_color=color.black)
    table.cell(status_table, 1, 7, str.tostring(volume), text_color=color.black)

// ============================================================================
// ALERT FREQUENCY OPTIMIZATION SUMMARY
// ============================================================================
// 
// PROBLEM: 1-second alerts = 3600/hour → "triggered too often"
// 
// SOLUTIONS IMPLEMENTED:
// 1. Time-based throttling (default 5 seconds = 720 alerts/hour max)
// 2. Price change threshold (only send if price moves significantly)
// 3. Session filtering (reduce alerts during low-activity periods)
// 4. Smart triggering (time OR price change, whichever comes first)
// 
// RESULT: ~100-200 alerts/hour instead of 3600/hour
// 
// RECOMMENDED SETTINGS:
// - Pro account: 5-10 second frequency
// - Premium account: 3-5 second frequency  
// - Free account: 15-30 second frequency
// 
// ============================================================================

// Debug indicators
plotchar(should_stream_update(), "Will Stream", "●", location.bottom, 
         color=color.green, size=size.small, display=display.data_window)
plotchar(time_threshold_met(), "Time OK", "T", location.bottom, 
         color=color.blue, size=size.tiny, display=display.data_window)
plotchar(price_change_significant(), "Price OK", "P", location.bottom, 
         color=color.orange, size=size.tiny, display=display.data_window)