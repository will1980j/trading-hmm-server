//@version=5
strategy("Automated Position Sizer - Exact Methodology", overlay=true, initial_capital=100000, default_qty_type=strategy.cash, commission_type=strategy.commission.cash_per_contract, commission_value=2.40)

// ============================================================================
// INPUTS
// ============================================================================

// Account & Risk Settings
account_size = input.float(100000, "Account Size ($)", group="Risk Management")
risk_percent = input.float(1.0, "Risk Per Trade (%)", minval=0.1, maxval=100, step=0.1, group="Risk Management")
buffer_points = input.int(25, "Stop Loss Buffer (Points)", minval=1, group="Risk Management")

// Signal Detection (placeholder - replace with your actual signal logic)
use_manual_signal = input.bool(true, "Manual Signal Mode", group="Signal Detection")
signal_type = input.string("None", "Manual Signal", options=["None", "Bullish", "Bearish"], group="Signal Detection")

// Display Settings
show_info_table = input.bool(true, "Show Info Table", group="Display")
table_position = input.string("top_right", "Table Position", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="Display")

// ============================================================================
// PIVOT DETECTION FUNCTION
// ============================================================================

// 3-candle pivot detection
is_pivot_low(index) =>
    low[index] < low[index-1] and low[index] < low[index+1]

is_pivot_high(index) =>
    high[index] > high[index-1] and high[index] > high[index+1]

// ============================================================================
// SIGNAL TRACKING VARIABLES
// ============================================================================

var float signal_candle_high = na
var float signal_candle_low = na
var int signal_bar_index = na
var string active_signal = "None"
var bool waiting_for_confirmation = false

var float entry_price = na
var float stop_loss_price = na
var float risk_distance = na
var int contract_size = na
var bool trade_ready = false

// ============================================================================
// SIGNAL DETECTION (PLACEHOLDER)
// ============================================================================

// Detect new signal
bullish_signal = use_manual_signal ? (signal_type == "Bullish" and signal_type[1] != "Bullish") : false
bearish_signal = use_manual_signal ? (signal_type == "Bearish" and signal_type[1] != "Bearish") : false

// Reset on new signal
if bullish_signal
    signal_candle_high := high
    signal_candle_low := low
    signal_bar_index := bar_index
    active_signal := "Bullish"
    waiting_for_confirmation := true
    trade_ready := false
    entry_price := na
    stop_loss_price := na

if bearish_signal
    signal_candle_high := high
    signal_candle_low := low
    signal_bar_index := bar_index
    active_signal := "Bearish"
    waiting_for_confirmation := true
    trade_ready := false
    entry_price := na
    stop_loss_price := na

// Cancel signal on opposite signal
if bullish_signal and active_signal == "Bearish"
    active_signal := "None"
    waiting_for_confirmation := false

if bearish_signal and active_signal == "Bullish"
    active_signal := "None"
    waiting_for_confirmation := false

// ============================================================================
// CONFIRMATION MONITORING
// ============================================================================

if waiting_for_confirmation and active_signal == "Bullish"
    // Check for bullish confirmation: close above signal candle high
    if close > signal_candle_high
        waiting_for_confirmation := false
        
        // Entry = next candle open (we'll use current close as proxy)
        entry_price := close
        
        // Find lowest point between signal candle and confirmation
        int bars_since_signal = bar_index - signal_bar_index
        float lowest_low = low
        int lowest_bar_offset = 0
        
        for i = 1 to bars_since_signal
            if low[i] < lowest_low
                lowest_low := low[i]
                lowest_bar_offset := i
        
        // Check if lowest point is a pivot
        bool lowest_is_pivot = false
        if lowest_bar_offset >= 1 and lowest_bar_offset <= bars_since_signal - 1
            lowest_is_pivot := is_pivot_low(lowest_bar_offset)
        
        // Calculate stop loss based on methodology
        if lowest_is_pivot
            // Scenario A: Lowest point is pivot
            stop_loss_price := lowest_low - buffer_points
        else if lowest_bar_offset == bars_since_signal
            // Lowest point is signal candle
            bool signal_is_pivot = bars_since_signal >= 1 and is_pivot_low(bars_since_signal)
            
            if signal_is_pivot
                // Scenario B: Signal candle is pivot
                stop_loss_price := lowest_low - buffer_points
            else
                // Scenario C: Search left 5 candles for pivot
                bool found_pivot = false
                float pivot_low = na
                
                for i = (bars_since_signal + 1) to (bars_since_signal + 5)
                    if i <= bar_index and is_pivot_low(i)
                        pivot_low := low[i]
                        found_pivot := true
                        break
                
                if found_pivot
                    stop_loss_price := pivot_low - buffer_points
                else
                    // No pivot found: use first bearish candle low
                    float bearish_candle_low = lowest_low
                    for i = (bars_since_signal + 1) to (bars_since_signal + 5)
                        if i <= bar_index and close[i] < open[i]
                            bearish_candle_low := low[i]
                            break
                    stop_loss_price := bearish_candle_low - buffer_points
        
        // Calculate risk and position size
        risk_distance := entry_price - stop_loss_price
        float risk_amount = account_size * (risk_percent / 100)
        contract_size := math.floor(risk_amount / risk_distance)
        trade_ready := true

if waiting_for_confirmation and active_signal == "Bearish"
    // Check for bearish confirmation: close below signal candle low
    if close < signal_candle_low
        waiting_for_confirmation := false
        
        // Entry = next candle open (we'll use current close as proxy)
        entry_price := close
        
        // Find highest point between signal candle and confirmation
        int bars_since_signal = bar_index - signal_bar_index
        float highest_high = high
        int highest_bar_offset = 0
        
        for i = 1 to bars_since_signal
            if high[i] > highest_high
                highest_high := high[i]
                highest_bar_offset := i
        
        // Check if highest point is a pivot
        bool highest_is_pivot = false
        if highest_bar_offset >= 1 and highest_bar_offset <= bars_since_signal - 1
            highest_is_pivot := is_pivot_high(highest_bar_offset)
        
        // Calculate stop loss based on methodology
        if highest_is_pivot
            // Scenario A: Highest point is pivot
            stop_loss_price := highest_high + buffer_points
        else if highest_bar_offset == bars_since_signal
            // Highest point is signal candle
            bool signal_is_pivot = bars_since_signal >= 1 and is_pivot_high(bars_since_signal)
            
            if signal_is_pivot
                // Scenario B: Signal candle is pivot
                stop_loss_price := highest_high + buffer_points
            else
                // Scenario C: Search left 5 candles for pivot
                bool found_pivot = false
                float pivot_high = na
                
                for i = (bars_since_signal + 1) to (bars_since_signal + 5)
                    if i <= bar_index and is_pivot_high(i)
                        pivot_high := high[i]
                        found_pivot := true
                        break
                
                if found_pivot
                    stop_loss_price := pivot_high + buffer_points
                else
                    // No pivot found: use first bullish candle high
                    float bullish_candle_high = highest_high
                    for i = (bars_since_signal + 1) to (bars_since_signal + 5)
                        if i <= bar_index and close[i] > open[i]
                            bullish_candle_high := high[i]
                            break
                    stop_loss_price := bullish_candle_high + buffer_points
        
        // Calculate risk and position size
        risk_distance := stop_loss_price - entry_price
        float risk_amount = account_size * (risk_percent / 100)
        contract_size := math.floor(risk_amount / risk_distance)
        trade_ready := true

// ============================================================================
// VISUALIZATION
// ============================================================================

// Plot signal candle markers
plotshape(bullish_signal, "Bullish Signal", shape.triangleup, location.belowbar, color.blue, size=size.small)
plotshape(bearish_signal, "Bearish Signal", shape.triangledown, location.abovebar, color.red, size=size.small)

// Plot entry and stop loss lines when trade is ready
plot(trade_ready and active_signal == "Bullish" ? entry_price : na, "Entry Price", color.green, 2, plot.style_linebr)
plot(trade_ready and active_signal == "Bullish" ? stop_loss_price : na, "Stop Loss", color.red, 2, plot.style_linebr)
plot(trade_ready and active_signal == "Bearish" ? entry_price : na, "Entry Price", color.green, 2, plot.style_linebr)
plot(trade_ready and active_signal == "Bearish" ? stop_loss_price : na, "Stop Loss", color.red, 2, plot.style_linebr)

// ============================================================================
// INFO TABLE
// ============================================================================

if show_info_table
    var table info_table = table.new(table_position == "top_left" ? position.top_left : table_position == "top_center" ? position.top_center : table_position == "top_right" ? position.top_right : table_position == "middle_left" ? position.middle_left : table_position == "middle_center" ? position.middle_center : table_position == "middle_right" ? position.middle_right : table_position == "bottom_left" ? position.bottom_left : table_position == "bottom_center" ? position.bottom_center : position.bottom_right, 2, 8, border_width=2)
    
    // Header
    table.cell(info_table, 0, 0, "Automated Position Sizer", text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
    table.merge_cells(info_table, 0, 0, 1, 0)
    
    // Status
    string status_text = waiting_for_confirmation ? "‚è≥ Waiting Confirmation" : trade_ready ? "‚úÖ TRADE READY" : "‚ö™ No Signal"
    color status_color = waiting_for_confirmation ? color.orange : trade_ready ? color.green : color.gray
    table.cell(info_table, 0, 1, "Status:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 1, status_text, text_color=color.white, bgcolor=color.new(status_color, 50))
    
    // Signal Type
    table.cell(info_table, 0, 2, "Signal:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 2, active_signal, text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    // Entry Price
    table.cell(info_table, 0, 3, "Entry:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 3, trade_ready ? str.tostring(entry_price, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    // Stop Loss
    table.cell(info_table, 0, 4, "Stop Loss:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 4, trade_ready ? str.tostring(stop_loss_price, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    // Risk Distance
    table.cell(info_table, 0, 5, "Risk (pts):", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 5, trade_ready ? str.tostring(risk_distance, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    // Contract Size (THE MONEY SHOT)
    table.cell(info_table, 0, 6, "üìä CONTRACTS:", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.large)
    table.cell(info_table, 1, 6, trade_ready ? str.tostring(contract_size) : "-", text_color=color.yellow, bgcolor=color.new(color.blue, 30), text_size=size.large)
    
    // Risk Amount
    float risk_dollar = account_size * (risk_percent / 100)
    table.cell(info_table, 0, 7, "Risk $:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(info_table, 1, 7, "$" + str.tostring(risk_dollar, "#,###"), text_color=color.white, bgcolor=color.new(color.gray, 70))
