 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Signals Dashboard | Trading Platform</title>
    <!-- D3.js for journey visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e6ed;
            min-height: 100vh;
        }

        .dashboard-container {
            padding: 20px;
            max-width: 1920px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            font-weight: 600;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 8px 16px rgba(0, 212, 255, 0.2);
        }

        .stat-label {
            color: #94a3b8;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.positive {
            color: #4ade80;
        }

        .stat-value.negative {
            color: #ef4444;
        }

        /* Main Content Grid */
        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Signals Table */
        .signals-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 20px;
            font-weight: 600;
            color: #00d4ff;
        }

        .filter-tabs {
            display: flex;
            gap: 10px;
        }

        .filter-tab {
            padding: 6px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .filter-tab:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .filter-tab.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            color: #00d4ff;
        }

        .signals-table {
            width: 100%;
            border-collapse: collapse;
        }

        .signals-table th {
            text-align: left;
            padding: 12px;
            color: #94a3b8;
            font-weight: 600;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .signals-table td {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .signals-table tr:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        .direction-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .direction-badge.bullish {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .direction-badge.bearish {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-badge.active {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .status-badge.completed {
            background: rgba(139, 92, 246, 0.2);
            color: #8b5cf6;
        }

        /* Status Dots */
        .trade-status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .trade-status-dot.active-both {
            background: #4ade80;
            animation: pulse-green 2s infinite;
            box-shadow: 0 0 8px #4ade80;
        }

        .trade-status-dot.active-no-be {
            background: #3b82f6;
            animation: pulse-blue 2s infinite;
            box-shadow: 0 0 8px #3b82f6;
        }

        @keyframes pulse-green {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.15); }
        }

        @keyframes pulse-blue {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.15); }
        }

        .trade-number {
            font-weight: 700;
            color: #00d4ff;
            font-size: 14px;
        }

        /* Activity Feed */
        .activity-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }

        .activity-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid #00d4ff;
        }

        .activity-item.new {
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .activity-time {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 5px;
        }

        .activity-content {
            font-size: 14px;
            color: #e0e6ed;
        }

        .activity-content strong {
            color: #00d4ff;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #64748b;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        /* Calendar Styles */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .calendar-day {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            min-height: 90px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .calendar-day:hover {
            background: rgba(0,212,255,0.2);
            transform: translateY(-2px);
        }

        .calendar-day.has-trades {
            background: rgba(0,212,255,0.1);
            border-color: rgba(0,212,255,0.3);
        }

        .calendar-day.has-active {
            background: rgba(255,165,0,0.2);
            border-color: rgba(255,165,0,0.6);
            animation: pulse-active 2s infinite;
        }

        .calendar-day.selected {
            background: rgba(0,212,255,0.3);
            border-color: #00d4ff;
        }

        .calendar-day.empty {
            opacity: 0.3;
            cursor: default;
        }

        .calendar-day.empty:hover {
            background: rgba(255,255,255,0.05);
            transform: none;
        }

        .day-number {
            font-size: 28px;
            font-weight: 700;
            color: rgba(255,255,255,0.9);
            line-height: 1;
            min-width: 32px;
            flex-shrink: 0;
        }

        .day-data {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
            font-size: 10px;
            line-height: 1.2;
        }

        .day-trades {
            font-size: 10px;
            color: #00d4ff;
            font-weight: 600;
        }

        .day-active {
            font-size: 9px;
            color: #ffa502;
            font-weight: 600;
            margin-top: 2px;
        }

        .day-stats {
            font-size: 9px;
            color: rgba(255,255,255,0.7);
            margin-top: 2px;
        }

        @keyframes pulse-active {
            0% { box-shadow: 0 0 0 0 rgba(255,165,0,0.4); }
            70% { box-shadow: 0 0 0 8px rgba(255,165,0,0); }
            100% { box-shadow: 0 0 0 0 rgba(255,165,0,0); }
        }

        .calendar-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .calendar-header-day {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            padding: 8px;
        }

        .month-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .month-nav button {
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .month-nav button:hover {
            background: rgba(0,212,255,0.3);
            transform: translateY(-1px);
        }

        .month-title {
            font-size: 16px;
            font-weight: 600;
            color: #00d4ff;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .calendar-grid {
                gap: 4px;
            }

            .calendar-day {
                min-height: 70px;
                padding: 4px;
            }

            .day-number {
                font-size: 20px;
            }
        }
    
        /* Trade Detail Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1f3a 0%, #0a0e27 100%);
            margin: 5% auto;
            padding: 0;
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #00d4ff;
            margin: 0;
        }

        .close-modal {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-modal:hover {
            color: #00d4ff;
        }

        .modal-body {
            padding: 30px;
        }

        .detail-section {
            margin-bottom: 30px;
        }

        .detail-section h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .detail-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-label {
            color: #94a3b8;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .detail-value {
            color: #e0e6ed;
            font-size: 16px;
            font-weight: 600;
        }

        .event-timeline {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 20px;
        }

        .event-item {
            padding: 15px;
            border-left: 3px solid #00d4ff;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .event-item:last-child {
            margin-bottom: 0;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .event-type {
            font-weight: 600;
            color: #00d4ff;
            font-size: 14px;
        }

        .event-time {
            color: #64748b;
            font-size: 12px;
        }

        .event-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 12px;
        }

        .event-detail {
            color: #94a3b8;
        }

        .event-detail strong {
            color: #e0e6ed;
        }

        .clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }


        /* Trade Journey Visualization */
        .journey-container {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .journey-title {
            color: #00d4ff;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #journeyViz {
            width: 100%;
            height: 400px;
            position: relative;
        }

        .journey-node {
            cursor: pointer;
            transition: filter 0.2s ease;
        }

        .journey-node:hover {
            /* Removed scale transform to prevent vibration */
            filter: brightness(1.2);
        }

        .journey-link {
            fill: none;
            stroke-width: 4px;
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        .journey-link.completed {
            stroke: #4ade80;
            opacity: 0.8;
        }

        .journey-link.active {
            stroke: #00d4ff;
            opacity: 1;
            animation: pulse-line 2s infinite;
        }

        .journey-link.potential {
            stroke: #94a3b8;
            stroke-dasharray: 8,8;
            opacity: 0.3;
        }

        @keyframes pulse-line {
            0%, 100% { 
                opacity: 1;
                stroke-width: 4px;
            }
            50% { 
                opacity: 0.6;
                stroke-width: 6px;
            }
        }

        .node-circle {
            filter: drop-shadow(0 0 10px currentColor);
            transition: filter 0.2s ease;
        }

        .journey-node:hover .node-circle {
            filter: drop-shadow(0 0 20px currentColor) brightness(1.2);
        }

        .node-label {
            font-size: 12px;
            font-weight: 600;
            fill: #e0e6ed;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-time {
            font-size: 10px;
            fill: #94a3b8;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-value {
            font-size: 13px;
            font-weight: 700;
            fill: #00d4ff;
            text-anchor: middle;
            pointer-events: none;
        }

        .current-indicator {
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% {
                filter: drop-shadow(0 0 12px #00d4ff) drop-shadow(0 0 20px #00d4ff);
            }
            50% {
                filter: drop-shadow(0 0 20px #00d4ff) drop-shadow(0 0 30px #00d4ff);
            }
        }

        .journey-legend {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 25px;
            font-size: 12px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #94a3b8;
        }

        .legend-line {
            width: 35px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-line.completed { background: #4ade80; }
        .legend-line.active { 
            background: #00d4ff;
            animation: pulse-legend 2s infinite;
        }
        .legend-line.potential { 
            background: #94a3b8; 
            opacity: 0.3;
        }

        @keyframes pulse-legend {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .clickable-row:hover {
            background: rgba(0, 212, 255, 0.15) !important;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    
<!-- SYSTEM HEALTH MONITOR -->
<style>
.health-monitor {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border-bottom: 2px solid #0f3460;
    padding: 12px 20px;
    margin: -20px -20px 20px -20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}

.health-status-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
}

.health-overall {
    display: flex;
    align-items: center;
    gap: 12px;
}

.health-pulse {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    animation: pulse 2s ease-in-out infinite;
}

.health-pulse.healthy {
    background: #00ff88;
    box-shadow: 0 0 10px #00ff88;
}

.health-pulse.warning {
    background: #ffaa00;
    box-shadow: 0 0 10px #ffaa00;
}

.health-pulse.critical {
    background: #ff3366;
    box-shadow: 0 0 10px #ff3366;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.2); }
}

.health-title {
    font-size: 14px;
    font-weight: 600;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.health-components {
    display: flex;
    gap: 15px;
    flex: 1;
    justify-content: center;
}

.health-component {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background: rgba(255,255,255,0.05);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.1);
    transition: all 0.3s ease;
    cursor: pointer;
}

.health-component:hover {
    background: rgba(255,255,255,0.1);
    transform: translateY(-2px);
}

.health-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.health-dot.healthy { background: #00ff88; }
.health-dot.warning { background: #ffaa00; }
.health-dot.critical { background: #ff3366; }

.health-label {
    font-size: 11px;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.health-value {
    font-size: 12px;
    color: #fff;
    font-weight: 600;
}

.health-actions {
    display: flex;
    gap: 10px;
}

.health-btn {
    padding: 6px 12px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.health-btn:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.health-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    margin-top: 0;
}

.health-details.expanded {
    max-height: 500px;
    margin-top: 15px;
}

.health-details-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
}

.health-detail-card {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 15px;
}

.health-detail-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
}

.health-detail-title {
    font-size: 12px;
    color: #fff;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.health-detail-status {
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.health-detail-status.healthy {
    background: rgba(0,255,136,0.2);
    color: #00ff88;
}

.health-detail-status.warning {
    background: rgba(255,170,0,0.2);
    color: #ffaa00;
}

.health-detail-status.critical {
    background: rgba(255,51,102,0.2);
    color: #ff3366;
}

.health-detail-metrics {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.health-metric {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
}

.health-metric-label {
    color: #aaa;
}

.health-metric-value {
    color: #fff;
    font-weight: 600;
}

.health-issues {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.1);
}

.health-issue {
    font-size: 10px;
    color: #ffaa00;
    padding: 4px 0;
    display: flex;
    align-items: center;
    gap: 6px;
}

.health-issue::before {
    content: "‚ö†";
    font-size: 12px;
}

.health-timestamp {
    font-size: 10px;
    color: #666;
    text-align: right;
}

        /* Trade Detail Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1f3a 0%, #0a0e27 100%);
            margin: 5% auto;
            padding: 0;
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #00d4ff;
            margin: 0;
        }

        .close-modal {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-modal:hover {
            color: #00d4ff;
        }

        .modal-body {
            padding: 30px;
        }

        .detail-section {
            margin-bottom: 30px;
        }

        .detail-section h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .detail-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-label {
            color: #94a3b8;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .detail-value {
            color: #e0e6ed;
            font-size: 16px;
            font-weight: 600;
        }

        .event-timeline {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 20px;
        }

        .event-item {
            padding: 15px;
            border-left: 3px solid #00d4ff;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .event-item:last-child {
            margin-bottom: 0;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .event-type {
            font-weight: 600;
            color: #00d4ff;
            font-size: 14px;
        }

        .event-time {
            color: #64748b;
            font-size: 12px;
        }

        .event-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 12px;
        }

        .event-detail {
            color: #94a3b8;
        }

        .event-detail strong {
            color: #e0e6ed;
        }

        .clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }


        /* Trade Journey Visualization */
        .journey-container {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .journey-title {
            color: #00d4ff;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #journeyViz {
            width: 100%;
            height: 400px;
            position: relative;
        }

        .journey-node {
            cursor: pointer;
            transition: filter 0.2s ease;
        }

        .journey-node:hover {
            /* Removed scale transform to prevent vibration */
            filter: brightness(1.2);
        }

        .journey-link {
            fill: none;
            stroke-width: 4px;
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        .journey-link.completed {
            stroke: #4ade80;
            opacity: 0.8;
        }

        .journey-link.active {
            stroke: #00d4ff;
            opacity: 1;
            animation: pulse-line 2s infinite;
        }

        .journey-link.potential {
            stroke: #94a3b8;
            stroke-dasharray: 8,8;
            opacity: 0.3;
        }

        @keyframes pulse-line {
            0%, 100% { 
                opacity: 1;
                stroke-width: 4px;
            }
            50% { 
                opacity: 0.6;
                stroke-width: 6px;
            }
        }

        .node-circle {
            filter: drop-shadow(0 0 10px currentColor);
            transition: filter 0.2s ease;
        }

        .journey-node:hover .node-circle {
            filter: drop-shadow(0 0 20px currentColor) brightness(1.2);
        }

        .node-label {
            font-size: 12px;
            font-weight: 600;
            fill: #e0e6ed;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-time {
            font-size: 10px;
            fill: #94a3b8;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-value {
            font-size: 13px;
            font-weight: 700;
            fill: #00d4ff;
            text-anchor: middle;
            pointer-events: none;
        }

        .current-indicator {
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% {
                filter: drop-shadow(0 0 12px #00d4ff) drop-shadow(0 0 20px #00d4ff);
            }
            50% {
                filter: drop-shadow(0 0 20px #00d4ff) drop-shadow(0 0 30px #00d4ff);
            }
        }

        .journey-legend {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 25px;
            font-size: 12px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #94a3b8;
        }

        .legend-line {
            width: 35px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-line.completed { background: #4ade80; }
        .legend-line.active { 
            background: #00d4ff;
            animation: pulse-legend 2s infinite;
        }
        .legend-line.potential { 
            background: #94a3b8; 
            opacity: 0.3;
        }

        @keyframes pulse-legend {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .clickable-row:hover {
            background: rgba(0, 212, 255, 0.15) !important;
        }
    </style>

<div class="health-monitor">
    <div class="health-status-bar">
        <div class="health-overall">
            <div class="health-pulse healthy" id="healthPulse"></div>
            <div class="health-title">System Status</div>
        </div>
        
        <div class="health-components" id="healthComponents">
            <!-- Populated by JavaScript -->
        </div>
        
        <div class="health-actions">
            <button class="health-btn" onclick="toggleHealthDetails()">Details</button>
            <button class="health-btn" onclick="refreshHealth()">Refresh</button>
        </div>
    </div>
    
    <div class="health-details" id="healthDetails">
        <div class="health-details-grid" id="healthDetailsGrid">
            <!-- Populated by JavaScript -->
        </div>
    </div>
    
    <div class="health-timestamp" id="healthTimestamp"></div>
</div>

<script>
let healthData = null;
let healthDetailsExpanded = false;

// Load health status on page load
document.addEventListener('DOMContentLoaded', function() {
    refreshHealth();
    // Auto-refresh every 60 seconds
    setInterval(refreshHealth, 60000);
});

async function refreshHealth() {
    try {
        const response = await fetch('/api/system-health');
        healthData = await response.json();
        updateHealthDisplay();
    } catch (error) {
        console.error('Health check failed:', error);
        showHealthError();
    }
}

function updateHealthDisplay() {
    if (!healthData) return;
    
    // Update overall status pulse
    const pulse = document.getElementById('healthPulse');
    pulse.className = `health-pulse ${healthData.overall_status}`;
    
    // Update components
    const componentsDiv = document.getElementById('healthComponents');
    componentsDiv.innerHTML = '';
    
    const components = healthData.components;
    
    // Database
    if (components.database) {
        const queryTime = components.database.query_time_ms || 0;
        componentsDiv.appendChild(createComponentBadge(
            'Database',
            components.database.status || 'unknown',
            `${queryTime}ms`
        ));
    }
    
    // Webhook
    if (components.webhook) {
        const lastWebhook = components.webhook.last_webhook_seconds_ago;
        const webhookValue = (lastWebhook !== null && lastWebhook !== undefined) ? 
                            `${lastWebhook}s ago` : 'No data';
        componentsDiv.appendChild(createComponentBadge(
            'Webhooks',
            components.webhook.status || 'unknown',
            webhookValue
        ));
    }
    
    // Events
    if (components.events) {
        const mfeCoverage = components.events.mfe_coverage_percent || 0;
        componentsDiv.appendChild(createComponentBadge(
            'Events',
            components.events.status || 'unknown',
            `${mfeCoverage}% MFE`
        ));
    }
    
    // Freshness
    if (components.freshness) {
        const mfeAge = components.freshness.last_mfe_seconds_ago;
        const freshnessValue = (mfeAge !== null && mfeAge !== undefined) ? 
                              `${Math.floor(mfeAge/60)}m old` : 'No data';
        componentsDiv.appendChild(createComponentBadge(
            'Data',
            components.freshness.status || 'unknown',
            freshnessValue
        ));
    }
    
    // API
    if (components.api) {
        componentsDiv.appendChild(createComponentBadge(
            'API',
            components.api.status,
            `${components.api.response_time_ms}ms`
        ));
    }
    
    // Signal Integrity
    if (components.integrity) {
        const integrityMsg = components.integrity.message || 
                            `${components.integrity.signals_verified} signals`;
        componentsDiv.appendChild(createComponentBadge(
            'Integrity',
            components.integrity.status,
            integrityMsg
        ));
    }
    
    // Update timestamp
    const timestamp = new Date(healthData.timestamp).toLocaleTimeString();
    document.getElementById('healthTimestamp').textContent = `Last check: ${timestamp}`;
    
    // Update details if expanded
    if (healthDetailsExpanded) {
        updateHealthDetails();
    }
}

function createComponentBadge(label, status, value) {
    const div = document.createElement('div');
    div.className = 'health-component';
    div.onclick = () => {
        if (!healthDetailsExpanded) {
            toggleHealthDetails();
        }
    };
    
    div.innerHTML = `
        <div class="health-dot ${status}"></div>
        <div>
            <div class="health-label">${label}</div>
            <div class="health-value">${value}</div>
        </div>
    `;
    
    return div;
}

function toggleHealthDetails() {
    healthDetailsExpanded = !healthDetailsExpanded;
    const detailsDiv = document.getElementById('healthDetails');
    
    if (healthDetailsExpanded) {
        detailsDiv.classList.add('expanded');
        updateHealthDetails();
    } else {
        detailsDiv.classList.remove('expanded');
    }
}

function updateHealthDetails() {
    if (!healthData || !healthData.components) return;
    
    const grid = document.getElementById('healthDetailsGrid');
    grid.innerHTML = '';
    
    const components = healthData.components;
    
    // Database details
    if (components.database) {
        grid.appendChild(createDetailCard('Database', components.database, [
            { label: 'Connected', value: components.database.connected ? 'Yes' : 'No' },
            { label: 'Table Exists', value: components.database.table_exists ? 'Yes' : 'No' },
            { label: 'Row Count', value: components.database.row_count },
            { label: 'Query Time', value: `${components.database.query_time_ms}ms` },
            { label: 'Columns OK', value: components.database.columns_ok ? 'Yes' : 'No' }
        ]));
    }
    
    // Webhook details
    if (components.webhook) {
        const eventTypes = components.webhook.event_types || {};
        grid.appendChild(createDetailCard('Webhooks', components.webhook, [
            { label: 'Last Webhook', value: `${components.webhook.last_webhook_seconds_ago}s ago` },
            { label: 'Last Hour', value: components.webhook.webhooks_last_hour },
            { label: 'ENTRY Events', value: eventTypes.ENTRY || 0 },
            { label: 'MFE Updates', value: eventTypes.MFE_UPDATE || 0 },
            { label: 'BE Triggered', value: eventTypes.BE_TRIGGERED || 0 },
            { label: 'EXIT Events', value: (eventTypes.EXIT_STOP_LOSS || 0) + (eventTypes.EXIT_BREAK_EVEN || 0) }
        ]));
    }
    
    // Event flow details
    if (components.events) {
        grid.appendChild(createDetailCard('Event Flow', components.events, [
            { label: 'Active Trades', value: components.events.active_trades },
            { label: 'With MFE', value: components.events.trades_with_mfe },
            { label: 'MFE Coverage', value: `${components.events.mfe_coverage_percent}%` },
            { label: 'Completed Today', value: components.events.completed_today }
        ]));
    }
    
    // Data freshness details
    if (components.freshness) {
        grid.appendChild(createDetailCard('Data Freshness', components.freshness, [
            { label: 'Last MFE Update', value: `${components.freshness.last_mfe_seconds_ago}s ago` },
            { label: 'Last Entry', value: `${components.freshness.last_entry_seconds_ago}s ago` }
        ]));
    }
    
    // API details
    if (components.api) {
        grid.appendChild(createDetailCard('API Performance', components.api, [
            { label: 'Response Time', value: `${components.api.response_time_ms}ms` },
            { label: 'Status Code', value: components.api.status_code }
        ]));
    }
    
    // Signal Integrity details
    if (components.integrity) {
        const metrics = [
            { label: 'Signals Verified', value: components.integrity.signals_verified || 0 },
            { label: 'Errors Found', value: components.integrity.errors_found || 0 },
            { label: 'Warnings Found', value: components.integrity.warnings_found || 0 }
        ];
        
        // Add message if present
        if (components.integrity.message) {
            metrics.push({ label: 'Status', value: components.integrity.message });
        }
        
        grid.appendChild(createDetailCard('Signal Integrity', components.integrity, metrics));
    }
}

function createDetailCard(title, data, metrics) {
    const card = document.createElement('div');
    card.className = 'health-detail-card';
    
    let metricsHTML = metrics.map(m => `
        <div class="health-metric">
            <span class="health-metric-label">${m.label}:</span>
            <span class="health-metric-value">${m.value}</span>
        </div>
    `).join('');
    
    let issuesHTML = '';
    if (data.issues && data.issues.length > 0) {
        issuesHTML = `
            <div class="health-issues">
                ${data.issues.map(issue => `<div class="health-issue">${issue}</div>`).join('')}
            </div>
        `;
    }
    
    card.innerHTML = `
        <div class="health-detail-header">
            <div class="health-detail-title">${title}</div>
            <div class="health-detail-status ${data.status}">${data.status}</div>
        </div>
        <div class="health-detail-metrics">
            ${metricsHTML}
        </div>
        ${issuesHTML}
    `;
    
    return card;
}

function showHealthError() {
    const pulse = document.getElementById('healthPulse');
    pulse.className = 'health-pulse critical';
    
    const componentsDiv = document.getElementById('healthComponents');
    componentsDiv.innerHTML = '<div style="color: #ff3366; font-size: 12px;">Health check failed</div>';
}
</script>
<div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <h1>ü§ñ Automated Signals Dashboard</h1>
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connected</span>
            </div>
        </div>

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Completed Signals Today</div>
                <div class="stat-value" id="completedSignals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Current Active Trades</div>
                <div class="stat-value positive" id="activeTrades">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg BE=1 MFE</div>
                <div class="stat-value" id="avgBeMFE">0.00R</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg No BE MFE</div>
                <div class="stat-value" id="avgNoBeMFE">0.00R</div>
            </div>
        </div>

        <!-- Calendar Section -->
        <div class="signals-panel" style="margin-bottom: 20px;">
            <div class="panel-header">
                <h2 class="panel-title">Trading Calendar</h2>
                <div class="month-nav">
                    <button onclick="changeMonth(-1)">‚Üê Previous</button>
                    <span class="month-title" id="monthTitle"></span>
                    <button onclick="changeMonth(1)">Next ‚Üí</button>
                </div>
            </div>
            <div class="calendar-header">
                <div class="calendar-header-day">Sun</div>
                <div class="calendar-header-day">Mon</div>
                <div class="calendar-header-day">Tue</div>
                <div class="calendar-header-day">Wed</div>
                <div class="calendar-header-day">Thu</div>
                <div class="calendar-header-day">Fri</div>
                <div class="calendar-header-day">Sat</div>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar days will be generated by JavaScript -->
            </div>
        </div>

        <!-- Main Content -->
        <div class="content-grid">
            <!-- Signals Table -->
            <div class="signals-panel">
                <div class="panel-header">
                    <h2 class="panel-title">Live Signals</h2>
                    <div class="filter-tabs">
                        <div class="filter-tab active" data-filter="all">All</div>
                        <div class="filter-tab" data-filter="active">Active</div>
                        <div class="filter-tab" data-filter="completed">Completed</div>
                    </div>
                </div>
                <div id="signalsTableContainer">
                    <table class="signals-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>#</th>
                                <th>Time</th>
                                <th>Direction</th>
                                <th>Entry</th>
                                <th>Stop Loss</th>
                                <th>Session</th>
                                <th>BE=1 MFE</th>
                                <th>No BE MFE</th>
                                <th>Trade Status</th>
                            </tr>
                        </thead>
                        <tbody id="signalsTableBody">
                            <tr>
                                <td colspan="7">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">üìä</div>
                                        <div>Waiting for automated signals...</div>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocket Connection
        const socket = io();
        let signals = [];
        let currentFilter = 'all';
        let selectedDate = null;
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();

        // Connection Status
        socket.on('connect', () => {
            updateConnectionStatus(true);
            loadInitialData();
        });

        socket.on('disconnect', () => {
            updateConnectionStatus(false);
        });

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (connected) {
                dot.classList.remove('disconnected');
                text.textContent = 'Connected';
            } else {
                dot.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }

        // Load Initial Data
        async function loadInitialData() {
            try {
                const response = await fetch('/api/automated-signals/dashboard-data');
                const data = await response.json();
                
                if (data.success) {
                    // Combine active and completed trades
                    signals = [...(data.active_trades || []), ...(data.completed_trades || [])];
                    updateDashboard();
                    updateCalendar();
                }
            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        }

        // Listen for New Signals
        socket.on('new_automated_signal', (data) => {
            signals.unshift(data);
            updateDashboard();
            addActivityItem('New signal received', data);
        });

        socket.on('signal_confirmed', (data) => {
            updateSignalStatus(data.trade_id, 'confirmed');
            addActivityItem('Signal confirmed', data);
        });

        socket.on('signal_resolved', (data) => {
            updateSignalStatus(data.trade_id, 'resolved');
            addActivityItem('Trade resolved', data);
        });

        // Update Dashboard
        function updateDashboard() {
            updateStats();
            updateSignalsTable();
        }

        function updateStats() {
            const today = new Date().toDateString();
            const todaySignals = signals.filter(s => 
                new Date(s.timestamp || s.created_at).toDateString() === today
            );

            // Count completed and active trades
            const completedToday = todaySignals.filter(s => {
                const status = (s.trade_status || s.status || '').toUpperCase();
                return status === 'RESOLVED' || status === 'COMPLETED' || status === 'EXIT_STOP_LOSS' || status === 'EXIT_BREAK_EVEN';
            }).length;
            
            const activeToday = todaySignals.filter(s => {
                const status = (s.trade_status || s.status || '').toUpperCase();
                return status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
            }).length;

            document.getElementById('completedSignals').textContent = completedToday;
            document.getElementById('activeTrades').textContent = activeToday;

            // Calculate average BE=1 MFE
            const beMfeSignals = todaySignals.filter(s => s.be_mfe && s.be_mfe > 0);
            const avgBeMFE = beMfeSignals.length > 0 
                ? beMfeSignals.reduce((sum, s) => sum + s.be_mfe, 0) / beMfeSignals.length
                : 0;
            
            // Calculate average No BE MFE
            const noBeMfeSignals = todaySignals.filter(s => s.no_be_mfe && s.no_be_mfe > 0);
            const avgNoBeMFE = noBeMfeSignals.length > 0
                ? noBeMfeSignals.reduce((sum, s) => sum + s.no_be_mfe, 0) / noBeMfeSignals.length
                : 0;
            
            document.getElementById('avgBeMFE').textContent = avgBeMFE.toFixed(2) + 'R';
            document.getElementById('avgNoBeMFE').textContent = avgNoBeMFE.toFixed(2) + 'R';
        }

        function updateSignalsTable() {
            const tbody = document.getElementById('signalsTableBody');
            
            // Apply both date filter and status filter
            let filteredSignals = signals;
            
            // Date filter
            if (selectedDate) {
                filteredSignals = filteredSignals.filter(s => s.date === selectedDate);
            }
            
            // Status filter
            if (currentFilter !== 'all') {
                filteredSignals = filteredSignals.filter(s => {
                    const status = (s.trade_status || s.status || '').toUpperCase();
                    if (currentFilter === 'active') {
                        return status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
                    }
                    if (currentFilter === 'completed') {
                        return status === 'RESOLVED' || status === 'COMPLETED' || status === 'EXIT_STOP_LOSS' || status === 'EXIT_BREAK_EVEN';
                    }
                    return true;
                });
            }

            if (filteredSignals.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10">
                            <div class="empty-state">
                                <div class="empty-state-icon">üìä</div>
                                <div>No ${selectedDate ? 'signals for selected date' : currentFilter + ' signals'}</div>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = filteredSignals.slice(0, 50).map((signal, index) => {
                const direction = signal.bias || signal.direction;
                const status = (signal.trade_status || signal.status || 'unknown').toUpperCase();
                
                // Determine if trade is active
                const isActive = status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
                
                // Use the dual MFE values from API
                const be_mfe = signal.be_mfe || 0;
                const no_be_mfe = signal.no_be_mfe || 0;
                
                // Determine status dot
                let statusDot = '';
                if (isActive) {
                    // Green pulsating dot if both MFEs are active (no_be_mfe > be_mfe means BE hasn't stopped out)
                    // Blue dot if BE=1 has stopped out (be_mfe exists but no_be_mfe is still running)
                    const beStoppedOut = be_mfe > 0 && no_be_mfe > be_mfe;
                    const dotClass = beStoppedOut ? 'active-no-be' : 'active-both';
                    statusDot = `<span class="trade-status-dot ${dotClass}"></span>`;
                }
                
                const timestamp = signal.created_at || signal.timestamp;
                
                // Use exact time from TradingView (signal_time or time field)
                const displayTime = signal.signal_time || signal.time || (timestamp ? formatTime(timestamp) : '-');
                
                // Display status badge
                const statusBadgeClass = isActive ? 'active' : 'completed';
                const statusText = isActive ? 'Active' : 'Completed';
                
                return `
                    <tr class="clickable-row" onclick="showTradeDetail('${signal.trade_id}')">
                        <td>${statusDot}</td>
                        <td><span class="trade-number">${index + 1}</span></td>
                        <td>${displayTime}</td>
                        <td>
                            <span class="direction-badge ${direction ? direction.toLowerCase() : 'neutral'}">
                                ${direction || '-'}
                            </span>
                        </td>
                        <td>${signal.entry_price ? signal.entry_price.toFixed(2) : '-'}</td>
                        <td>${signal.stop_loss_price || signal.stop_loss ? (signal.stop_loss_price || signal.stop_loss).toFixed(2) : '-'}</td>
                        <td>${signal.session || '-'}</td>
                        <td><strong>${be_mfe > 0 ? be_mfe.toFixed(2) + 'R' : '-'}</strong></td>
                        <td><strong>${no_be_mfe > 0 ? no_be_mfe.toFixed(2) + 'R' : '-'}</strong></td>
                        <td>
                            <span class="status-badge ${statusBadgeClass}">
                                ${statusText}
                            </span>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updateSignalStatus(tradeId, newStatus) {
            const signal = signals.find(s => s.trade_id === tradeId);
            if (signal) {
                signal.status = newStatus;
                updateDashboard();
            }
        }

        // Activity Feed (removed from UI but keeping function for compatibility)
        function addActivityItem(message, data) {
            const feed = document.getElementById('activityFeed');
            
            // Activity Feed removed - function is now a no-op
            if (!feed) {
                return;
            }
            
            // Remove empty state if present
            const emptyState = feed.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            const item = document.createElement('div');
            item.className = 'activity-item new';
            item.innerHTML = `
                <div class="activity-time">${formatTime(new Date())}</div>
                <div class="activity-content">
                    <strong>${message}</strong> - 
                    ${data.direction} @ ${data.entry_price || data.current_price || 'N/A'}
                </div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 50 items
            while (feed.children.length > 50) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Filter Tabs
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.filter-tab').forEach(t => 
                    t.classList.remove('active')
                );
                tab.classList.add('active');
                currentFilter = tab.dataset.filter;
                updateSignalsTable();
            });
        });

        // Calendar Functions
        function updateCalendar() {
            const grid = document.getElementById('calendarGrid');
            const monthTitle = document.getElementById('monthTitle');
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthTitle.textContent = `${monthNames[currentMonth]} ${currentYear}`;
            
            // Get first day of month and number of days
            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();
            
            // Count trades by date
            const tradesByDate = {};
            const activeByDate = {};
            const statsByDate = {};
            
            signals.forEach(signal => {
                if (signal.date) {
                    const dateStr = signal.date;
                    
                    if (!tradesByDate[dateStr]) {
                        tradesByDate[dateStr] = 0;
                        activeByDate[dateStr] = 0;
                        statsByDate[dateStr] = { totalMFE: 0, count: 0 };
                    }
                    
                    tradesByDate[dateStr]++;
                    
                    // Track active trades
                    if (signal.trade_status === 'ACTIVE' || signal.trade_status === 'CONFIRMED') {
                        activeByDate[dateStr]++;
                    }
                    
                    // Calculate stats
                    const mfe = signal.final_mfe || signal.current_mfe || 0;
                    statsByDate[dateStr].totalMFE += mfe;
                    statsByDate[dateStr].count++;
                }
            });
            
            // Clear grid
            grid.innerHTML = '';
            
            // Add empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day empty';
                grid.appendChild(emptyDay);
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayElement = document.createElement('div');
                const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const tradeCount = tradesByDate[dateStr] || 0;
                const activeCount = activeByDate[dateStr] || 0;
                
                dayElement.className = 'calendar-day';
                
                if (tradeCount > 0) {
                    dayElement.classList.add('has-trades');
                }
                
                if (activeCount > 0) {
                    dayElement.classList.add('has-active');
                }
                
                if (selectedDate === dateStr) {
                    dayElement.classList.add('selected');
                }
                
                let statsHtml = '';
                if (tradeCount > 0) {
                    const stats = statsByDate[dateStr];
                    const avgMFE = stats.count > 0 ? (stats.totalMFE / stats.count).toFixed(2) : '0.00';
                    statsHtml = `<div class="day-stats">Avg: ${avgMFE}R</div>`;
                }
                
                let activeHtml = '';
                if (activeCount > 0) {
                    activeHtml = `<div class="day-active">üî¥ ${activeCount} Active</div>`;
                }
                
                dayElement.innerHTML = `
                    <div class="day-number">${day}</div>
                    <div class="day-data">
                        ${tradeCount > 0 ? `<div class="day-trades">${tradeCount} trades</div>` : ''}
                        ${activeHtml}
                        ${statsHtml}
                    </div>
                `;
                
                dayElement.onclick = () => filterDate(dateStr);
                grid.appendChild(dayElement);
            }
        }

        function changeMonth(direction) {
            currentMonth += direction;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            } else if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            updateCalendar();
        }

        function filterDate(dateStr) {
            if (selectedDate === dateStr) {
                selectedDate = null; // Clear filter
            } else {
                selectedDate = dateStr; // Set filter
            }
            updateDashboard();
            updateCalendar();
        }

        // Utility Functions
        function formatTime(timestamp) {
            // Convert timestamp to Eastern Time to match TradingView
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'America/New_York',
                hour12: false
            });
        }




        // Minimal Journey for trades with only ENTRY event
        function renderMinimalJourney(trade, entryEvent) {
            const container = d3.select('#journeyViz');
            const width = container.node().getBoundingClientRect().width;
            const height = 400;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const centerY = height / 2;
            const spacing = width / 4;
            
            // Define minimal journey: ENTRY -> Waiting for MFE -> Potential Outcomes
            const nodes = [
                { x: spacing, y: centerY, label: 'Entry', sublabel: trade.entry_price ? trade.entry_price.toFixed(2) : 'N/A', color: '#4ade80', icon: '‚ñ∂', status: 'completed' },
                { x: spacing * 2, y: centerY, label: 'Awaiting Updates', sublabel: 'No MFE data yet', color: '#fbbf24', icon: '‚è≥', status: 'current' },
                { x: spacing * 3, y: centerY, label: 'Potential Exit', sublabel: 'Stop or Target', color: '#94a3b8', icon: 'üèÅ', status: 'potential' }
            ];
            
            // Draw lines
            for (let i = 0; i < nodes.length - 1; i++) {
                const source = nodes[i];
                const target = nodes[i + 1];
                
                svg.append('path')
                    .attr('class', i === 0 ? 'journey-link completed' : 'journey-link potential')
                    .attr('d', `M ${source.x},${source.y} L ${target.x},${target.y}`);
            }
            
            // Draw nodes
            const nodeGroups = svg.selectAll('.journey-node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'journey-node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            nodeGroups.append('circle')
                .attr('class', d => d.status === 'current' ? 'node-circle current-indicator' : 'node-circle')
                .attr('r', d => d.status === 'current' ? 40 : 32)
                .attr('fill', d => d.color)
                .attr('opacity', d => d.status === 'potential' ? 0.3 : 0.9);
            
            nodeGroups.append('text')
                .attr('class', 'node-label')
                .attr('y', 6)
                .style('font-size', d => d.status === 'current' ? '24px' : '18px')
                .text(d => d.icon);
            
            nodeGroups.append('text')
                .attr('class', 'node-label')
                .attr('y', -50)
                .text(d => d.label);
            
            nodeGroups.append('text')
                .attr('class', 'node-value')
                .attr('y', 55)
                .text(d => d.sublabel);
            
            // Add note about missing data
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 30)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .attr('font-size', '12px')
                .text('‚ö†Ô∏è Waiting for MFE updates from TradingView indicator');
        }

        // Trade Journey Visualization with D3.js
        function renderPriceChartJourney(trade) {
    console.log('renderPriceChartJourney called with trade:', trade);
    
    const container = d3.select('#journeyViz');
    container.selectAll('*').remove();
    
    if (!trade || !trade.events || trade.events.length === 0) {
        container.append('div')
            .style('text-align', 'center')
            .style('padding', '40px')
            .style('color', '#94a3b8')
            .text('No event data available for visualization');
        return;
    }
    
    // Extract price data from events
    const direction = trade.direction;
    const entryPrice = trade.entry_price;
    const stopLoss = trade.stop_loss;
    const riskDistance = trade.risk_distance;
    
    // Calculate price levels
    const isBullish = direction === 'Bullish';
    const target1R = isBullish ? entryPrice + riskDistance : entryPrice - riskDistance;
    const target2R = isBullish ? entryPrice + (2 * riskDistance) : entryPrice - (2 * riskDistance);
    const target3R = isBullish ? entryPrice + (3 * riskDistance) : entryPrice - (3 * riskDistance);
    
    // Get MFE values from events
    const mfeEvents = trade.events.filter(e => e.event_type === 'MFE_UPDATE' || e.event_type === 'SIGNAL_CREATED');
    const maxMFE = Math.max(...trade.events.map(e => e.no_be_mfe || 0));
    const maxPrice = isBullish ? entryPrice + (maxMFE * riskDistance) : entryPrice - (maxMFE * riskDistance);
    
    // Determine price range for chart
    const priceMin = Math.min(stopLoss, entryPrice, maxPrice) - riskDistance;
    const priceMax = Math.max(stopLoss, entryPrice, maxPrice, target3R) + riskDistance;
    
    // Chart dimensions
    const margin = {top: 40, right: 80, bottom: 60, left: 80};
    const width = container.node().offsetWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;
    
    // Create SVG
    const svg = container.append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Scales
    const xScale = d3.scaleLinear()
        .domain([0, mfeEvents.length - 1])
        .range([0, width]);
    
    const yScale = d3.scaleLinear()
        .domain([priceMin, priceMax])
        .range([height, 0]);
    
    // Create price path data
    const priceData = mfeEvents.map((event, i) => {
        const mfe = event.no_be_mfe || 0;
        const price = isBullish ? entryPrice + (mfe * riskDistance) : entryPrice - (mfe * riskDistance);
        return {x: i, price: price, event: event};
    });
    
    // Draw background zones
    const zones = [
        {label: 'Stop Loss', price: stopLoss, color: '#ef4444', dash: '5,5'},
        {label: 'Entry', price: entryPrice, color: '#00d4ff', dash: 'none'},
        {label: '+1R', price: target1R, color: '#4ade80', dash: '3,3'},
        {label: '+2R', price: target2R, color: '#4ade80', dash: '3,3'},
        {label: '+3R', price: target3R, color: '#4ade80', dash: '3,3'}
    ];
    
    // Draw horizontal reference lines
    zones.forEach(zone => {
        svg.append('line')
            .attr('x1', 0)
            .attr('x2', width)
            .attr('y1', yScale(zone.price))
            .attr('y2', yScale(zone.price))
            .attr('stroke', zone.color)
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', zone.dash)
            .attr('opacity', 0.5);
        
        // Label
        svg.append('text')
            .attr('x', width + 10)
            .attr('y', yScale(zone.price))
            .attr('dy', '0.35em')
            .attr('fill', zone.color)
            .attr('font-size', '11px')
            .attr('font-weight', '600')
            .text(`${zone.label} (${zone.price.toFixed(2)})`);
    });
    
    // Draw price path
    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.price))
        .curve(d3.curveMonotoneX);
    
    // Price area fill
    const area = d3.area()
        .x(d => xScale(d.x))
        .y0(yScale(entryPrice))
        .y1(d => yScale(d.price))
        .curve(d3.curveMonotoneX);
    
    svg.append('path')
        .datum(priceData)
        .attr('fill', isBullish ? 'rgba(74, 222, 128, 0.1)' : 'rgba(239, 68, 68, 0.1)')
        .attr('d', area);
    
    // Price line
    svg.append('path')
        .datum(priceData)
        .attr('fill', 'none')
        .attr('stroke', isBullish ? '#4ade80' : '#ef4444')
        .attr('stroke-width', 3)
        .attr('d', line);
    
// Draw price points with different styles based on event type
    svg.selectAll('.price-point')
        .data(priceData)
        .enter()
        .append('g')
        .attr('class', 'price-point-group')
        .attr('transform', d => `translate(${xScale(d.x)},${yScale(d.price)})`)
        .each(function(d) {
            const group = d3.select(this);
            const eventType = d.event.event_type;
            
            // Different shapes for different event types
            if (eventType === 'SIGNAL_CREATED') {
                // Entry point - large star
                const starPath = d3.symbol().type(d3.symbolStar).size(200);
                group.append('path')
                    .attr('d', starPath)
                    .attr('fill', '#00d4ff')
                    .attr('stroke', '#0a0e27')
                    .attr('stroke-width', 2)
                    .attr('class', 'event-marker');
                
                // Label
                group.append('text')
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#00d4ff')
                    .attr('font-size', '10px')
                    .attr('font-weight', '700')
                    .text('ENTRY');
                    
            } else if (eventType === 'BE_TRIGGERED') {
                // BE trigger - diamond
                const diamondPath = d3.symbol().type(d3.symbolDiamond).size(150);
                group.append('path')
                    .attr('d', diamondPath)
                    .attr('fill', '#fbbf24')
                    .attr('stroke', '#0a0e27')
                    .attr('stroke-width', 2)
                    .attr('class', 'event-marker');
                
                // Label
                group.append('text')
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fbbf24')
                    .attr('font-size', '10px')
                    .attr('font-weight', '700')
                    .text('BE +1R');
                    
            } else if (eventType.startsWith('EXIT_')) {
                // Exit point - square
                const squarePath = d3.symbol().type(d3.symbolSquare).size(150);
                group.append('path')
                    .attr('d', squarePath)
                    .attr('fill', '#ef4444')
                    .attr('stroke', '#0a0e27')
                    .attr('stroke-width', 2)
                    .attr('class', 'event-marker');
                
                // Label
                group.append('text')
                    .attr('y', -15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#ef4444')
                    .attr('font-size', '10px')
                    .attr('font-weight', '700')
                    .text('EXIT');
                    
            } else {
                // MFE update - regular circle
                group.append('circle')
                    .attr('r', 5)
                    .attr('fill', isBullish ? '#4ade80' : '#ef4444')
                    .attr('stroke', '#0a0e27')
                    .attr('stroke-width', 2)
                    .attr('class', 'event-marker');
            }
            
            // Make interactive
            group.style('cursor', 'pointer')
                .on('mouseover', function(event) {
                    d3.select(this).select('.event-marker')
                        .transition()
                        .duration(200)
                        .attr('transform', 'scale(1.5)');
                    
                    // Show detailed tooltip
                    const tooltip = svg.append('g')
                        .attr('class', 'price-tooltip')
                        .attr('transform', `translate(${xScale(d.x)},${yScale(d.price) - 40})`);
                    
                    const tooltipText = [
                        `${d.event.event_type}`,
                        `Price: ${d.price.toFixed(2)}`,
                        `MFE: ${(d.event.no_be_mfe || 0).toFixed(2)}R`,
                        `Time: ${d.event.signal_time || 'N/A'}`
                    ];
                    
                    const textGroup = tooltip.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#e0e6ed')
                        .attr('font-size', '11px');
                    
                    tooltipText.forEach((line, i) => {
                        textGroup.append('tspan')
                            .attr('x', 0)
                            .attr('dy', i === 0 ? 0 : 14)
                            .attr('font-weight', i === 0 ? '700' : '400')
                            .text(line);
                    });
                    
                    const bbox = textGroup.node().getBBox();
                    tooltip.insert('rect', 'text')
                        .attr('x', bbox.x - 8)
                        .attr('y', bbox.y - 4)
                        .attr('width', bbox.width + 16)
                        .attr('height', bbox.height + 8)
                        .attr('fill', 'rgba(0, 0, 0, 0.9)')
                        .attr('rx', 6)
                        .attr('stroke', '#00d4ff')
                        .attr('stroke-width', 1);
                })
                .on('mouseout', function() {
                    d3.select(this).select('.event-marker')
                        .transition()
                        .duration(200)
                        .attr('transform', 'scale(1)');
                    
                    svg.selectAll('.price-tooltip').remove();
                });
        });
    
    // Add axes
    const xAxis = d3.axisBottom(xScale)
        .ticks(Math.min(mfeEvents.length, 10))
        .tickFormat(d => `Event ${Math.floor(d) + 1}`);
    
    const yAxis = d3.axisLeft(yScale)
        .ticks(8)
        .tickFormat(d => d.toFixed(2));
    
    svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(xAxis)
        .attr('color', '#94a3b8')
        .selectAll('text')
        .attr('font-size', '10px');
    
    svg.append('g')
        .call(yAxis)
        .attr('color', '#94a3b8')
        .selectAll('text')
        .attr('font-size', '10px');
    
    // Chart title
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', -20)
        .attr('text-anchor', 'middle')
        .attr('fill', '#00d4ff')
        .attr('font-size', '14px')
        .attr('font-weight', '600')
        .text(`${direction} Trade Price Journey - Max MFE: ${maxMFE.toFixed(2)}R`);
    
    // Status indicator
    const isActive = !trade.events[trade.events.length - 1].event_type.startsWith('EXIT_');
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', -5)
        .attr('text-anchor', 'middle')
        .attr('fill', isActive ? '#4ade80' : '#8b5cf6')
        .attr('font-size', '12px')
        .text(isActive ? '‚óè ACTIVE' : '‚óè COMPLETED');
}
            
            // Clear existing visualization
            d3.select('#journeyViz').selectAll('*').remove();
            
            const events = trade.events || [];
            
            // If no events, show message
            if (events.length === 0) {
                console.warn('No events found for trade');
                document.getElementById('journeyViz').innerHTML = '<div style="color: #fbbf24; text-align: center; padding: 40px;">No event data available for this trade</div>';
                return;
            }
            
            // If only ENTRY event, create a minimal journey showing current state
            if (events.length === 1 && events[0].event_type === 'ENTRY') {
                console.log('Only ENTRY event found, creating minimal journey');
                renderMinimalJourney(trade, events[0]);
                return;
            }
            
            const latestEvent = events[events.length - 1];
            const isActive = !latestEvent.event_type.startsWith('EXIT_');
            
            console.log(`Trade has ${events.length} events, isActive: ${isActive}`);
            
            // Build journey path based on actual events
            const journeyPath = [];
            const eventsByType = {};
            
            events.forEach(event => {
                if (!eventsByType[event.event_type]) {
                    eventsByType[event.event_type] = [];
                }
                eventsByType[event.event_type].push(event);
            });
            
            // Add ENTRY
            if (eventsByType['ENTRY']) {
                journeyPath.push({
                    stage: 'ENTRY',
                    event: eventsByType['ENTRY'][0],
                    status: 'completed',
                    label: 'Entry',
                    color: '#4ade80',
                    icon: '‚ñ∂'
                });
            }
            
            // Add MFE_UPDATE nodes (show first, peak, and latest)
            if (eventsByType['MFE_UPDATE']) {
                const mfeEvents = eventsByType['MFE_UPDATE'];
                
                // Find peak MFE
                let peakMfe = mfeEvents[0];
                mfeEvents.forEach(e => {
                    if ((e.no_be_mfe || 0) > (peakMfe.no_be_mfe || 0)) {
                        peakMfe = e;
                    }
                });
                
                // Add first MFE
                journeyPath.push({
                    stage: 'MFE_UPDATE',
                    event: mfeEvents[0],
                    status: 'completed',
                    label: 'First MFE',
                    sublabel: `${(mfeEvents[0].no_be_mfe || 0).toFixed(2)}R`,
                    color: '#00d4ff',
                    icon: 'üìä'
                });
                
                // Add peak MFE if different
                if (peakMfe !== mfeEvents[0] && peakMfe !== mfeEvents[mfeEvents.length - 1]) {
                    journeyPath.push({
                        stage: 'MFE_UPDATE',
                        event: peakMfe,
                        status: 'completed',
                        label: 'Peak MFE',
                        sublabel: `${(peakMfe.no_be_mfe || 0).toFixed(2)}R`,
                        color: '#10b981',
                        icon: 'üéØ'
                    });
                }
                
                // Add latest MFE if active
                if (isActive && mfeEvents.length > 1) {
                    journeyPath.push({
                        stage: 'MFE_UPDATE',
                        event: mfeEvents[mfeEvents.length - 1],
                        status: 'current',
                        label: 'Current MFE',
                        sublabel: `${(mfeEvents[mfeEvents.length - 1].no_be_mfe || 0).toFixed(2)}R`,
                        color: '#00d4ff',
                        icon: 'üìà'
                    });
                }
            }
            
            // Add BE_TRIGGERED if exists
            if (eventsByType['BE_TRIGGERED']) {
                journeyPath.push({
                    stage: 'BE_TRIGGERED',
                    event: eventsByType['BE_TRIGGERED'][0],
                    status: 'completed',
                    label: 'Break Even',
                    sublabel: '+1R Achieved',
                    color: '#fbbf24',
                    icon: '‚ö°'
                });
            }
            
            // Add EXIT if exists
            if (eventsByType['EXIT_STOP_LOSS']) {
                journeyPath.push({
                    stage: 'EXIT_STOP_LOSS',
                    event: eventsByType['EXIT_STOP_LOSS'][0],
                    status: 'completed',
                    label: 'Stop Loss Hit',
                    sublabel: `Final: ${(eventsByType['EXIT_STOP_LOSS'][0].no_be_mfe || 0).toFixed(2)}R`,
                    color: '#ef4444',
                    icon: 'üõë'
                });
            } else if (eventsByType['EXIT_BREAK_EVEN']) {
                journeyPath.push({
                    stage: 'EXIT_BREAK_EVEN',
                    event: eventsByType['EXIT_BREAK_EVEN'][0],
                    status: 'completed',
                    label: 'BE Exit',
                    sublabel: `Final: ${(eventsByType['EXIT_BREAK_EVEN'][0].be_mfe || 0).toFixed(2)}R`,
                    color: '#8b5cf6',
                    icon: '‚Ü©'
                });
            }
            
            // Add potential next states if active
            if (isActive) {
                if (!eventsByType['BE_TRIGGERED']) {
                    journeyPath.push({
                        stage: 'BE_TRIGGERED',
                        status: 'potential',
                        label: 'Potential BE',
                        sublabel: 'If +1R reached',
                        color: '#94a3b8',
                        icon: '‚ö°'
                    });
                }
                
                journeyPath.push({
                    stage: 'EXIT',
                    status: 'potential',
                    label: 'Potential Exit',
                    sublabel: 'Stop or Target',
                    color: '#94a3b8',
                    icon: 'üèÅ'
                });
            }
            
            // Set up SVG
            const container = d3.select('#journeyViz');
            const width = container.node().getBoundingClientRect().width;
            const height = 400;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Calculate positions
            const nodeSpacing = width / (journeyPath.length + 1);
            const centerY = height / 2;
            
            journeyPath.forEach((node, i) => {
                node.x = nodeSpacing * (i + 1);
                node.y = centerY;
            });
            
            // Draw connecting lines
            for (let i = 0; i < journeyPath.length - 1; i++) {
                const source = journeyPath[i];
                const target = journeyPath[i + 1];
                
                let linkClass = 'journey-link ';
                if (source.status === 'completed' && target.status === 'completed') {
                    linkClass += 'completed';
                } else if (source.status === 'current' || target.status === 'current') {
                    linkClass += 'active';
                } else {
                    linkClass += 'potential';
                }
                
                svg.append('path')
                    .attr('class', linkClass)
                    .attr('d', `M ${source.x},${source.y} L ${target.x},${target.y}`);
            }
            
            // Draw nodes
            const nodes = svg.selectAll('.journey-node')
                .data(journeyPath)
                .enter()
                .append('g')
                .attr('class', 'journey-node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            // Node circles
            nodes.append('circle')
                .attr('class', d => d.status === 'current' ? 'node-circle current-indicator' : 'node-circle')
                .attr('r', d => d.status === 'current' ? 40 : d.status === 'potential' ? 28 : 32)
                .attr('fill', d => d.color)
                .attr('opacity', d => d.status === 'potential' ? 0.3 : 0.9);
            
            // Node icons
            nodes.append('text')
                .attr('class', 'node-label')
                .attr('y', 6)
                .style('font-size', d => d.status === 'current' ? '24px' : '18px')
                .text(d => d.icon);
            
            // Node labels
            nodes.append('text')
                .attr('class', 'node-label')
                .attr('y', -50)
                .text(d => d.label);
            
            // Node sublabels (MFE values, etc.)
            nodes.filter(d => d.sublabel)
                .append('text')
                .attr('class', 'node-value')
                .attr('y', 55)
                .text(d => d.sublabel);
            
            // Node times
            nodes.filter(d => d.event)
                .append('text')
                .attr('class', 'node-time')
                .attr('y', 72)
                .text(d => {
                    if (d.event.signal_time) {
                        const time = d.event.signal_time.split('T')[1];
                        return time ? time.substring(0, 8) : '';
                    }
                    return '';
                });
        }


        // Trade Detail Modal Functions
        async function showTradeDetail(tradeId) {
            const modal = document.getElementById('tradeDetailModal');
            const body = document.getElementById('tradeDetailBody');
            
            body.innerHTML = '<div style="text-align: center; padding: 40px; color: #00d4ff;">Loading trade details...</div>';
            modal.style.display = 'block';
            
            try {
                const response = await fetch(`/api/automated-signals/trade-detail/${tradeId}`);
                const data = await response.json();
                
                if (data.success) {
                    renderTradeDetail(data.trade);
                } else {
                    body.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Error: ${data.error}</div>`;
                }
            } catch (error) {
                console.error('Error loading trade detail:', error);
                body.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Error loading trade details</div>`;
            }
        }

        function renderTradeDetail(trade) {
            const body = document.getElementById('tradeDetailBody');
            
            // Determine current status from latest event
            const latestEvent = trade.events[trade.events.length - 1];
            const isActive = !latestEvent.event_type.startsWith('EXIT_');
            const statusText = isActive ? 'ACTIVE' : 'COMPLETED';
            const statusColor = isActive ? '#4ade80' : '#8b5cf6';
            
            body.innerHTML = `
                <div class="journey-container">
                    <div class="journey-title">üìç Trade Journey Map</div>
                    <div id="journeyViz"></div>
                    <div class="journey-legend">
                        <div class="legend-item">
                            <div class="legend-line completed"></div>
                            <span>Completed</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line active"></div>
                            <span>Current</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line potential"></div>
                            <span>Potential Next</span>
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Trade Summary</h3>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="detail-label">Trade ID</div>
                            <div class="detail-value">${trade.trade_id}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Current Status</div>
                            <div class="detail-value" style="color: ${statusColor}">${statusText}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Latest Event</div>
                            <div class="detail-value">${latestEvent.event_type}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Direction</div>
                            <div class="detail-value">${trade.direction}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Session</div>
                            <div class="detail-value">${trade.session || 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Entry Price</div>
                            <div class="detail-value">${trade.entry_price ? trade.entry_price.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Stop Loss</div>
                            <div class="detail-value">${trade.stop_loss ? trade.stop_loss.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Risk Distance</div>
                            <div class="detail-value">${trade.risk_distance ? trade.risk_distance.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">BE=1 MFE</div>
                            <div class="detail-value">${trade.be_mfe ? trade.be_mfe.toFixed(2) + 'R' : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">No BE MFE</div>
                            <div class="detail-value">${trade.no_be_mfe ? trade.no_be_mfe.toFixed(2) + 'R' : 'N/A'}</div>
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Event Timeline (${trade.events.length} events)</h3>
                    <div class="event-timeline">
                        ${trade.events.map(event => `
                            <div class="event-item">
                                <div class="event-header">
                                    <span class="event-type">${event.event_type}</span>
                                    <span class="event-time">${event.signal_time || formatTime(event.timestamp)}</span>
                                </div>
                                <div class="event-details">
                                    ${event.be_mfe !== null && event.be_mfe !== undefined ? `<div class="event-detail">BE MFE: <strong>${event.be_mfe.toFixed(2)}R</strong></div>` : ''}
                                    ${event.no_be_mfe !== null && event.no_be_mfe !== undefined ? `<div class="event-detail">No BE MFE: <strong>${event.no_be_mfe.toFixed(2)}R</strong></div>` : ''}
                                    ${event.entry_price ? `<div class="event-detail">Entry: <strong>${event.entry_price.toFixed(2)}</strong></div>` : ''}
                                    ${event.stop_loss ? `<div class="event-detail">Stop: <strong>${event.stop_loss.toFixed(2)}</strong></div>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Latest Alert Payload</h3>
                    <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; color: #e0e6ed; overflow-x: auto;">
                        <pre>${JSON.stringify(latestEvent, null, 2)}</pre>
                    </div>
                </div>
            `;
            
            // Render the journey visualization after DOM is updated
            setTimeout(() => renderPriceChartJourney(trade), 100);
        }

        function closeTradeDetail() {
            document.getElementById('tradeDetailModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('tradeDetailModal');
            if (event.target == modal) {
                closeTradeDetail();
            }
        }


        // Initialize
        loadInitialData();
    </script>

<!-- Trade Detail Modal -->
<div id="tradeDetailModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Trade Details</h2>
            <span class="close-modal" onclick="closeTradeDetail()">&times;</span>
        </div>
        <div class="modal-body" id="tradeDetailBody">
            <!-- Populated by JavaScript -->
        </div>
    </div>
</div>

</body>
</html>


<!-- Calendar implementation complete - ready for deployment -->
