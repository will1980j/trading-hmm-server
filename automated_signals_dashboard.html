 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Signals Dashboard | Trading Platform</title>
    <!-- D3.js for journey visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        
    
        
    
        
    
        /* Navigation */
        .nav-container {
            background: #141b3d;
            padding: 12px 20px;
            border-bottom: 1px solid #2d3a5f;
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            overflow-x: auto;
        }

        .nav-link {
            padding: 8px 12px;
            background: #1a2142;
            color: #f8fafc;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background: #3b82f6;
            transform: translateY(-2px);
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- Navigation -->
        <!-- Navigation -->
    <nav class="nav-container">
        <a href="/homepage" class="nav-link">üè† Home</a>
        <a href="/ml-dashboard" class="nav-link">ü§ñ ML</a>
        <a href="/signal-lab-dashboard" class="nav-link">üìä Dashboard</a>
        <a href="/signal-analysis-lab" class="nav-link">üß™ Signal Lab</a>
        <a href="/automated-signals" class="nav-link">üì° Automated Signals</a>
        <a href="/time-analysis" class="nav-link">‚è∞ Time</a>
        <a href="/strategy-optimizer" class="nav-link">üéØ Optimizer</a>
        <a href="/strategy-comparison" class="nav-link">üèÜ Compare</a>
        <a href="/ai-business-advisor" class="nav-link">üß† AI Advisor</a>
        <a href="/prop-portfolio" class="nav-link">üíº Prop</a>
        <a href="/trade-manager" class="nav-link">üìã Trades</a>
        <a href="/financial-summary" class="nav-link">üí∞ Finance</a>
        <a href="/reporting-hub" class="nav-link">üìä Reports</a>
    </nav>

<script>
let healthData = null;
let healthDetailsExpanded = false;

// Load health status on page load
document.addEventListener('DOMContentLoaded', function() {
    refreshHealth();
    // Auto-refresh every 60 seconds
    setInterval(refreshHealth, 60000);
});

async function refreshHealth() {
    try {
        const response = await fetch('/api/system-health');
        healthData = await response.json();
        updateHealthDisplay();
    } catch (error) {
        console.error('Health check failed:', error);
        showHealthError();
    }
}

function updateHealthDisplay() {
    if (!healthData) return;
    
    // Update overall status pulse
    const pulse = document.getElementById('healthPulse');
    pulse.className = `health-pulse ${healthData.overall_status}`;
    
    // Update components
    const componentsDiv = document.getElementById('healthComponents');
    componentsDiv.innerHTML = '';
    
    const components = healthData.components;
    
    // Database
    if (components.database) {
        const queryTime = components.database.query_time_ms || 0;
        componentsDiv.appendChild(createComponentBadge(
            'Database',
            components.database.status || 'unknown',
            `${queryTime}ms`
        ));
    }
    
    // Webhook
    if (components.webhook) {
        const lastWebhook = components.webhook.last_webhook_seconds_ago;
        const webhookValue = (lastWebhook !== null && lastWebhook !== undefined) ? 
                            `${lastWebhook}s ago` : 'No data';
        componentsDiv.appendChild(createComponentBadge(
            'Webhooks',
            components.webhook.status || 'unknown',
            webhookValue
        ));
    }
    
    // Events
    if (components.events) {
        const mfeCoverage = components.events.mfe_coverage_percent || 0;
        componentsDiv.appendChild(createComponentBadge(
            'Events',
            components.events.status || 'unknown',
            `${mfeCoverage}% MFE`
        ));
    }
    
    // Freshness
    if (components.freshness) {
        const mfeAge = components.freshness.last_mfe_seconds_ago;
        const freshnessValue = (mfeAge !== null && mfeAge !== undefined) ? 
                              `${Math.floor(mfeAge/60)}m old` : 'No data';
        componentsDiv.appendChild(createComponentBadge(
            'Data',
            components.freshness.status || 'unknown',
            freshnessValue
        ));
    }
    
    // API
    if (components.api) {
        componentsDiv.appendChild(createComponentBadge(
            'API',
            components.api.status,
            `${components.api.response_time_ms}ms`
        ));
    }
    
    // Signal Integrity
    if (components.integrity) {
        const integrityMsg = components.integrity.message || 
                            `${components.integrity.signals_verified} signals`;
        componentsDiv.appendChild(createComponentBadge(
            'Integrity',
            components.integrity.status,
            integrityMsg
        ));
    }
    
    // Update timestamp
    const timestamp = new Date(healthData.timestamp).toLocaleTimeString();
    document.getElementById('healthTimestamp').textContent = `Last check: ${timestamp}`;
    
    // Update details if expanded
    if (healthDetailsExpanded) {
        updateHealthDetails();
    }
}

function createComponentBadge(label, status, value) {
    const div = document.createElement('div');
    div.className = 'health-component';
    div.onclick = () => {
        if (!healthDetailsExpanded) {
            toggleHealthDetails();
        }
    };
    
    div.innerHTML = `
        <div class="health-dot ${status}"></div>
        <div>
            <div class="health-label">${label}</div>
            <div class="health-value">${value}</div>
        </div>
    `;
    
    return div;
}

function toggleHealthDetails() {
    healthDetailsExpanded = !healthDetailsExpanded;
    const detailsDiv = document.getElementById('healthDetails');
    
    if (healthDetailsExpanded) {
        detailsDiv.classList.add('expanded');
        updateHealthDetails();
    } else {
        detailsDiv.classList.remove('expanded');
    }
}

function updateHealthDetails() {
    if (!healthData || !healthData.components) return;
    
    const grid = document.getElementById('healthDetailsGrid');
    grid.innerHTML = '';
    
    const components = healthData.components;
    
    // Database details
    if (components.database) {
        grid.appendChild(createDetailCard('Database', components.database, [
            { label: 'Connected', value: components.database.connected ? 'Yes' : 'No' },
            { label: 'Table Exists', value: components.database.table_exists ? 'Yes' : 'No' },
            { label: 'Row Count', value: components.database.row_count },
            { label: 'Query Time', value: `${components.database.query_time_ms}ms` },
            { label: 'Columns OK', value: components.database.columns_ok ? 'Yes' : 'No' }
        ]));
    }
    
    // Webhook details
    if (components.webhook) {
        const eventTypes = components.webhook.event_types || {};
        grid.appendChild(createDetailCard('Webhooks', components.webhook, [
            { label: 'Last Webhook', value: `${components.webhook.last_webhook_seconds_ago}s ago` },
            { label: 'Last Hour', value: components.webhook.webhooks_last_hour },
            { label: 'ENTRY Events', value: eventTypes.ENTRY || 0 },
            { label: 'MFE Updates', value: eventTypes.MFE_UPDATE || 0 },
            { label: 'BE Triggered', value: eventTypes.BE_TRIGGERED || 0 },
            { label: 'EXIT Events', value: (eventTypes.EXIT_STOP_LOSS || 0) + (eventTypes.EXIT_BREAK_EVEN || 0) }
        ]));
    }
    
    // Event flow details
    if (components.events) {
        grid.appendChild(createDetailCard('Event Flow', components.events, [
            { label: 'Active Trades', value: components.events.active_trades },
            { label: 'With MFE', value: components.events.trades_with_mfe },
            { label: 'MFE Coverage', value: `${components.events.mfe_coverage_percent}%` },
            { label: 'Completed Today', value: components.events.completed_today }
        ]));
    }
    
    // Data freshness details
    if (components.freshness) {
        grid.appendChild(createDetailCard('Data Freshness', components.freshness, [
            { label: 'Last MFE Update', value: `${components.freshness.last_mfe_seconds_ago}s ago` },
            { label: 'Last Entry', value: `${components.freshness.last_entry_seconds_ago}s ago` }
        ]));
    }
    
    // API details
    if (components.api) {
        grid.appendChild(createDetailCard('API Performance', components.api, [
            { label: 'Response Time', value: `${components.api.response_time_ms}ms` },
            { label: 'Status Code', value: components.api.status_code }
        ]));
    }
    
    // Signal Integrity details
    if (components.integrity) {
        const metrics = [
            { label: 'Signals Verified', value: components.integrity.signals_verified || 0 },
            { label: 'Errors Found', value: components.integrity.errors_found || 0 },
            { label: 'Warnings Found', value: components.integrity.warnings_found || 0 }
        ];
        
        // Add message if present
        if (components.integrity.message) {
            metrics.push({ label: 'Status', value: components.integrity.message });
        }
        
        grid.appendChild(createDetailCard('Signal Integrity', components.integrity, metrics));
    }
}

function createDetailCard(title, data, metrics) {
    const card = document.createElement('div');
    card.className = 'health-detail-card';
    
    let metricsHTML = metrics.map(m => `
        <div class="health-metric">
            <span class="health-metric-label">${m.label}:</span>
            <span class="health-metric-value">${m.value}</span>
        </div>
    `).join('');
    
    let issuesHTML = '';
    if (data.issues && data.issues.length > 0) {
        issuesHTML = `
            <div class="health-issues">
                ${data.issues.map(issue => `<div class="health-issue">${issue}</div>`).join('')}
            </div>
        `;
    }
    
    card.innerHTML = `
        <div class="health-detail-header">
            <div class="health-detail-title">${title}</div>
            <div class="health-detail-status ${data.status}">${data.status}</div>
        </div>
        <div class="health-detail-metrics">
            ${metricsHTML}
        </div>
        ${issuesHTML}
    `;
    
    return card;
}

function showHealthError() {
    const pulse = document.getElementById('healthPulse');
    pulse.className = 'health-pulse critical';
    
    const componentsDiv = document.getElementById('healthComponents');
    componentsDiv.innerHTML = '<div style="color: #ff3366; font-size: 12px;">Health check failed</div>';
}
</script>
<div class="dashboard-container">
        <!-- Header -->
        

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Completed Signals Today</div>
                <div class="stat-value" id="completedSignals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Current Active Trades</div>
                <div class="stat-value positive" id="activeTrades">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg BE=1 MFE</div>
                <div class="stat-value" id="avgBeMFE">0.00R</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg No BE MFE</div>
                <div class="stat-value" id="avgNoBeMFE">0.00R</div>
            </div>
        </div>

        <!-- Calendar Section -->
        <div class="signals-panel" style="margin-bottom: 20px;">
            <div class="panel-header">
                <h2 class="panel-title">Trading Calendar</h2>
                <div class="month-nav">
                    <button onclick="changeMonth(-1)">‚Üê Previous</button>
                    <span class="month-title" id="monthTitle"></span>
                    <button onclick="changeMonth(1)">Next ‚Üí</button>
                </div>
            </div>
            <div class="calendar-header">
                <div class="calendar-header-day">Sun</div>
                <div class="calendar-header-day">Mon</div>
                <div class="calendar-header-day">Tue</div>
                <div class="calendar-header-day">Wed</div>
                <div class="calendar-header-day">Thu</div>
                <div class="calendar-header-day">Fri</div>
                <div class="calendar-header-day">Sat</div>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar days will be generated by JavaScript -->
            </div>
        </div>

        <!-- Main Content -->
        <div class="content-grid">
            <!-- Signals Table -->
            <div class="signals-panel">
                <div class="panel-header">
                    <h2 class="panel-title">Live Signals</h2>
                    <div class="filter-tabs">
                        <div class="filter-tab active" data-filter="all">All</div>
                        <div class="filter-tab" data-filter="active">Active</div>
                        <div class="filter-tab" data-filter="completed">Completed</div>
                    </div>
                </div>
                <div id="signalsTableContainer">
                    <div style="margin-bottom: 10px; display: flex; justify-content: flex-end;">
                        <button id="bulkDeleteBtn" onclick="bulkDeleteTrades()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; display: none;">
                            Delete Selected (0)
                        </button>
                    </div>
                    <table class="signals-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" style="cursor: pointer;">
                                </th>
                                <th>Status</th>
                                <th>#</th>
                                <th>Time</th>
                                <th>Direction</th>
                                <th>Entry</th>
                                <th>Stop Loss</th>
                                <th>Session</th>
                                <th>BE=1 MFE</th>
                                <th>No BE MFE</th>
                                <th>Trade Status</th>
                            </tr>
                        </thead>
                        <tbody id="signalsTableBody">
                            <tr>
                                <td colspan="7">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">üìä</div>
                                        <div>Waiting for automated signals...</div>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocket Connection
        const socket = io();
        let signals = [];
        let currentFilter = 'all';
        let selectedDate = null;
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();

        // Connection Status
        socket.on('connect', () => {
            updateConnectionStatus(true);
            loadInitialData();
        });

        socket.on('disconnect', () => {
            updateConnectionStatus(false);
        });

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (connected) {
                dot.classList.remove('disconnected');
                text.textContent = 'Connected';
            } else {
                dot.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }

        // Load Initial Data
        async function loadInitialData() {
            try {
                const response = await fetch('/api/automated-signals/dashboard-data');
                const data = await response.json();
                
                if (data.success) {
                    // Combine active and completed trades
                    signals = [...(data.active_trades || []), ...(data.completed_trades || [])];
                    updateDashboard();
                    updateCalendar();
                }
            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        }

        // Listen for New Signals
        socket.on('new_automated_signal', (data) => {
            signals.unshift(data);
            updateDashboard();
            addActivityItem('New signal received', data);
        });

        socket.on('signal_confirmed', (data) => {
            updateSignalStatus(data.trade_id, 'confirmed');
            addActivityItem('Signal confirmed', data);
        });

        socket.on('signal_resolved', (data) => {
            updateSignalStatus(data.trade_id, 'resolved');
            addActivityItem('Trade resolved', data);
        });

        // Update Dashboard
        function updateDashboard() {
            updateStats();
            updateSignalsTable();
        }

        function updateStats() {
            const today = new Date().toDateString();
            const todaySignals = signals.filter(s => 
                new Date(s.timestamp || s.created_at).toDateString() === today
            );

            // Count completed and active trades
            const completedToday = todaySignals.filter(s => {
                const status = (s.trade_status || s.status || '').toUpperCase();
                return status === 'RESOLVED' || status === 'COMPLETED' || status === 'EXIT_STOP_LOSS' || status === 'EXIT_BREAK_EVEN';
            }).length;
            
            const activeToday = todaySignals.filter(s => {
                const status = (s.trade_status || s.status || '').toUpperCase();
                return status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
            }).length;

            document.getElementById('completedSignals').textContent = completedToday;
            document.getElementById('activeTrades').textContent = activeToday;

            // Calculate average BE=1 MFE
            const beMfeSignals = todaySignals.filter(s => s.be_mfe && s.be_mfe > 0);
            const avgBeMFE = beMfeSignals.length > 0 
                ? beMfeSignals.reduce((sum, s) => sum + s.be_mfe, 0) / beMfeSignals.length
                : 0;
            
            // Calculate average No BE MFE
            const noBeMfeSignals = todaySignals.filter(s => s.no_be_mfe && s.no_be_mfe > 0);
            const avgNoBeMFE = noBeMfeSignals.length > 0
                ? noBeMfeSignals.reduce((sum, s) => sum + s.no_be_mfe, 0) / noBeMfeSignals.length
                : 0;
            
            document.getElementById('avgBeMFE').textContent = avgBeMFE.toFixed(2) + 'R';
            document.getElementById('avgNoBeMFE').textContent = avgNoBeMFE.toFixed(2) + 'R';
        }

        function updateSignalsTable() {
            const tbody = document.getElementById('signalsTableBody');
            
            // Apply both date filter and status filter
            let filteredSignals = signals;
            
            // Date filter
            if (selectedDate) {
                filteredSignals = filteredSignals.filter(s => s.date === selectedDate);
            }
            
            // Status filter
            if (currentFilter !== 'all') {
                filteredSignals = filteredSignals.filter(s => {
                    const status = (s.trade_status || s.status || '').toUpperCase();
                    if (currentFilter === 'active') {
                        return status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
                    }
                    if (currentFilter === 'completed') {
                        return status === 'RESOLVED' || status === 'COMPLETED' || status === 'EXIT_STOP_LOSS' || status === 'EXIT_BREAK_EVEN';
                    }
                    return true;
                });
            }

            if (filteredSignals.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10">
                            <div class="empty-state">
                                <div class="empty-state-icon">üìä</div>
                                <div>No ${selectedDate ? 'signals for selected date' : currentFilter + ' signals'}</div>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = filteredSignals.slice(0, 50).map((signal, index) => {
                const direction = signal.bias || signal.direction;
                const status = (signal.trade_status || signal.status || 'unknown').toUpperCase();
                
                // Determine if trade is active
                const isActive = status === 'ACTIVE' || status === 'CONFIRMED' || status === 'ENTRY';
                
                // Use the dual MFE values from API
                const be_mfe = signal.be_mfe || 0;
                const no_be_mfe = signal.no_be_mfe || 0;
                
                // Determine status dot
                let statusDot = '';
                if (isActive) {
                    // Green pulsating dot if both MFEs are active (no_be_mfe > be_mfe means BE hasn't stopped out)
                    // Blue dot if BE=1 has stopped out (be_mfe exists but no_be_mfe is still running)
                    const beStoppedOut = be_mfe > 0 && no_be_mfe > be_mfe;
                    const dotClass = beStoppedOut ? 'active-no-be' : 'active-both';
                    statusDot = `<span class="trade-status-dot ${dotClass}"></span>`;
                }
                
                const timestamp = signal.created_at || signal.timestamp;
                
                // Use exact time from TradingView (signal_time or time field)
                const displayTime = signal.signal_time || signal.time || (timestamp ? formatTime(timestamp) : '-');
                
                // Display status badge
                const statusBadgeClass = isActive ? 'active' : 'completed';
                const statusText = isActive ? 'Active' : 'Completed';
                
                return `
                    <tr class="signal-row">
                        <td onclick="event.stopPropagation()">
                            <input type="checkbox" class="trade-checkbox" data-trade-id="${signal.trade_id}" onchange="toggleTradeSelection('${signal.trade_id}')" style="cursor: pointer;">
                        </td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">${statusDot}</td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;"><span class="trade-number">${index + 1}</span></td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">${displayTime}</td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">
                            <span class="direction-badge ${direction ? direction.toLowerCase() : 'neutral'}">
                                ${direction || '-'}
                            </span>
                        </td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">${signal.entry_price ? signal.entry_price.toFixed(2) : '-'}</td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">${signal.stop_loss_price || signal.stop_loss ? (signal.stop_loss_price || signal.stop_loss).toFixed(2) : '-'}</td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">${signal.session || '-'}</td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;"><strong>${be_mfe > 0 ? be_mfe.toFixed(2) + 'R' : '-'}</strong></td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;"><strong>${no_be_mfe > 0 ? no_be_mfe.toFixed(2) + 'R' : '-'}</strong></td>
                        <td onclick="showTradeDetail('${signal.trade_id}')" style="cursor: pointer;">
                            <span class="status-badge ${statusBadgeClass}">
                                ${statusText}
                            </span>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updateSignalStatus(tradeId, newStatus) {
            const signal = signals.find(s => s.trade_id === tradeId);
            if (signal) {
                signal.status = newStatus;
                updateDashboard();
            }
        }

        // Activity Feed (removed from UI but keeping function for compatibility)
        function addActivityItem(message, data) {
            const feed = document.getElementById('activityFeed');
            
            // Activity Feed removed - function is now a no-op
            if (!feed) {
                return;
            }
            
            // Remove empty state if present
            const emptyState = feed.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            const item = document.createElement('div');
            item.className = 'activity-item new';
            item.innerHTML = `
                <div class="activity-time">${formatTime(new Date())}</div>
                <div class="activity-content">
                    <strong>${message}</strong> - 
                    ${data.direction} @ ${data.entry_price || data.current_price || 'N/A'}
                </div>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Keep only last 50 items
            while (feed.children.length > 50) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Filter Tabs
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.filter-tab').forEach(t => 
                    t.classList.remove('active')
                );
                tab.classList.add('active');
                currentFilter = tab.dataset.filter;
                updateSignalsTable();
            });
        });

        // Calendar Functions
        function updateCalendar() {
            const grid = document.getElementById('calendarGrid');
            const monthTitle = document.getElementById('monthTitle');
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthTitle.textContent = `${monthNames[currentMonth]} ${currentYear}`;
            
            // Get first day of month and number of days
            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();
            
            // Count trades by date
            const tradesByDate = {};
            const activeByDate = {};
            const statsByDate = {};
            
            signals.forEach(signal => {
                if (signal.date) {
                    const dateStr = signal.date;
                    
                    if (!tradesByDate[dateStr]) {
                        tradesByDate[dateStr] = 0;
                        activeByDate[dateStr] = 0;
                        statsByDate[dateStr] = { totalMFE: 0, count: 0 };
                    }
                    
                    tradesByDate[dateStr]++;
                    
                    // Track active trades
                    if (signal.trade_status === 'ACTIVE' || signal.trade_status === 'CONFIRMED') {
                        activeByDate[dateStr]++;
                    }
                    
                    // Calculate stats
                    const mfe = signal.final_mfe || signal.current_mfe || 0;
                    statsByDate[dateStr].totalMFE += mfe;
                    statsByDate[dateStr].count++;
                }
            });
            
            // Clear grid
            grid.innerHTML = '';
            
            // Add empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day empty';
                grid.appendChild(emptyDay);
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayElement = document.createElement('div');
                const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const tradeCount = tradesByDate[dateStr] || 0;
                const activeCount = activeByDate[dateStr] || 0;
                
                dayElement.className = 'calendar-day';
                
                if (tradeCount > 0) {
                    dayElement.classList.add('has-trades');
                }
                
                if (activeCount > 0) {
                    dayElement.classList.add('has-active');
                }
                
                if (selectedDate === dateStr) {
                    dayElement.classList.add('selected');
                }
                
                let statsHtml = '';
                if (tradeCount > 0) {
                    const stats = statsByDate[dateStr];
                    const avgMFE = stats.count > 0 ? (stats.totalMFE / stats.count).toFixed(2) : '0.00';
                    statsHtml = `<div class="day-stats">Avg: ${avgMFE}R</div>`;
                }
                
                let activeHtml = '';
                if (activeCount > 0) {
                    activeHtml = `<div class="day-active">üî¥ ${activeCount} Active</div>`;
                }
                
                dayElement.innerHTML = `
                    <div class="day-number">${day}</div>
                    <div class="day-data">
                        ${tradeCount > 0 ? `<div class="day-trades">${tradeCount} trades</div>` : ''}
                        ${activeHtml}
                        ${statsHtml}
                    </div>
                `;
                
                dayElement.onclick = () => filterDate(dateStr);
                grid.appendChild(dayElement);
            }
        }

        function changeMonth(direction) {
            currentMonth += direction;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            } else if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            updateCalendar();
        }

        function filterDate(dateStr) {
            if (selectedDate === dateStr) {
                selectedDate = null; // Clear filter
            } else {
                selectedDate = dateStr; // Set filter
            }
            updateDashboard();
            updateCalendar();
        }

        // Utility Functions
        function formatTime(timestamp) {
            // Convert timestamp to Eastern Time to match TradingView
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'America/New_York',
                hour12: false
            });
        }




        // Minimal Journey for trades with only ENTRY event
        function renderMinimalJourney(trade, entryEvent) {
            const container = d3.select('#journeyViz');
            const width = container.node().getBoundingClientRect().width;
            const height = 400;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const centerY = height / 2;
            const spacing = width / 4;
            
            // Define minimal journey: ENTRY -> Waiting for MFE -> Potential Outcomes
            const nodes = [
                { x: spacing, y: centerY, label: 'Entry', sublabel: trade.entry_price ? trade.entry_price.toFixed(2) : 'N/A', color: '#4ade80', icon: '‚ñ∂', status: 'completed' },
                { x: spacing * 2, y: centerY, label: 'Awaiting Updates', sublabel: 'No MFE data yet', color: '#fbbf24', icon: '‚è≥', status: 'current' },
                { x: spacing * 3, y: centerY, label: 'Potential Exit', sublabel: 'Stop or Target', color: '#94a3b8', icon: 'üèÅ', status: 'potential' }
            ];
            
            // Draw lines
            for (let i = 0; i < nodes.length - 1; i++) {
                const source = nodes[i];
                const target = nodes[i + 1];
                
                svg.append('path')
                    .attr('class', i === 0 ? 'journey-link completed' : 'journey-link potential')
                    .attr('d', `M ${source.x},${source.y} L ${target.x},${target.y}`);
            }
            
            // Draw nodes
            const nodeGroups = svg.selectAll('.journey-node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'journey-node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            nodeGroups.append('circle')
                .attr('class', d => d.status === 'current' ? 'node-circle current-indicator' : 'node-circle')
                .attr('r', d => d.status === 'current' ? 40 : 32)
                .attr('fill', d => d.color)
                .attr('opacity', d => d.status === 'potential' ? 0.3 : 0.9);
            
            nodeGroups.append('text')
                .attr('class', 'node-label')
                .attr('y', 6)
                .style('font-size', d => d.status === 'current' ? '24px' : '18px')
                .text(d => d.icon);
            
            nodeGroups.append('text')
                .attr('class', 'node-label')
                .attr('y', -50)
                .text(d => d.label);
            
            nodeGroups.append('text')
                .attr('class', 'node-value')
                .attr('y', 55)
                .text(d => d.sublabel);
            
            // Add note about missing data
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 30)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .attr('font-size', '12px')
                .text('‚ö†Ô∏è Waiting for MFE updates from TradingView indicator');
        }

        // Trade Journey Visualization with D3.js
// Option 1: Clean Price Line Chart with Event Markers
function renderPriceChartJourney(trade) {
    console.log('renderPriceChartJourney called with trade:', trade);
    
    const container = d3.select('#journeyViz');
    container.selectAll('*').remove();
    
    if (!trade || !trade.events || trade.events.length === 0) {
        container.append('div')
            .style('text-align', 'center')
            .style('padding', '40px')
            .style('color', '#94a3b8')
            .text('No event data available for visualization');
        return;
    }
    
    // Extract trade data
    const direction = trade.direction;
    const entryPrice = trade.entry_price;
    const stopLoss = trade.stop_loss;
    let riskDistance = trade.risk_distance;
    const noBeRR = trade.no_be_mfe || 0;
    const beRR = trade.be_mfe || 0;
    const isActive = !trade.latest_event_type || !trade.latest_event_type.startsWith('EXIT_');
    const isBullish = direction === 'Bullish';
    
    console.log('Trade direction:', direction, 'isBullish:', isBullish);
    console.log('Entry:', entryPrice, 'Stop:', stopLoss, 'Risk:', riskDistance);
    console.log('MFE:', noBeRR);
    
    // Ensure riskDistance is always positive (distance, not direction)
    if (riskDistance < 0) {
        console.log('Risk distance was negative, converting to positive');
        riskDistance = Math.abs(riskDistance);
    }
    // If risk distance is missing or zero, calculate it
    if (!riskDistance || riskDistance === 0) {
        riskDistance = Math.abs(entryPrice - stopLoss);
        console.log('Calculated risk distance:', riskDistance);
    }
    
    // If incomplete data, show simple MFE bars
    if (!direction || !entryPrice || !stopLoss || !riskDistance) {
        renderSimpleMFEBars(container, trade, noBeRR, beRR, isActive);
        return;
    }
    
    // Filter and prepare key events only
    const keyEvents = [];
    
    // 1. Find ENTRY event
    const entryEvent = trade.events.find(e => e.event_type === 'ENTRY' || e.event_type === 'SIGNAL_CREATED');
    if (entryEvent) {
        keyEvents.push({
            type: 'ENTRY',
            event: entryEvent,
            mfe: 0,
            price: entryPrice,
            label: 'ENTRY',
            icon: '‚ñ∂',
            color: '#00d4ff'
        });
    }
    
    // 2. Find first MFE update (if exists)
    const mfeUpdates = trade.events.filter(e => e.event_type === 'MFE_UPDATE');
    if (mfeUpdates.length > 0) {
        const firstMFE = mfeUpdates[0];
        
        keyEvents.push({
            type: 'FIRST_MFE',
            event: firstMFE,
            mfe: firstMFE.no_be_mfe || 0,
            label: 'First Move',
            icon: 'üìä',
            color: '#3b82f6'
        });
    }
    
    // 3. Find BE_TRIGGERED event (if exists)
    const beEvent = trade.events.find(e => e.event_type === 'BE_TRIGGERED');
    if (beEvent) {
        keyEvents.push({
            type: 'BE_TRIGGERED',
            event: beEvent,
            mfe: 1.0,
            label: 'Break Even',
            icon: '‚ö°',
            color: '#fbbf24'
        });
    }
    
    // 4. Find peak MFE
    if (mfeUpdates.length > 0) {
        let peakMFE = mfeUpdates[0];
        mfeUpdates.forEach(e => {
            if ((e.no_be_mfe || 0) > (peakMFE.no_be_mfe || 0)) {
                peakMFE = e;
            }
        });
        
        // Only add if different from first and not the last
        if (peakMFE !== mfeUpdates[0] && peakMFE !== mfeUpdates[mfeUpdates.length - 1]) {
            keyEvents.push({
                type: 'PEAK_MFE',
                event: peakMFE,
                mfe: peakMFE.no_be_mfe || 0,
                label: 'Peak MFE',
                icon: 'üéØ',
                color: '#10b981'
            });
        }
    }
    
    // 5. Find EXIT event (if exists)
    const exitEvent = trade.events.find(e => e.event_type.startsWith('EXIT_'));
    if (exitEvent) {
        keyEvents.push({
            type: exitEvent.event_type,
            event: exitEvent,
            mfe: exitEvent.no_be_mfe || 0,
            label: exitEvent.event_type === 'EXIT_STOP_LOSS' ? 'Stop Loss' : 'BE Exit',
            icon: 'üõë',
            color: exitEvent.event_type === 'EXIT_STOP_LOSS' ? '#ef4444' : '#8b5cf6'
        });
    } else if (mfeUpdates.length > 0) {
        // If active, add current MFE as last point
        const currentMFE = mfeUpdates[mfeUpdates.length - 1];
        
        keyEvents.push({
            type: 'CURRENT',
            event: currentMFE,
            mfe: currentMFE.no_be_mfe || 0,
            label: 'Current',
            icon: 'üìà',
            color: '#4ade80'
        });
    }
    
    // Chart dimensions
    const width = container.node().offsetWidth || 600;
    const height = 400;
    const margin = {top: 60, right: 60, bottom: 60, left: 80};
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    
    // Create SVG
    const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('background', 'rgba(255,255,255,0.02)')
        .style('border-radius', '8px');
    
    const chart = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Calculate R-multiple range
    const mfeValues = keyEvents.map(e => e.mfe);
    const minMFE = Math.min(...mfeValues, -1); // At least show -1R (stop loss)
    const maxMFE = Math.max(...mfeValues, 1); // At least show +1R
    const mfeRange = maxMFE - minMFE;
    const mfePadding = mfeRange * 0.15;
    
    console.log('MFE range:', minMFE, 'to', maxMFE);
    console.log('Key events MFE values:', mfeValues);
    
    // Scales
    const xScale = d3.scaleLinear()
        .domain([0, keyEvents.length - 1])
        .range([0, chartWidth]);
    
    const yScale = d3.scaleLinear()
        .domain([minMFE - mfePadding, maxMFE + mfePadding])
        .range([chartHeight, 0]); // Higher MFE at top
    
    // Background gradient (profit/loss zones)
    const gradient = svg.append('defs')
        .append('linearGradient')
        .attr('id', 'profitGradient')
        .attr('x1', '0%')
        .attr('x2', '0%')
        .attr('y1', '0%')
        .attr('y2', '100%');
    
    gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', isBullish ? '#10b981' : '#ef4444')
        .attr('stop-opacity', 0.1);
    
    gradient.append('stop')
        .attr('offset', '50%')
        .attr('stop-color', '#00d4ff')
        .attr('stop-opacity', 0.05);
    
    gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', isBullish ? '#ef4444' : '#10b981')
        .attr('stop-opacity', 0.1);
    
    chart.append('rect')
        .attr('width', chartWidth)
        .attr('height', chartHeight)
        .attr('fill', 'url(#profitGradient)');
    
    // Draw horizontal reference lines (R-multiples)
    // Entry line (0R)
    chart.append('line')
        .attr('x1', 0)
        .attr('x2', chartWidth)
        .attr('y1', yScale(0))
        .attr('y2', yScale(0))
        .attr('stroke', '#00d4ff')
        .attr('stroke-width', 2)
        .attr('stroke-dasharray', '5,5')
        .attr('opacity', 0.6);
    
    chart.append('text')
        .attr('x', -10)
        .attr('y', yScale(0))
        .attr('text-anchor', 'end')
        .attr('alignment-baseline', 'middle')
        .attr('fill', '#00d4ff')
        .attr('font-size', '11px')
        .text('Entry (0R)');
    
    // Stop loss line (-1R)
    chart.append('line')
        .attr('x1', 0)
        .attr('x2', chartWidth)
        .attr('y1', yScale(-1))
        .attr('y2', yScale(-1))
        .attr('stroke', '#ef4444')
        .attr('stroke-width', 2)
        .attr('stroke-dasharray', '3,3')
        .attr('opacity', 0.6);
    
    chart.append('text')
        .attr('x', -10)
        .attr('y', yScale(-1))
        .attr('text-anchor', 'end')
        .attr('alignment-baseline', 'middle')
        .attr('fill', '#ef4444')
        .attr('font-size', '11px')
        .text('Stop (-1R)');
    
    // +1R line (BE trigger)
    chart.append('line')
        .attr('x1', 0)
        .attr('x2', chartWidth)
        .attr('y1', yScale(1))
        .attr('y2', yScale(1))
        .attr('stroke', '#fbbf24')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '2,2')
        .attr('opacity', 0.4);
    
    chart.append('text')
        .attr('x', -10)
        .attr('y', yScale(1))
        .attr('text-anchor', 'end')
        .attr('alignment-baseline', 'middle')
        .attr('fill', '#fbbf24')
        .attr('font-size', '10px')
        .text('+1R (BE)');
    
    // Draw MFE line
    const line = d3.line()
        .x((d, i) => xScale(i))
        .y(d => yScale(d.mfe))
        .curve(d3.curveMonotoneX);
    
    const lineColor = noBeRR >= 0 ? '#4ade80' : '#ef4444';
    
    chart.append('path')
        .datum(keyEvents)
        .attr('fill', 'none')
        .attr('stroke', lineColor)
        .attr('stroke-width', 3)
        .attr('d', line)
        .attr('opacity', 0.8);
    
    // Draw event markers
    keyEvents.forEach((event, i) => {
        const group = chart.append('g')
            .attr('transform', `translate(${xScale(i)},${yScale(event.mfe)})`);
        
        // Event circle
        group.append('circle')
            .attr('r', event.type === 'ENTRY' || event.type.startsWith('EXIT_') ? 10 : 7)
            .attr('fill', event.color)
            .attr('stroke', '#0a0e27')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer');
        
        // Event icon
        group.append('text')
            .attr('text-anchor', 'middle')
            .attr('alignment-baseline', 'middle')
            .attr('fill', '#0a0e27')
            .attr('font-size', event.type === 'ENTRY' || event.type.startsWith('EXIT_') ? '12px' : '10px')
            .attr('font-weight', '700')
            .text(event.icon);
        
        // Event label
        group.append('text')
            .attr('y', -20)
            .attr('text-anchor', 'middle')
            .attr('fill', event.color)
            .attr('font-size', '11px')
            .attr('font-weight', '600')
            .text(event.label);
        
        // MFE value
        if (event.mfe !== 0) {
            group.append('text')
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .attr('font-size', '10px')
                .text(`${event.mfe.toFixed(2)}R`);
        }
        
        // Hover effect
        group.on('mouseover', function() {
            d3.select(this).select('circle')
                .transition()
                .duration(200)
                .attr('r', event.type === 'ENTRY' || event.type.startsWith('EXIT_') ? 14 : 10);
        })
        .on('mouseout', function() {
            d3.select(this).select('circle')
                .transition()
                .duration(200)
                .attr('r', event.type === 'ENTRY' || event.type.startsWith('EXIT_') ? 10 : 7);
        });
    });
    
    // Title
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', 30)
        .attr('text-anchor', 'middle')
        .attr('fill', '#00d4ff')
        .attr('font-size', '16px')
        .attr('font-weight', '600')
        .text(`${direction} Trade Journey - ${isActive ? 'ACTIVE' : 'COMPLETED'}`);
    
    // Final MFE display
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', height - 15)
        .attr('text-anchor', 'middle')
        .attr('fill', noBeRR >= 0 ? '#4ade80' : '#ef4444')
        .attr('font-size', '14px')
        .attr('font-weight', '600')
        .text(`Final MFE: ${noBeRR.toFixed(2)}R`);
    
    // Status indicator
    svg.append('circle')
        .attr('cx', width - 30)
        .attr('cy', 30)
        .attr('r', 8)
        .attr('fill', isActive ? '#4ade80' : '#8b5cf6');
}

// Helper function for simple MFE bars (when data is incomplete)
function renderSimpleMFEBars(container, trade, noBeRR, beRR, isActive) {
    const width = container.node().offsetWidth || 600;
    const height = 250;
    
    const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('background', 'rgba(255,255,255,0.02)')
        .style('border-radius', '8px');
    
    // Title
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', 30)
        .attr('text-anchor', 'middle')
        .attr('fill', '#00d4ff')
        .attr('font-size', '16px')
        .attr('font-weight', '600')
        .text(`Trade ${trade.trade_id || 'Unknown'} - ${isActive ? 'ACTIVE' : 'COMPLETED'}`);
    
    // MFE bars
    const barY = height / 2;
    const maxBarWidth = width - 200;
    const maxMFE = Math.max(noBeRR, beRR, 1);
    
    // No BE MFE bar
    const noBeWidth = (noBeRR / maxMFE) * maxBarWidth;
    svg.append('rect')
        .attr('x', 100)
        .attr('y', barY - 40)
        .attr('width', noBeWidth)
        .attr('height', 30)
        .attr('fill', noBeRR > 0 ? '#4ade80' : '#ef4444')
        .attr('opacity', 0.7);
    
    svg.append('text')
        .attr('x', 90)
        .attr('y', barY - 20)
        .attr('text-anchor', 'end')
        .attr('fill', '#e0e6ed')
        .attr('font-size', '12px')
        .text('No BE:');
    
    svg.append('text')
        .attr('x', 110 + noBeWidth)
        .attr('y', barY - 20)
        .attr('fill', '#4ade80')
        .attr('font-size', '14px')
        .attr('font-weight', '600')
        .text(`${noBeRR.toFixed(2)}R`);
    
    // BE=1 MFE bar
    const beWidth = (beRR / maxMFE) * maxBarWidth;
    svg.append('rect')
        .attr('x', 100)
        .attr('y', barY + 10)
        .attr('width', beWidth)
        .attr('height', 30)
        .attr('fill', beRR > 0 ? '#fbbf24' : '#ef4444')
        .attr('opacity', 0.7);
    
    svg.append('text')
        .attr('x', 90)
        .attr('y', barY + 30)
        .attr('text-anchor', 'end')
        .attr('fill', '#e0e6ed')
        .attr('font-size', '12px')
        .text('BE=1:');
    
    svg.append('text')
        .attr('x', 110 + beWidth)
        .attr('y', barY + 30)
        .attr('fill', '#fbbf24')
        .attr('font-size', '14px')
        .attr('font-weight', '600')
        .text(`${beRR.toFixed(2)}R`);
    
    // Status indicator
    svg.append('circle')
        .attr('cx', width - 30)
        .attr('cy', 30)
        .attr('r', 8)
        .attr('fill', isActive ? '#4ade80' : '#8b5cf6');
    
    // Info message
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', height - 20)
        .attr('text-anchor', 'middle')
        .attr('fill', '#94a3b8')
        .attr('font-size', '11px')
        .text(`${trade.events ? trade.events.length : 0} events ‚Ä¢ ${trade.direction || 'Direction unknown'}`);
}




        // Trade Detail Modal Functions
        async function showTradeDetail(tradeId) {
            const modal = document.getElementById('tradeDetailModal');
            const body = document.getElementById('tradeDetailBody');
            
            body.innerHTML = '<div style="text-align: center; padding: 40px; color: #00d4ff;">Loading trade details...</div>';
            modal.style.display = 'block';
            
            try {
                const response = await fetch(`/api/automated-signals/trade-detail/${tradeId}`);
                const data = await response.json();
                
                if (data.success) {
                    renderTradeDetail(data.trade);
                } else {
                    body.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Error: ${data.error}</div>`;
                }
            } catch (error) {
                console.error('Error loading trade detail:', error);
                body.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Error loading trade details</div>`;
            }
        }

        function renderTradeDetail(trade) {
            const body = document.getElementById('tradeDetailBody');
            
            // Validate trade data
            if (!trade || !trade.events || trade.events.length === 0) {
                body.innerHTML = '<div style="color: #fbbf24; text-align: center; padding: 40px;">No event data available for this trade</div>';
                return;
            }
            
            // Determine current status from latest event
            const latestEvent = trade.events[trade.events.length - 1];
            const isActive = !latestEvent.event_type || !latestEvent.event_type.startsWith('EXIT_');
            const statusText = isActive ? 'ACTIVE' : 'COMPLETED';
            const statusColor = isActive ? '#4ade80' : '#8b5cf6';
            
            body.innerHTML = `
                <div class="journey-container">
                    <div class="journey-title">üìç Trade Journey Map</div>
                    <div id="journeyViz"></div>
                    <div class="journey-legend">
                        <div class="legend-item">
                            <div class="legend-line completed"></div>
                            <span>Completed</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line active"></div>
                            <span>Current</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line potential"></div>
                            <span>Potential Next</span>
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Trade Summary</h3>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="detail-label">Trade ID</div>
                            <div class="detail-value">${trade.trade_id}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Current Status</div>
                            <div class="detail-value" style="color: ${statusColor}">${statusText}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Latest Event</div>
                            <div class="detail-value">${latestEvent.event_type}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Direction</div>
                            <div class="detail-value">${trade.direction}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Session</div>
                            <div class="detail-value">${trade.session || 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Entry Price</div>
                            <div class="detail-value">${trade.entry_price ? trade.entry_price.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Stop Loss</div>
                            <div class="detail-value">${trade.stop_loss ? trade.stop_loss.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Risk Distance</div>
                            <div class="detail-value">${trade.risk_distance ? trade.risk_distance.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">BE=1 MFE</div>
                            <div class="detail-value">${trade.be_mfe ? trade.be_mfe.toFixed(2) + 'R' : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">No BE MFE</div>
                            <div class="detail-value">${trade.no_be_mfe ? trade.no_be_mfe.toFixed(2) + 'R' : 'N/A'}</div>
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Event Timeline (${trade.events.length} events)</h3>
                    <div class="event-timeline">
                        ${trade.events.map((event, index) => {
                            // Format timestamp properly
                            let timeDisplay = '';
                            if (event.signal_time) {
                                const dt = new Date(event.signal_time);
                                timeDisplay = dt.toLocaleString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    hour: '2-digit', 
                                    minute: '2-digit',
                                    second: '2-digit'
                                });
                            } else if (event.timestamp) {
                                const dt = new Date(event.timestamp);
                                timeDisplay = dt.toLocaleString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    hour: '2-digit', 
                                    minute: '2-digit',
                                    second: '2-digit'
                                });
                            } else {
                                timeDisplay = `Event ${index + 1}`;
                            }
                            
                            return `
                            <div class="event-item">
                                <div class="event-header">
                                    <span class="event-type">${event.event_type}</span>
                                    <span class="event-time">${timeDisplay}</span>
                                </div>
                                <div class="event-details">
                                    ${event.be_mfe !== null && event.be_mfe !== undefined ? `<div class="event-detail">BE MFE: <strong>${event.be_mfe.toFixed(2)}R</strong></div>` : ''}
                                    ${event.no_be_mfe !== null && event.no_be_mfe !== undefined ? `<div class="event-detail">No BE MFE: <strong>${event.no_be_mfe.toFixed(2)}R</strong></div>` : ''}
                                    ${event.entry_price ? `<div class="event-detail">Entry: <strong>${event.entry_price.toFixed(2)}</strong></div>` : ''}
                                    ${event.stop_loss ? `<div class="event-detail">Stop: <strong>${event.stop_loss.toFixed(2)}</strong></div>` : ''}
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                </div>
                
                <div class="detail-section">
                    <h3>Latest Alert Payload</h3>
                    <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; color: #e0e6ed; overflow-x: auto;">
                        <pre>${JSON.stringify(latestEvent, null, 2)}</pre>
                    </div>
                </div>
            `;
            
            // Render the journey visualization after DOM is updated
            setTimeout(() => renderPriceChartJourney(trade), 100);
        }

        function closeTradeDetail() {
            document.getElementById('tradeDetailModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('tradeDetailModal');
            if (event.target == modal) {
                closeTradeDetail();
            }
        }

        // Bulk Delete Functionality
        let selectedTrades = new Set();
        
        function toggleTradeSelection(tradeId) {
            const checkbox = document.querySelector(`.trade-checkbox[data-trade-id="${tradeId}"]`);
            if (checkbox && checkbox.checked) {
                selectedTrades.add(tradeId);
            } else {
                selectedTrades.delete(tradeId);
            }
            updateBulkDeleteButton();
        }
        
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const checkboxes = document.querySelectorAll('.trade-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
                const tradeId = checkbox.getAttribute('data-trade-id');
                if (selectAllCheckbox.checked) {
                    selectedTrades.add(tradeId);
                } else {
                    selectedTrades.delete(tradeId);
                }
            });
            
            updateBulkDeleteButton();
        }
        
        function updateBulkDeleteButton() {
            const button = document.getElementById('bulkDeleteBtn');
            if (button) {
                button.textContent = `Delete Selected (${selectedTrades.size})`;
                button.style.display = selectedTrades.size > 0 ? 'block' : 'none';
            }
        }
        
        async function bulkDeleteTrades() {
            if (selectedTrades.size === 0) {
                alert('No trades selected');
                return;
            }
            
            const confirmation = confirm(`Are you sure you want to delete ${selectedTrades.size} selected trade(s)? This action cannot be undone.`);
            if (!confirmation) return;
            
            try {
                const tradeIds = Array.from(selectedTrades);
                const response = await fetch('/api/automated-signals/bulk-delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ trade_ids: tradeIds })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert(`Successfully deleted ${result.deleted_count} trade(s)`);
                    selectedTrades.clear();
                    document.getElementById('selectAllCheckbox').checked = false;
                    loadInitialData(); // Refresh the data
                } else {
                    alert(`Error: ${result.error}`);
                }
            } catch (error) {
                console.error('Bulk delete error:', error);
                alert('Error deleting trades. Please try again.');
            }
        }

        // Initialize
        loadInitialData();
    </script>

<!-- Trade Detail Modal -->
<div id="tradeDetailModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Trade Details</h2>
            <span class="close-modal" onclick="closeTradeDetail()">&times;</span>
        </div>
        <div class="modal-body" id="tradeDetailBody">
            <!-- Populated by JavaScript -->
        </div>
    </div>
</div>

</body>
</html>


<!-- Calendar implementation complete - ready for deployment -->
