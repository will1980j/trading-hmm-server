<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Optimizer - Unified Analysis</title>
    <link rel="stylesheet" href="/style_preload.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); color: #fff; padding: 20px; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; }
        .navbar { background: rgba(255,255,255,0.1); padding: 15px; margin-bottom: 20px; border-radius: 15px; backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); }
        .nav-link { color: rgba(255,255,255,0.8); text-decoration: none; padding: 10px 18px; background: rgba(255,255,255,0.05); border-radius: 10px; transition: all 0.3s; font-weight: 500; border: 1px solid rgba(255,255,255,0.1); display: inline-block; margin: 0 5px; }
        .nav-link:hover { background: rgba(255,255,255,0.15); }
        .nav-link.active { color: #00ff88; background: rgba(0,255,136,0.15); border-color: rgba(0,255,136,0.3); }
        .header { text-align: center; padding: 40px; background: rgba(255,255,255,0.08); border-radius: 20px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .header h1 { font-size: 3em; font-weight: 800; margin-bottom: 10px; background: linear-gradient(45deg, #00ff88, #00d4aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .controls { background: rgba(255,255,255,0.08); border-radius: 20px; padding: 25px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .control-group label { display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #00ff88; }
        input[type="number"], select { width: 100%; padding: 12px; border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; background: rgba(255,255,255,0.1); color: white; font-size: 14px; }
        .session-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px; }
        .session-item { display: flex; align-items: center; gap: 8px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; }
        .session-item input { width: 16px; height: 16px; accent-color: #00ff88; }
        .btn { background: linear-gradient(45deg, #00ff88, #00d4aa); border: none; padding: 15px 40px; border-radius: 12px; color: white; font-weight: 700; cursor: pointer; font-size: 16px; box-shadow: 0 4px 15px rgba(0,255,136,0.3); transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,255,136,0.4); }
        .section { background: rgba(255,255,255,0.08); border-radius: 20px; padding: 30px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .section-title { font-size: 24px; font-weight: 800; color: #00ff88; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 25px; }
        .metric-card { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; text-align: center; }
        .metric-value { font-size: 32px; font-weight: 700; margin: 10px 0; background: linear-gradient(45deg, #00ff88, #00d4aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .metric-label { font-size: 12px; text-transform: uppercase; opacity: 0.8; font-weight: 600; }
        .strategy-box { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #00ff88; }
        .detail-row { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .detail-label { opacity: 0.8; }
        .detail-value { font-weight: 600; color: #00ff88; }
        .warning-box { background: rgba(255,71,87,0.1); border: 1px solid rgba(255,71,87,0.3); border-radius: 12px; padding: 15px; margin-top: 20px; color: #ff4757; }
        .success-box { background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 12px; padding: 15px; margin-top: 20px; color: #00ff88; }
        .comparison-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .comparison-table th { background: rgba(0,255,136,0.1); padding: 12px; text-align: left; font-weight: 600; color: #00ff88; border-bottom: 2px solid rgba(0,255,136,0.3); }
        .comparison-table td { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .comparison-table tr:hover { background: rgba(255,255,255,0.05); cursor: pointer; }
        .loading { text-align: center; padding: 60px; font-size: 18px; color: rgba(255,255,255,0.7); }
        .time-window { background: rgba(58,123,213,0.1); border: 1px solid rgba(58,123,213,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
        .ml-insight { background: rgba(102,126,234,0.1); border: 1px solid rgba(102,126,234,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
        .gpt-insight { background: rgba(255,165,2,0.1); border: 1px solid rgba(255,165,2,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
    </style>
</head>
<body>
    <nav class="navbar">
        <div style="display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap;">
            <a href="/ml-dashboard" class="nav-link">ü§ñ ML</a>
            <a href="/live-signals-dashboard" class="nav-link">üì∂ Live</a>
            <a href="/signal-lab-dashboard" class="nav-link">üè† Dashboard</a>
            <a href="/signal-analysis-lab" class="nav-link">üìä Signal Lab</a>
            <a href="/strategy-optimizer" class="nav-link active">üéØ Optimizer</a>
            <a href="/ai-business-advisor" class="nav-link">üß† AI Advisor</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>üéØ Strategy Optimizer</h1>
            <p>Unified analysis: TIME + ML + GPT-4 + Prop Firm Constraints</p>
        </div>
        
        <div class="controls">
            <h3 style="color: #00ff88; margin-bottom: 20px;">üö® Prop Firm Constraints</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label>Max Daily Loss (%)</label>
                    <input type="number" id="maxDailyLoss" value="5" min="1" max="10" step="0.5">
                </div>
                <div class="control-group">
                    <label>Max Total Drawdown (%)</label>
                    <input type="number" id="maxDrawdown" value="10" min="5" max="20" step="1">
                </div>
                <div class="control-group">
                    <label>Risk Per Trade (%)</label>
                    <input type="number" id="riskPerTrade" value="0.5" min="0.1" max="2" step="0.1">
                </div>
                <div class="control-group">
                    <label>Min Win Rate (%)</label>
                    <input type="number" id="minWinRate" value="40" min="0" max="100" step="5">
                </div>
                <div class="control-group" style="grid-column: 1/-1; background: rgba(0,255,136,0.1); padding: 15px; border-radius: 10px; margin-top: 10px;">
                    <label style="color: #00ff88;">üìä Max R-Target (Auto-calculated)</label>
                    <div id="maxRDisplay" style="font-size: 24px; font-weight: 700; color: #00ff88; margin-top: 5px;">-</div>
                    <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">Based on: Max Daily Loss √∑ Risk Per Trade</div>
                </div>
            </div>
            
            <h3 style="color: #00ff88; margin: 20px 0;">‚è∞ Session Selection</h3>
            <div class="session-grid">
                <div class="session-item"><input type="checkbox" id="sessAsia" value="Asia" checked><label for="sessAsia">Asia</label></div>
                <div class="session-item"><input type="checkbox" id="sessLondon" value="London" checked><label for="sessLondon">London</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYPre" value="NY Pre Market" checked><label for="sessNYPre">NY Pre</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYAM" value="NY AM" checked><label for="sessNYAM">NY AM</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYLunch" value="NY Lunch" checked><label for="sessNYLunch">NY Lunch</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYPM" value="NY PM" checked><label for="sessNYPM">NY PM</label></div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn" onclick="runUnifiedOptimization()">üöÄ Find Optimal Strategy (All Methods)</button>
            </div>
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        let signals = [];
        
        async function loadSignals() {
            try {
                const response = await fetch('https://web-production-cd33.up.railway.app/api/signal-lab-trades?analysis_only=true');
                if (!response.ok) throw new Error('Failed to load data');
                const data = await response.json();
                const trades = Array.isArray(data) ? data : data.trades || [];
                signals = trades.filter(t => { const d = new Date(t.date); return d.getDay() !== 0 && d.getDay() !== 6; })
                    .map(t => ({ date: t.date, time: t.time, session: t.session, mfeNone: parseFloat(t.mfe_none || t.mfe) || 0, mfe1: parseFloat(t.mfe1) || 0 }));
                console.log(`Loaded ${signals.length} signals`);
            } catch (error) {
                console.error('Error loading signals:', error);
                document.getElementById('results').innerHTML = `<div class="warning-box">Failed to load data: ${error.message}</div>`;
            }
        }
        
        function getSelectedSessions() {
            return ['sessAsia', 'sessLondon', 'sessNYPre', 'sessNYAM', 'sessNYLunch', 'sessNYPM']
                .filter(id => document.getElementById(id).checked).map(id => document.getElementById(id).value);
        }
        
        function calculateTradeResult(signal, beStrategy, rTarget) {
            const mfe = beStrategy === 'be1' ? signal.mfe1 : signal.mfeNone;
            if (!mfe || mfe === 0) return -1;
            if (beStrategy === 'none') return mfe < 0 ? -1 : (mfe >= rTarget ? rTarget : -1);
            if (mfe < 1) return -1;
            if (mfe >= 1 && mfe < rTarget) return 0;
            if (mfe >= rTarget) return rTarget;
            return -1;
        }
        
        function calculateStats(results) {
            const wins = results.filter(r => r > 0).length;
            const losses = results.filter(r => r < 0).length;
            const breakevens = results.filter(r => r === 0).length;
            const total = results.length;
            const winRate = total > 0 ? ((wins + breakevens) / total) * 100 : 0;
            const totalR = results.reduce((sum, r) => sum + r, 0);
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const avgWin = winResults.length > 0 ? winResults.reduce((a, b) => a + b, 0) / winResults.length : 0;
            const avgLoss = lossResults.length > 0 ? Math.abs(lossResults.reduce((a, b) => a + b, 0) / lossResults.length) : 0;
            const expectancy = total > 0 ? (((wins + breakevens) / total) * avgWin) - ((losses / total) * avgLoss) : 0;
            let maxConsecLosses = 0, currentConsecLosses = 0, maxDrawdown = 0, currentDrawdown = 0, peak = 0, runningTotal = 0;
            results.forEach(result => {
                runningTotal += result;
                if (runningTotal > peak) { peak = runningTotal; currentDrawdown = 0; }
                else { currentDrawdown = peak - runningTotal; maxDrawdown = Math.max(maxDrawdown, currentDrawdown); }
                if (result < 0) { currentConsecLosses++; maxConsecLosses = Math.max(maxConsecLosses, currentConsecLosses); }
                else if (result > 0) currentConsecLosses = 0;
            });
            return { expectancy, winRate, totalR, maxConsecLosses, maxDrawdown, total };
        }
        
        function analyzeTimeWindows(sessionSignals, session) {
            const hourlyPerf = {};
            sessionSignals.forEach(s => {
                if (!s.time) return;
                const hour = parseInt(s.time.split(':')[0]);
                if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                hourlyPerf[hour].push(s);
            });
            const hourlyStats = Object.entries(hourlyPerf).map(([hour, sigs]) => {
                if (sigs.length < 3) return null;
                const results = sigs.map(s => calculateTradeResult(s, 'none', 2));
                const stats = calculateStats(results);
                return { hour: parseInt(hour), count: sigs.length, expectancy: stats.expectancy, winRate: stats.winRate };
            }).filter(h => h !== null).sort((a, b) => b.expectancy - a.expectancy);
            return hourlyStats.slice(0, 3);
        }
        
        async function getMLPrediction(session) {
            try {
                const response = await fetch('https://web-production-cd33.up.railway.app/api/ml-insights');
                if (!response.ok) return null;
                const data = await response.json();
                if (data.performance && data.performance.is_trained) {
                    return { trained: true, accuracy: data.performance.performance_metrics ? 
                        Math.max(...Object.values(data.performance.performance_metrics).map(m => m.test_r2 * 100)) : 0 };
                }
                return { trained: false };
            } catch (error) { return null; }
        }
        
        async function getGPT4Analysis(bestCombo) {
            try {
                const sessionsText = bestCombo.sessions.join(', ');
                const prompt = `Analyze this optimal NQ trading strategy:\nSessions: ${sessionsText}\nBE: ${bestCombo.beStrategy}\nR-Target: ${bestCombo.rTarget}R\nExpectancy: ${bestCombo.stats.expectancy.toFixed(3)}R\nWin Rate: ${bestCombo.stats.winRate.toFixed(1)}%\n\nProvide: 1) Why this works 2) Session-specific tips 3) Risk management advice. Keep under 150 words.`;
                const response = await fetch('https://web-production-cd33.up.railway.app/api/ai-insights', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, data: {} })
                });
                if (!response.ok) return null;
                const data = await response.json();
                return data.insight || null;
            } catch (error) { return null; }
        }
        
        async function runUnifiedOptimization() {
            if (signals.length === 0) { await loadSignals(); if (signals.length === 0) return; }
            document.getElementById('results').innerHTML = '<div class="loading">üîÑ Running unified analysis (TIME + ML + GPT-4)...</div>';
            
            const constraints = {
                maxDailyLoss: parseFloat(document.getElementById('maxDailyLoss').value),
                maxDrawdown: parseFloat(document.getElementById('maxDrawdown').value),
                riskPerTrade: parseFloat(document.getElementById('riskPerTrade').value),
                minWinRate: parseFloat(document.getElementById('minWinRate').value)
            };
            
            const selectedSessions = getSelectedSessions();
            const beStrategies = ['none', 'be1'];
            const maxPossibleR = Math.floor(constraints.maxDailyLoss / constraints.riskPerTrade);
            const rTargets = [];
            for (let r = 1; r <= maxPossibleR; r += 0.5) rTargets.push(r);
            let allCombinations = [], bestOverall = null, bestScore = -999;
            
            // Single sessions
            beStrategies.forEach(beStrategy => {
                rTargets.forEach(rTarget => {
                    selectedSessions.forEach(session => {
                        const sessionSignals = signals.filter(s => s.session === session);
                        if (sessionSignals.length < 30) return;
                        const results = sessionSignals.map(s => calculateTradeResult(s, beStrategy, rTarget));
                        const stats = calculateStats(results);
                        const maxDailyLossPercent = stats.maxConsecLosses * constraints.riskPerTrade;
                        const maxDrawdownPercent = stats.maxDrawdown * constraints.riskPerTrade;
                        const propViable = maxDailyLossPercent <= constraints.maxDailyLoss && 
                                         maxDrawdownPercent <= constraints.maxDrawdown && 
                                         stats.winRate >= constraints.minWinRate;
                        if (!propViable) return;
                        const avgRPerTrade = stats.totalR / stats.total;
                        const sharpe = stats.expectancy / (stats.maxDrawdown > 0 ? stats.maxDrawdown : 1);
                        const score = (stats.expectancy * 40) + (stats.winRate / 100 * 20) + (avgRPerTrade * 15) + (sharpe * 10) + (Math.log(stats.total) * 5);
                        const combo = { sessions: [session], beStrategy, rTarget, stats, score, maxDailyLossPercent, maxDrawdownPercent, avgRPerTrade };
                        allCombinations.push(combo);
                        if (score > bestScore) { bestScore = score; bestOverall = combo; }
                    });
                });
            });
            
            // Multi-session combinations
            beStrategies.forEach(beStrategy => {
                rTargets.forEach(rTarget => {
                    for (let i = 0; i < selectedSessions.length; i++) {
                        for (let j = i + 1; j < selectedSessions.length; j++) {
                            const sessionPair = [selectedSessions[i], selectedSessions[j]];
                            const combinedSignals = signals.filter(s => sessionPair.includes(s.session));
                            if (combinedSignals.length < 50) continue;
                            const results = combinedSignals.map(s => calculateTradeResult(s, beStrategy, rTarget));
                            const stats = calculateStats(results);
                            const maxDailyLossPercent = stats.maxConsecLosses * constraints.riskPerTrade;
                            const maxDrawdownPercent = stats.maxDrawdown * constraints.riskPerTrade;
                            const propViable = maxDailyLossPercent <= constraints.maxDailyLoss && 
                                             maxDrawdownPercent <= constraints.maxDrawdown && 
                                             stats.winRate >= constraints.minWinRate;
                            if (!propViable) continue;
                            const avgRPerTrade = stats.totalR / stats.total;
                            const sharpe = stats.expectancy / (stats.maxDrawdown > 0 ? stats.maxDrawdown : 1);
                            const score = (stats.expectancy * 40) + (stats.winRate / 100 * 20) + (avgRPerTrade * 15) + (sharpe * 10) + (Math.log(stats.total) * 5);
                            const combo = { sessions: sessionPair, beStrategy, rTarget, stats, score, maxDailyLossPercent, maxDrawdownPercent, avgRPerTrade };
                            allCombinations.push(combo);
                            if (score > bestScore) { bestScore = score; bestOverall = combo; }
                        }
                    }
                });
            });
            
            if (!bestOverall) {
                document.getElementById('results').innerHTML = '<div class="warning-box"><strong>‚ùå No viable strategy found</strong><br>All combinations violate prop firm constraints.</div>';
                return;
            }
            
            allCombinations.sort((a, b) => b.score - a.score);
            const topAlternatives = allCombinations.slice(0, 10);
            
            const timeWindows = {};
            const sessionsToAnalyze = [...new Set(bestOverall.sessions)];
            sessionsToAnalyze.forEach(session => {
                const sessionSignals = signals.filter(s => s.session === session);
                if (sessionSignals.length >= 10) timeWindows[session] = analyzeTimeWindows(sessionSignals, session);
            });
            
            const mlPrediction = await getMLPrediction(bestOverall.sessions[0]);
            const gpt4Analysis = await getGPT4Analysis(bestOverall);
            
            displayUnifiedResults(bestOverall, topAlternatives, timeWindows, mlPrediction, gpt4Analysis, constraints);
        }
        
        function displayUnifiedResults(best, alternatives, timeWindows, mlPrediction, gpt4Analysis, constraints) {
            const beText = { 'none': 'No Breakeven', 'be1': 'Breakeven at 1R' };
            const sessionsText = best.sessions.length === 1 ? best.sessions[0] : best.sessions.join(' + ');
            const totalPercent = best.stats.totalR * constraints.riskPerTrade;
            
            let timeHtml = '';
            Object.entries(timeWindows).forEach(([session, windows]) => {
                if (windows.length > 0) {
                    timeHtml += `<div class="time-window"><strong>‚è∞ ${session} Best Hours:</strong><br>`;
                    windows.forEach(w => timeHtml += `${w.hour}:00 - ${w.expectancy.toFixed(3)}R expectancy (${w.count} trades)<br>`);
                    timeHtml += '</div>';
                }
            });
            
            const mlHtml = mlPrediction ? (mlPrediction.trained ? 
                `<div class="ml-insight"><strong>ü§ñ ML Analysis:</strong> Models trained (${mlPrediction.accuracy.toFixed(1)}% accuracy). Use ML predictions for position sizing on ${sessionsText} signals.</div>` :
                `<div class="ml-insight"><strong>ü§ñ ML Status:</strong> Not trained yet. Add more MFE data for predictions.</div>`) : '';
            
            const gpt4Html = gpt4Analysis ? 
                `<div class="gpt-insight"><strong>üß† GPT-4 Insight:</strong><br>${gpt4Analysis}</div>` : '';
            
            const html = `
                <div class="section">
                    <div class="section-title">üèÜ OPTIMAL STRATEGY (Unified Analysis)</div>
                    <div class="metrics-grid">
                        <div class="metric-card"><div class="metric-label">Expectancy</div><div class="metric-value">${best.stats.expectancy.toFixed(3)}R</div></div>
                        <div class="metric-card"><div class="metric-label">Win Rate</div><div class="metric-value">${best.stats.winRate.toFixed(1)}%</div></div>
                        <div class="metric-card"><div class="metric-label">Total Return</div><div class="metric-value">${totalPercent > 0 ? '+' : ''}${totalPercent.toFixed(1)}%</div></div>
                        <div class="metric-card"><div class="metric-label">Max Daily Loss</div><div class="metric-value">${best.maxDailyLossPercent.toFixed(1)}%</div></div>
                        <div class="metric-card"><div class="metric-label">Max Drawdown</div><div class="metric-value">${best.maxDrawdownPercent.toFixed(1)}%</div></div>
                        <div class="metric-card"><div class="metric-label">Total Trades</div><div class="metric-value">${best.stats.total}</div></div>
                    </div>
                    <div class="strategy-box">
                        <h4 style="color: #00ff88; margin-bottom: 15px;">Strategy Configuration</h4>
                        <div class="detail-row"><span class="detail-label">Sessions</span><span class="detail-value">${sessionsText}</span></div>
                        <div class="detail-row"><span class="detail-label">Breakeven Strategy</span><span class="detail-value">${beText[best.beStrategy]}</span></div>
                        <div class="detail-row"><span class="detail-label">R-Target</span><span class="detail-value">${best.rTarget}R</span></div>
                        <div class="detail-row"><span class="detail-label">Risk Per Trade</span><span class="detail-value">${constraints.riskPerTrade}%</span></div>
                    </div>
                    ${timeHtml}
                    ${mlHtml}
                    ${gpt4Html}
                    <div class="success-box"><strong>‚úÖ Prop Firm Compliant</strong><br>Max daily loss: ${best.maxDailyLossPercent.toFixed(1)}% (limit: ${constraints.maxDailyLoss}%) | Max drawdown: ${best.maxDrawdownPercent.toFixed(1)}% (limit: ${constraints.maxDrawdown}%)</div>
                </div>
                
                <div class="section">
                    <div class="section-title">üìä Top 10 Alternative Strategies</div>
                    <table class="comparison-table">
                        <thead><tr><th>Rank</th><th>Sessions</th><th>BE</th><th>R-Target</th><th>Expectancy</th><th>Win Rate</th><th>Avg R/Trade</th><th>Daily Loss</th><th>Trades</th><th>Score</th></tr></thead>
                        <tbody>
                            ${alternatives.map((c, i) => `<tr><td>${i+1}</td><td>${c.sessions.join(' + ')}</td><td>${beText[c.beStrategy]}</td><td>${c.rTarget}R</td><td>${c.stats.expectancy.toFixed(3)}R</td><td>${c.stats.winRate.toFixed(1)}%</td><td>${c.avgRPerTrade.toFixed(3)}R</td><td>${c.maxDailyLossPercent.toFixed(1)}%</td><td>${c.stats.total}</td><td style="color: #00ff88; font-weight: 600;">${c.score.toFixed(1)}</td></tr>`).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            document.getElementById('results').innerHTML = html;
        }
        
        function updateMaxR() {
            const maxDailyLoss = parseFloat(document.getElementById('maxDailyLoss').value);
            const riskPerTrade = parseFloat(document.getElementById('riskPerTrade').value);
            const maxR = Math.floor(maxDailyLoss / riskPerTrade);
            document.getElementById('maxRDisplay').textContent = `${maxR}R (${maxDailyLoss}% √∑ ${riskPerTrade}% = ${maxR} max consecutive losses)`;
        }
        
        document.addEventListener('DOMContentLoaded', () => { 
            loadSignals(); 
            updateMaxR();
            ['maxDailyLoss', 'riskPerTrade'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateMaxR);
            });
        });
    </script>
</body>
</html>
