<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Optimizer - Unified Analysis</title>
    <link rel="stylesheet" href="/style_preload.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); color: #fff; padding: 20px; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; }
        .navbar { background: rgba(255,255,255,0.1); padding: 15px; margin-bottom: 20px; border-radius: 15px; backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); }
        .nav-link { color: rgba(255,255,255,0.8); text-decoration: none; padding: 10px 18px; background: rgba(255,255,255,0.05); border-radius: 10px; transition: all 0.3s; font-weight: 500; border: 1px solid rgba(255,255,255,0.1); display: inline-block; margin: 0 5px; }
        .nav-link:hover { background: rgba(255,255,255,0.15); }
        .nav-link.active { color: #00ff88; background: rgba(0,255,136,0.15); border-color: rgba(0,255,136,0.3); }
        .header { text-align: center; padding: 40px; background: rgba(255,255,255,0.08); border-radius: 20px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .header h1 { font-size: 3em; font-weight: 800; margin-bottom: 10px; background: linear-gradient(45deg, #00ff88, #00d4aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .controls { background: rgba(255,255,255,0.08); border-radius: 20px; padding: 25px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .control-group label { display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #00ff88; }
        input[type="number"], select { width: 100%; padding: 12px; border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; background: rgba(255,255,255,0.1); color: white; font-size: 14px; }
        .session-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px; }
        .session-item { display: flex; align-items: center; gap: 8px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; }
        .session-item input { width: 16px; height: 16px; accent-color: #00ff88; }
        .btn { background: linear-gradient(45deg, #00ff88, #00d4aa); border: none; padding: 15px 40px; border-radius: 12px; color: white; font-weight: 700; cursor: pointer; font-size: 16px; box-shadow: 0 4px 15px rgba(0,255,136,0.3); transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,255,136,0.4); }
        .section { background: rgba(255,255,255,0.08); border-radius: 20px; padding: 30px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .section-title { font-size: 24px; font-weight: 800; color: #00ff88; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 25px; }
        .metric-card { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; text-align: center; }
        .metric-value { font-size: 32px; font-weight: 700; margin: 10px 0; background: linear-gradient(45deg, #00ff88, #00d4aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .metric-label { font-size: 12px; text-transform: uppercase; opacity: 0.8; font-weight: 600; }
        .strategy-box { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #00ff88; }
        .detail-row { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .detail-label { opacity: 0.8; }
        .detail-value { font-weight: 600; color: #00ff88; }
        .warning-box { background: rgba(255,71,87,0.1); border: 1px solid rgba(255,71,87,0.3); border-radius: 12px; padding: 15px; margin-top: 20px; color: #ff4757; }
        .success-box { background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 12px; padding: 15px; margin-top: 20px; color: #00ff88; }
        .comparison-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .comparison-table th { background: rgba(0,255,136,0.1); padding: 12px; text-align: left; font-weight: 600; color: #00ff88; border-bottom: 2px solid rgba(0,255,136,0.3); }
        .comparison-table td { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .comparison-table tr:hover { background: rgba(255,255,255,0.05); cursor: pointer; }
        .loading { text-align: center; padding: 60px; font-size: 18px; color: rgba(255,255,255,0.7); }
        .time-window { background: rgba(58,123,213,0.1); border: 1px solid rgba(58,123,213,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
        .ml-insight { background: rgba(102,126,234,0.1); border: 1px solid rgba(102,126,234,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
        .gpt-insight { background: rgba(255,165,2,0.1); border: 1px solid rgba(255,165,2,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; }
    </style>
</head>
<body>
    <nav class="navbar">
        <div style="display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap;">
            <a href="/ml-dashboard" class="nav-link">ü§ñ ML</a>
            <a href="/live-signals-dashboard" class="nav-link">üì∂ Live</a>
            <a href="/signal-lab-dashboard" class="nav-link">üè† Dashboard</a>
            <a href="/signal-analysis-lab" class="nav-link">üß™ Signal Lab</a>
            <a href="/time-analysis" class="nav-link">‚è∞ Time</a>
            <a href="/strategy-optimizer" class="nav-link active">üéØ Optimizer</a>
            <a href="/ai-business-advisor" class="nav-link">üß† AI Advisor</a>
            <a href="/prop-portfolio" class="nav-link">üíº Prop</a>
            <a href="/trade-manager" class="nav-link">üìã Trades</a>
            <a href="/financial-summary" class="nav-link">üí∞ Finance</a>
            <a href="/reporting-hub" class="nav-link">üìä Reports</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>üéØ Strategy Optimizer</h1>
            <p>Unified analysis: TIME + ML + GPT-4 + Prop Firm Constraints</p>
        </div>
        
        <div class="controls">
            <h3 style="color: #00ff88; margin-bottom: 20px;">üö® Prop Firm Constraints</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label>Max Daily Loss (%)</label>
                    <input type="number" id="maxDailyLoss" value="5" min="1" max="10" step="0.5">
                </div>
                <div class="control-group">
                    <label>Max Total Drawdown (%)</label>
                    <input type="number" id="maxDrawdown" value="10" min="5" max="20" step="1">
                </div>
                <div class="control-group">
                    <label>Min Win Rate (%)</label>
                    <input type="number" id="minWinRate" value="40" min="0" max="100" step="5">
                </div>
            </div>
            
            <h3 style="color: #00ff88; margin: 20px 0;">‚è∞ Session Selection</h3>
            <div class="session-grid">
                <div class="session-item"><input type="checkbox" id="sessAsia" value="Asia" checked><label for="sessAsia">Asia</label></div>
                <div class="session-item"><input type="checkbox" id="sessLondon" value="London" checked><label for="sessLondon">London</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYPre" value="NY Pre Market" checked><label for="sessNYPre">NY Pre</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYAM" value="NY AM" checked><label for="sessNYAM">NY AM</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYLunch" value="NY Lunch" checked><label for="sessNYLunch">NY Lunch</label></div>
                <div class="session-item"><input type="checkbox" id="sessNYPM" value="NY PM" checked><label for="sessNYPM">NY PM</label></div>
            </div>
            <div style="margin-top: 15px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="useOptimalHours" style="width: 16px; height: 16px; accent-color: #00ff88;">
                    <span style="color: #00ff88; font-weight: 600;">Use optimal time windows only</span>
                </label>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn" onclick="runUnifiedOptimization()">üöÄ Find Optimal Strategy (All Methods)</button>
            </div>
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        let signals = [];
        
        async function loadSignals() {
            try {
                const response = await fetch('https://web-production-cd33.up.railway.app/api/signal-lab-trades?analysis_only=true');
                if (!response.ok) throw new Error('Failed to load data');
                const data = await response.json();
                const trades = Array.isArray(data) ? data : data.trades || [];
                signals = trades.filter(t => { const d = new Date(t.date); return d.getDay() !== 0 && d.getDay() !== 6; })
                    .map(t => ({ date: t.date, time: t.time, session: t.session, mfeNone: parseFloat(t.mfe_none || t.mfe) || 0, mfe1: parseFloat(t.mfe1) || 0 }));
                console.log(`Loaded ${signals.length} signals`);
            } catch (error) {
                console.error('Error loading signals:', error);
                document.getElementById('results').innerHTML = `<div class="warning-box">Failed to load data: ${error.message}</div>`;
            }
        }
        
        function getSelectedSessions() {
            return ['sessAsia', 'sessLondon', 'sessNYPre', 'sessNYAM', 'sessNYLunch', 'sessNYPM']
                .filter(id => document.getElementById(id).checked).map(id => document.getElementById(id).value);
        }
        
        function calculateTradeResult(signal, beStrategy, rTarget) {
            const mfe = beStrategy === 'be1' ? signal.mfe1 : signal.mfeNone;
            if (!mfe || mfe === 0) return -1;
            if (beStrategy === 'none') return mfe < 0 ? -1 : (mfe >= rTarget ? rTarget : -1);
            if (mfe < 1) return -1;
            if (mfe >= 1 && mfe < rTarget) return 0;
            if (mfe >= rTarget) return rTarget;
            return -1;
        }
        
        function calculateStats(results) {
            const wins = results.filter(r => r > 0).length;
            const losses = results.filter(r => r < 0).length;
            const breakevens = results.filter(r => r === 0).length;
            const total = results.length;
            const winRate = total > 0 ? ((wins + breakevens) / total) * 100 : 0;
            const totalR = results.reduce((sum, r) => sum + r, 0);
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const expectancy = total > 0 ? totalR / total : 0;
            let maxConsecLosses = 0, currentConsecLosses = 0, maxDrawdown = 0, currentDrawdown = 0, peak = 0, runningTotal = 0;
            results.forEach(result => {
                runningTotal += result;
                if (runningTotal > peak) { peak = runningTotal; currentDrawdown = 0; }
                else { currentDrawdown = peak - runningTotal; maxDrawdown = Math.max(maxDrawdown, currentDrawdown); }
                if (result < 0) { currentConsecLosses++; maxConsecLosses = Math.max(maxConsecLosses, currentConsecLosses); }
                else if (result > 0) currentConsecLosses = 0;
            });
            return { expectancy, winRate, totalR, maxConsecLosses, maxDrawdown, total };
        }
        
        async function loadTimeAnalysis() {
            try {
                const response = await fetch('https://web-production-cd33.up.railway.app/api/time-analysis');
                if (!response.ok) return {};
                const data = await response.json();
                return {
                    hourly: data.hourly || [],
                    session: data.session || [],
                    bestHour: data.best_hour || {},
                    bestSession: data.best_session || {}
                };
            } catch (error) {
                console.error('Time analysis load failed:', error);
                return {};
            }
        }
        
        async function getMLPrediction(session) {
            try {
                const response = await fetch('https://web-production-cd33.up.railway.app/api/ml-insights');
                if (!response.ok) return null;
                const data = await response.json();
                if (data.performance && data.performance.is_trained) {
                    return { trained: true, accuracy: data.performance.performance_metrics ? 
                        Math.max(...Object.values(data.performance.performance_metrics).map(m => m.test_r2 * 100)) : 0 };
                }
                return { trained: false };
            } catch (error) { return null; }
        }
        
        async function getGPT4Analysis(bestCombo) {
            try {
                const sessionsText = bestCombo.sessions.join(', ');
                const prompt = `Analyze this optimal NQ trading strategy:\nSessions: ${sessionsText}\nBE: ${bestCombo.beStrategy}\nR-Target: ${bestCombo.rTarget}R\nExpectancy: ${bestCombo.stats.expectancy.toFixed(3)}R\nWin Rate: ${bestCombo.stats.winRate.toFixed(1)}%\n\nProvide: 1) Why this works 2) Session-specific tips 3) Risk management advice. Keep under 150 words.`;
                const response = await fetch('https://web-production-cd33.up.railway.app/api/ai-insights', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, data: {} })
                });
                if (!response.ok) return null;
                const data = await response.json();
                return data.insight || null;
            } catch (error) { return null; }
        }
        
        async function runUnifiedOptimization() {
            if (signals.length === 0) { await loadSignals(); if (signals.length === 0) return; }
            document.getElementById('results').innerHTML = '<div class="loading">üîÑ Running unified analysis (TIME + ML + GPT-4)...</div>';
            
            const constraints = {
                maxDailyLoss: parseFloat(document.getElementById('maxDailyLoss').value),
                maxDrawdown: parseFloat(document.getElementById('maxDrawdown').value),
                minWinRate: parseFloat(document.getElementById('minWinRate').value)
            };
            
            const riskLevels = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0];
            const resultsByRisk = {};
            
            const selectedSessions = getSelectedSessions();
            const useOptimalHours = document.getElementById('useOptimalHours').checked;
            
            // Calculate optimal time windows (best hour per session) - declare at function scope
            let optimalTimeWindows = {};
            let filteredSignals = signals;
            
            const beStrategies = ['none', 'be1'];
            
            if (useOptimalHours) {
                // Calculate optimal hours for EACH BE/R combination to match what will be tested
                const allOptimalWindows = {};
                
                beStrategies.forEach(beStrategy => {
                    riskLevels.forEach(riskPerTrade => {
                        const maxPossibleR = Math.floor(constraints.maxDailyLoss / riskPerTrade);
                        for (let r = 1; r <= maxPossibleR; r += 0.5) {
                            const key = `${beStrategy}_${r}`;
                            if (!allOptimalWindows[key]) allOptimalWindows[key] = {};
                            
                            selectedSessions.forEach(session => {
                                const sessionSignals = signals.filter(s => s.session === session);
                                const hourlyPerf = {};
                                sessionSignals.forEach(s => {
                                    if (!s.time) return;
                                    const hour = parseInt(s.time.split(':')[0]);
                                    if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                                    hourlyPerf[hour].push(s);
                                });
                                const hourlyStats = Object.entries(hourlyPerf)
                                    .map(([hour, sigs]) => {
                                        if (sigs.length < 3) return null;
                                        const results = sigs.map(s => calculateTradeResult(s, beStrategy, r));
                                        const stats = calculateStats(results);
                                        return { hour: parseInt(hour), expectancy: stats.expectancy };
                                    })
                                    .filter(h => h !== null)
                                    .sort((a, b) => b.expectancy - a.expectancy);
                                if (hourlyStats.length > 0) allOptimalWindows[key][session] = [hourlyStats[0]];
                            });
                        }
                    });
                });
                
                optimalTimeWindows = allOptimalWindows;
                
                // Filter signals to only optimal time windows
                filteredSignals = signals.filter(signal => {
                    const sessionWindows = optimalTimeWindows[signal.session];
                    if (!sessionWindows || sessionWindows.length === 0) return false;
                    const hour = signal.time ? parseInt(signal.time.split(':')[0]) : null;
                    if (hour === null) return false;
                    return sessionWindows.some(w => hour === w.hour);
                });
            }
            
            riskLevels.forEach(riskPerTrade => {
                const maxPossibleR = Math.floor(constraints.maxDailyLoss / riskPerTrade);
                const rTargets = [];
                for (let r = 1; r <= maxPossibleR; r += 0.5) rTargets.push(r);
                let allCombinations = [], bestOverall = null, bestScore = -999;
                
                beStrategies.forEach(beStrategy => {
                    rTargets.forEach(rTarget => {
                        selectedSessions.forEach(session => {
                            const key = `${beStrategy}_${rTarget}`;
                            const windowsForCombo = optimalTimeWindows[key] || {};
                            
                            let sessionSignals = signals.filter(s => s.session === session);
                            if (useOptimalHours && windowsForCombo[session]) {
                                sessionSignals = sessionSignals.filter(s => {
                                    const hour = s.time ? parseInt(s.time.split(':')[0]) : null;
                                    if (hour === null) return false;
                                    return windowsForCombo[session].some(w => hour === w.hour);
                                });
                            }
                            if (sessionSignals.length < 30) return;
                            const results = sessionSignals.map(s => calculateTradeResult(s, beStrategy, rTarget));
                            const stats = calculateStats(results);
                            const maxDailyLossPercent = stats.maxConsecLosses * riskPerTrade;
                            const maxDrawdownPercent = stats.maxDrawdown * riskPerTrade;
                            const propViable = maxDailyLossPercent <= constraints.maxDailyLoss && 
                                             maxDrawdownPercent <= constraints.maxDrawdown && 
                                             stats.winRate >= constraints.minWinRate;
                            if (!propViable) return;
                            const avgRPerTrade = stats.totalR / stats.total;
                            const sharpe = stats.expectancy / (stats.maxDrawdown > 0 ? stats.maxDrawdown : 1);
                            const score = (stats.expectancy * 40) + (stats.winRate / 100 * 20) + (avgRPerTrade * 15) + (sharpe * 10) + (Math.log(stats.total) * 5);
                            const combo = { sessions: [session], beStrategy, rTarget, stats, score, maxDailyLossPercent, maxDrawdownPercent, avgRPerTrade, riskPerTrade, optimalWindows: optimalTimeWindows, signals: sessionSignals };
                            allCombinations.push(combo);
                            if (score > bestScore) { bestScore = score; bestOverall = combo; }
                        });
                    });
                });
                
                beStrategies.forEach(beStrategy => {
                    rTargets.forEach(rTarget => {
                        for (let i = 0; i < selectedSessions.length; i++) {
                            for (let j = i + 1; j < selectedSessions.length; j++) {
                                const sessionPair = [selectedSessions[i], selectedSessions[j]];
                                const key = `${beStrategy}_${rTarget}`;
                                const windowsForCombo = optimalTimeWindows[key] || {};
                                
                                let combinedSignals = signals.filter(s => sessionPair.includes(s.session));
                                if (useOptimalHours) {
                                    combinedSignals = combinedSignals.filter(s => {
                                        const sessionWindows = windowsForCombo[s.session];
                                        if (!sessionWindows) return false;
                                        const hour = s.time ? parseInt(s.time.split(':')[0]) : null;
                                        if (hour === null) return false;
                                        return sessionWindows.some(w => hour === w.hour);
                                    });
                                }
                                if (combinedSignals.length < 50) continue;
                                const results = combinedSignals.map(s => calculateTradeResult(s, beStrategy, rTarget));
                                const stats = calculateStats(results);
                                const maxDailyLossPercent = stats.maxConsecLosses * riskPerTrade;
                                const maxDrawdownPercent = stats.maxDrawdown * riskPerTrade;
                                const propViable = maxDailyLossPercent <= constraints.maxDailyLoss && 
                                                 maxDrawdownPercent <= constraints.maxDrawdown && 
                                                 stats.winRate >= constraints.minWinRate;
                                if (!propViable) continue;
                                const avgRPerTrade = stats.totalR / stats.total;
                                const sharpe = stats.expectancy / (stats.maxDrawdown > 0 ? stats.maxDrawdown : 1);
                                const score = (stats.expectancy * 40) + (stats.winRate / 100 * 20) + (avgRPerTrade * 15) + (sharpe * 10) + (Math.log(stats.total) * 5);
                                const combo = { sessions: sessionPair, beStrategy, rTarget, stats, score, maxDailyLossPercent, maxDrawdownPercent, avgRPerTrade, riskPerTrade, optimalWindows: optimalTimeWindows, signals: combinedSignals };
                                allCombinations.push(combo);
                                if (score > bestScore) { bestScore = score; bestOverall = combo; }
                            }
                        }
                    });
                });
                
                if (bestOverall) {
                    allCombinations.sort((a, b) => b.score - a.score);
                    resultsByRisk[riskPerTrade] = { best: bestOverall, alternatives: allCombinations.slice(0, 5) };
                }
            });
            
            if (Object.keys(resultsByRisk).length === 0) {
                document.getElementById('results').innerHTML = '<div class="warning-box"><strong>‚ùå No viable strategy found</strong><br>All combinations violate prop firm constraints.</div>';
                return;
            }
            
            const timeWindows = await loadTimeAnalysis();
            const mlPrediction = await getMLPrediction();
            
            displayRiskBasedResults(resultsByRisk, timeWindows, mlPrediction, constraints);
            
            // Store strategy data for chart rendering
            Object.entries(resultsByRisk).forEach(([risk, data]) => {
                const riskId = risk.toString().replace('.', '_');
                strategyData[riskId] = {
                    signals: data.best.signals,
                    beStrategy: data.best.beStrategy,
                    rTarget: data.best.rTarget
                };
            });
        }
        
        function displayRiskBasedResults(resultsByRisk, timeWindows, mlPrediction, constraints) {
            const beText = { 'none': 'No Breakeven', 'be1': 'Breakeven at 1R' };
            
            let timeHtml = '';
            if (timeWindows.session && timeWindows.session.length > 0) {
                timeHtml = '<div class="time-window"><strong>‚è∞ Time Analysis (from /api/time-analysis):</strong><br>';
                timeWindows.session.slice(0, 3).forEach(s => {
                    const exp = typeof s.expectancy === 'number' ? s.expectancy : parseFloat(s.expectancy) || 0;
                    const wr = typeof s.win_rate === 'number' ? s.win_rate : parseFloat(s.win_rate) || 0;
                    timeHtml += `${s.session}: ${exp.toFixed(3)}R expectancy, ${(wr * 100).toFixed(1)}% win rate (${s.trades} trades)<br>`;
                });
                if (timeWindows.bestHour && timeWindows.bestHour.hour) {
                    const exp = typeof timeWindows.bestHour.expectancy === 'number' ? timeWindows.bestHour.expectancy : parseFloat(timeWindows.bestHour.expectancy) || 0;
                    timeHtml += `<br>Best Hour: ${timeWindows.bestHour.hour}:00 (${exp.toFixed(3)}R)`;
                }
                timeHtml += '</div>';
            }
            
            const mlHtml = mlPrediction && mlPrediction.trained ? 
                `<div class="ml-insight"><strong>ü§ñ ML Analysis:</strong> Models trained (${mlPrediction.accuracy.toFixed(1)}% accuracy)</div>` : '';
            
            let html = '<div class="section"><div class="section-title">üìä OPTIMAL STRATEGY BY RISK LEVEL</div>';
            
            Object.entries(resultsByRisk).forEach(([risk, data]) => {
                const best = data.best;
                const sessionsText = best.sessions.join(' + ');
                const totalPercent = best.stats.totalR * best.riskPerTrade;
                
                const optimalHoursText = best.sessions.map(session => {
                    const windows = best.optimalWindows?.[session];
                    if (windows && windows.length > 0) {
                        return `${session}: ${windows[0].hour}:00`;
                    }
                    return `${session}: All hours`;
                }).join(' | ');
                
                const riskId = risk.toString().replace('.', '_');
                
                html += `
                    <div class="strategy-box" style="margin-bottom: 30px;">
                        <h4 style="color: #00ff88; margin-bottom: 15px;">üéØ Risk ${risk}% Per Trade</h4>
                        <div class="metrics-grid">
                            <div class="metric-card"><div class="metric-label">Sessions</div><div class="metric-value" style="font-size: 18px;">${sessionsText}</div></div>
                            <div class="metric-card"><div class="metric-label">Strategy</div><div class="metric-value" style="font-size: 18px;">${beText[best.beStrategy]}</div></div>
                            <div class="metric-card"><div class="metric-label">R-Target</div><div class="metric-value">${best.rTarget}R</div></div>
                            <div class="metric-card"><div class="metric-label">Expectancy</div><div class="metric-value">${best.stats.expectancy.toFixed(3)}R</div></div>
                            <div class="metric-card"><div class="metric-label">Win Rate</div><div class="metric-value">${best.stats.winRate.toFixed(1)}%</div></div>
                            <div class="metric-card"><div class="metric-label">Total Return</div><div class="metric-value">${totalPercent > 0 ? '+' : ''}${totalPercent.toFixed(1)}%</div></div>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <strong>Risk Metrics:</strong> Max Daily Loss: ${best.maxDailyLossPercent.toFixed(1)}% | Max Drawdown: ${best.maxDrawdownPercent.toFixed(1)}% | Trades: ${best.stats.total}
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(58,123,213,0.1); border: 1px solid rgba(58,123,213,0.3); border-radius: 8px;">
                            <strong>‚è∞ Optimal Trading Hours:</strong> ${optimalHoursText}
                        </div>
                        <div style="margin-top: 15px; display: flex; gap: 10px;">
                            <button onclick="toggleChart('equity_${riskId}')" style="flex: 1; padding: 10px; background: rgba(0,255,136,0.2); border: 1px solid rgba(0,255,136,0.3); border-radius: 8px; color: #00ff88; cursor: pointer; font-weight: 600;">üìà Toggle Equity Curve</button>
                            <button onclick="toggleChart('calendar_${riskId}')" style="flex: 1; padding: 10px; background: rgba(255,165,2,0.2); border: 1px solid rgba(255,165,2,0.3); border-radius: 8px; color: #ffa502; cursor: pointer; font-weight: 600;">üìÖ Toggle Calendar</button>
                        </div>
                        <div id="equity_${riskId}" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 12px;">
                            <div style="height: 400px; width: 100%;" id="equity_chart_${riskId}"></div>
                        </div>
                        <div id="calendar_${riskId}" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 12px;">
                            <div id="calendar_content_${riskId}"></div>
                        </div>
                    </div>
                `;
            });
            
            html += timeHtml + mlHtml;
            
            html += '<table class="comparison-table" style="margin-top: 30px;"><thead><tr><th>Risk %</th><th>Sessions</th><th>BE</th><th>R-Target</th><th>Expectancy</th><th>Win Rate</th><th>Total Return</th><th>Max DD</th></tr></thead><tbody>';
            Object.entries(resultsByRisk).forEach(([risk, data]) => {
                const b = data.best;
                html += `<tr><td>${risk}%</td><td>${b.sessions.join('+')}</td><td>${beText[b.beStrategy]}</td><td>${b.rTarget}R</td><td>${b.stats.expectancy.toFixed(3)}R</td><td>${b.stats.winRate.toFixed(1)}%</td><td>${(b.stats.totalR * b.riskPerTrade).toFixed(1)}%</td><td>${b.maxDrawdownPercent.toFixed(1)}%</td></tr>`;
            });
            html += '</tbody></table></div>';
            
            document.getElementById('results').innerHTML = html;
        }
        
        let strategyData = {};
        
        function toggleChart(chartId) {
            const el = document.getElementById(chartId);
            if (el.style.display === 'none') {
                el.style.display = 'block';
                const riskId = chartId.split('_').slice(1).join('_');
                const data = strategyData[riskId];
                if (!data) return;
                
                if (chartId.startsWith('equity_')) {
                    renderEquityCurve(riskId, data);
                } else if (chartId.startsWith('calendar_')) {
                    renderCalendar(riskId, data);
                }
            } else {
                el.style.display = 'none';
            }
        }
        
        function renderEquityCurve(riskId, data) {
            const container = document.getElementById(`equity_chart_${riskId}`);
            container.innerHTML = '';
            
            const results = data.signals.map(s => calculateTradeResult(s, data.beStrategy, data.rTarget));
            let cumulative = 0;
            const equityData = results.map((r, i) => {
                cumulative += r;
                return { index: i + 1, equity: cumulative, result: r };
            });
            
            const width = container.offsetWidth || 800;
            const height = 400;
            const margin = {top: 20, right: 30, bottom: 40, left: 60};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            const svg = d3.select(container).append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', 'rgba(0,0,0,0.2)')
                .style('border-radius', '8px');
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleLinear()
                .domain([0, equityData.length])
                .range([0, innerWidth]);
            
            const yScale = d3.scaleLinear()
                .domain([d3.min(equityData, d => d.equity) - 2, d3.max(equityData, d => d.equity) + 2])
                .range([innerHeight, 0]);
            
            const line = d3.line()
                .x(d => xScale(d.index))
                .y(d => yScale(d.equity))
                .curve(d3.curveMonotoneX);
            
            const area = d3.area()
                .x(d => xScale(d.index))
                .y0(innerHeight)
                .y1(d => yScale(d.equity))
                .curve(d3.curveMonotoneX);
            
            g.append('path')
                .datum(equityData)
                .attr('fill', 'url(#gradient)')
                .attr('d', area)
                .style('opacity', 0.3);
            
            const gradient = svg.append('defs').append('linearGradient')
                .attr('id', 'gradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '0%').attr('y2', '100%');
            gradient.append('stop').attr('offset', '0%').attr('stop-color', '#00ff88').attr('stop-opacity', 0.8);
            gradient.append('stop').attr('offset', '100%').attr('stop-color', '#00ff88').attr('stop-opacity', 0.1);
            
            g.append('path')
                .datum(equityData)
                .attr('fill', 'none')
                .attr('stroke', '#00ff88')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            g.append('g')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(d3.axisBottom(xScale).ticks(10))
                .style('color', '#fff');
            
            g.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d => d + 'R'))
                .style('color', '#fff');
            
            g.append('text')
                .attr('x', innerWidth / 2)
                .attr('y', innerHeight + 35)
                .attr('text-anchor', 'middle')
                .style('fill', '#fff')
                .text('Trade Number');
            
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -innerHeight / 2)
                .attr('y', -45)
                .attr('text-anchor', 'middle')
                .style('fill', '#fff')
                .text('Cumulative R');
        }
        
        function renderCalendar(riskId, data) {
            const container = document.getElementById(`calendar_content_${riskId}`);
            const dailyResults = {};
            
            data.signals.forEach(s => {
                if (!dailyResults[s.date]) dailyResults[s.date] = [];
                dailyResults[s.date].push(calculateTradeResult(s, data.beStrategy, data.rTarget));
            });
            
            const dailyTotals = {};
            Object.entries(dailyResults).forEach(([date, results]) => {
                dailyTotals[date] = {
                    total: results.reduce((sum, r) => sum + r, 0),
                    count: results.length
                };
            });
            
            const dates = Object.keys(dailyTotals).sort();
            if (dates.length === 0) return;
            
            const startDate = new Date(dates[0]);
            const endDate = new Date(dates[dates.length - 1]);
            const startMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
            const endMonth = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
            
            let html = '';
            let currentDate = new Date(startMonth);
            
            while (currentDate <= endMonth) {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const monthName = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });
                
                html += `<div style="margin-bottom: 30px;"><h4 style="color: #00ff88; margin-bottom: 15px;">${monthName}</h4>`;
                html += '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; margin-bottom: 10px;">';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Sun</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Mon</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Tue</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Wed</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Thu</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Fri</div>';
                html += '<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">Sat</div>';
                html += '</div>';
                
                html += '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px;">';
                
                const firstDay = new Date(year, month, 1).getDay();
                for (let i = 0; i < firstDay; i++) {
                    html += '<div></div>';
                }
                
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const dayData = dailyTotals[dateStr];
                    const dayOfWeek = new Date(year, month, day).getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    
                    if (dayData) {
                        const intensity = Math.min(Math.abs(dayData.total) / 5, 1);
                        const bgColor = dayData.total > 0 ? 
                            `rgba(0, 255, 136, ${0.3 + intensity * 0.7})` : 
                            `rgba(255, 71, 87, ${0.3 + intensity * 0.7})`;
                        html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 10px; text-align: center; border: 2px solid rgba(255,255,255,0.1); cursor: pointer; transition: all 0.3s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">`;
                        html += `<div style="font-size: 11px; opacity: 0.8; margin-bottom: 4px;">${day}</div>`;
                        html += `<div style="font-weight: 700; font-size: 16px; margin-bottom: 2px;">${dayData.total > 0 ? '+' : ''}${dayData.total.toFixed(1)}R</div>`;
                        html += `<div style="font-size: 10px; opacity: 0.7;">${dayData.count} trades</div>`;
                        html += '</div>';
                    } else {
                        const bgColor = isWeekend ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.05)';
                        html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.05);">`;
                        html += `<div style="font-size: 11px; opacity: 0.4;">${day}</div>`;
                        html += '</div>';
                    }
                }
                
                html += '</div></div>';
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            
            container.innerHTML = html;
        }
        
        document.addEventListener('DOMContentLoaded', () => { loadSignals(); });
    </script>
</body>
</html>
