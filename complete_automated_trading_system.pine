//@version=5
strategy("NQ_FVG_CORE_TELEMETRY_V1", overlay=true, initial_capital=100000, default_qty_type=strategy.cash, commission_type=strategy.commission.cash_per_contract, commission_value=2.40, max_lines_count=500, max_labels_count=500, max_bars_back=5000, calc_on_every_tick=false, process_orders_on_close=true)

// ============================================================================
// EVENT TYPE CONSTANTS (DO NOT CHANGE - MUST MATCH DATABASE)
// ============================================================================
EVENT_SIGNAL_CREATED   = "SIGNAL_CREATED"     // triangle appears (before confirmation)
EVENT_ENTRY            = "ENTRY"
EVENT_MFE_UPDATE       = "MFE_UPDATE"
EVENT_BE_TRIGGERED     = "BE_TRIGGERED"
EVENT_EXIT_BREAK_EVEN  = "EXIT_BREAK_EVEN"
EVENT_EXIT_STOP_LOSS   = "EXIT_STOP_LOSS"
EVENT_EXIT_TAKE_PROFIT = "EXIT_TAKE_PROFIT"   // reserved for TP exits
EVENT_EXIT_PARTIAL     = "EXIT_PARTIAL"        // reserved for partial exits
EVENT_CANCELLED        = "CANCELLED"           // signal never confirmed (opposite signal before confirmation)



// ============================================================================
// ACCOUNT & RISK SETTINGS
// ============================================================================

account_size = input.float(100000, "Account Size ($)", group="Risk Management")
risk_percent = input.float(1.0, "Risk Per Trade (%)", minval=0.1, maxval=100, step=0.1, group="Risk Management")
buffer_points = input.float(0.25, "Stop Loss Buffer (Points)", minval=0.01, step=0.01, group="Risk Management")

// SIGNAL LIST VIEWER (Confirmed Signals)
SHOW_SIGNAL_LIST = input.bool(false, "Show Confirmed Signals Table", group="Signal List Viewer", tooltip="Display table of confirmed signals")
SIGNAL_LIST_FILTER = input.string("ALL", "Filter", options=["ALL", "ACTIVE", "COMPLETED"], group="Signal List Viewer", tooltip="Show all signals, only active, or only completed")
SIGNAL_LIST_START = input.int(0, "Start Index (Page)", minval=0, step=20, group="Signal List Viewer", tooltip="Which signal to start from (0=first page, 20=page 2, 40=page 3, etc.)")
SIGNAL_LIST_COUNT = input.int(20, "Signals Per Page", minval=5, maxval=20, group="Signal List Viewer")
SIGNAL_LIST_POSITION = input.string("middle_right", "Table Position", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="Signal List Viewer")

// ALL SIGNALS VIEWER (Every Triangle)
SHOW_ALL_SIGNALS = input.bool(false, "Show All Signals Table", group="All Signals Viewer", tooltip="Display table of every triangle (pending, confirmed, cancelled)")
ALL_SIGNALS_FILTER = input.string("LATEST_40", "Filter", options=["LATEST_40", "ACTIVE_BE", "ACTIVE_ALL", "ALL", "PENDING", "CONFIRMED", "CANCELLED", "COMPLETED"], group="All Signals Viewer", tooltip="LATEST_40=Last 40 signals, ACTIVE_BE=Active with BE+1R, ACTIVE_ALL=All active signals")
ALL_SIGNALS_START = input.int(0, "Start Index (Page)", minval=0, step=50, group="All Signals Viewer")
ALL_SIGNALS_COUNT = input.int(50, "Signals Per Page", minval=5, maxval=50, group="All Signals Viewer")
ALL_SIGNALS_POSITION = input.string("middle_left", "Table Position", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="All Signals Viewer")
ALL_SIGNALS_FONT_SIZE = input.string("Tiny", "Font Size", options=["Tiny", "Small", "Normal"], group="All Signals Viewer")

// ARRAY RESET - Change this number to force rebuild (1, 2, 3, etc.)
ARRAY_VERSION = input.int(1, "Array Version (change to reset)", minval=1, group="Debug", tooltip="Change this number (1‚Üí2‚Üí3) to force array reset and rebuild with fixed MFE logic")

// MFE RECALCULATION - Force recalculate ALL MFE from chart history
RECALCULATE_MFE = input.bool(false, "üîÑ Recalculate All MFE", group="Debug", tooltip="Scan entire chart history and recalculate MFE for ALL signals. Turn ON, wait for completion, turn OFF. May take 2-3 minutes.")

// BULK EXPORT - Export all signals to backend
ENABLE_EXPORT = input.bool(false, "üì§ Export Confirmed Signals", group="Export", tooltip="Export confirmed signals with entry/stop/MFE data. Turn ON, wait for completion, turn OFF.")
ENABLE_ALL_SIGNALS_EXPORT = input.bool(false, "üì§ Export All Signals", group="Export", tooltip="Export every triangle (pending, confirmed, cancelled). Run AFTER confirmed signals export.")
ENABLE_LIVE_CONFIRMED_EXPORT = input.bool(true, "‚ö° Live Confirmed Export (per trade)", group="Export", tooltip="Send ONE confirmed signal immediately when entry bar begins (realtime only)")
EXPORT_DELAY_BARS = input.int(5, "Delay Between Batches (bars)", minval=0, maxval=10, group="Export", tooltip="5 = wait 5 minutes between batches (recommended), 0 = send immediately (may hit rate limits)")

// AUTO-DETECT CONTRACT TYPE AND POINT VALUE
auto_detect_contract = input.bool(true, "Auto-Detect Contract Type", tooltip="Automatically detect contract type from chart symbol", group="Risk Management")
manual_point_value = input.float(20.0, "Manual Point Value ($)", minval=0.1, tooltip="Only used if Auto-Detect is OFF", group="Risk Management")

// Automatic point value detection based on symbol
get_point_value() =>
    string ticker = syminfo.ticker
    float detected_value = 20.0  // Default to NQ
    
    // NASDAQ contracts
    if str.contains(ticker, "MNQ")
        detected_value := 2.0   // Micro NQ
    else if str.contains(ticker, "NQ")
        detected_value := 20.0  // Standard NQ
    
    // S&P 500 contracts
    else if str.contains(ticker, "MES")
        detected_value := 5.0   // Micro ES
    else if str.contains(ticker, "ES")
        detected_value := 50.0  // Standard ES
    
    // Dow Jones contracts
    else if str.contains(ticker, "MYM")
        detected_value := 0.5   // Micro YM
    else if str.contains(ticker, "YM")
        detected_value := 5.0   // Standard YM
    
    // Russell 2000 contracts
    else if str.contains(ticker, "M2K")
        detected_value := 5.0   // Micro RTY
    else if str.contains(ticker, "RTY")
        detected_value := 50.0  // Standard RTY
    
    detected_value

point_value = auto_detect_contract ? get_point_value() : manual_point_value

// ============================================================================
// FVG INDICATOR SETTINGS (YOUR EXACT SETTINGS)
// ============================================================================

// HTF Timeframe selection (all OFF by default for maximum performance)
use_daily = input.bool(false, "Daily", group="HTF Bias Filter")
use_4h = input.bool(false, "4H", group="HTF Bias Filter")
use_1h = input.bool(false, "1H", group="HTF Bias Filter")
use_15m = input.bool(false, "15M", group="HTF Bias Filter")
use_5m = input.bool(false, "5M", group="HTF Bias Filter")

// Engulfing Filters
require_engulfing = input.bool(false, "FVG + Engulfing Only", group="Signal Filter")
require_sweep_engulfing = input.bool(false, "FVG + Sweep Engulfing Only", group="Signal Filter")

// Visual settings
show_htf_status = input.bool(false, "Show HTF Status", group="Display", tooltip="‚ö†Ô∏è Disable for better performance (table updates every bar)")
show_position_table = input.bool(false, "Show Position Sizing Table", group="Display", tooltip="‚ö†Ô∏è Enable when needed (significantly slower performance)")
position_table_location = input.string("Top Left", "Position Table Location", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group="Display")
htf_aligned_only = input.bool(false, "HTF Aligned Triangles Only", group="Display", tooltip="Enable this with HTF filters for aligned signals only")
triangle_size = input.string("Small", "Triangle Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="Display")
bull_color = input.color(color.blue, "Bullish Color", group="Display")
bear_color = input.color(color.red, "Bearish Color", group="Display")
neutral_color = input.color(color.gray, "Neutral Color", group="Display")

// MFE Label Settings (disabled by default for performance)
show_mfe_labels = input.bool(false, "Show MFE Labels", group="MFE Labels", tooltip="Enable to see MFE tracking (slower performance)")
track_be_mfe = input.bool(false, "Track BE=1 MFE", group="MFE Labels", tooltip="Track MFE with breakeven at +1R (slower performance)")
show_entry_sl_lines = input.bool(false, "Show Entry/SL Lines", group="MFE Labels", tooltip="Show entry and stop loss lines for all signals (slower performance)")
mfe_label_size = input.string("Small", "MFE Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="MFE Labels")
mfe_active_color = input.color(color.new(color.yellow, 20), "Active Trade Background Color", group="MFE Labels", tooltip="Background color for active (running) trades")
mfe_active_text_color = input.color(color.black, "Active Trade Text Color", group="MFE Labels", tooltip="Text color for active (running) trades")
mfe_complete_color = input.color(color.new(color.orange, 0), "Completed Trade Background Color", group="MFE Labels", tooltip="Background color for completed (stopped out) trades")
mfe_complete_text_color = input.color(color.white, "Completed Trade Text Color", group="MFE Labels", tooltip="Text color for completed (stopped out) trades")
mfe_label_format = input.string("MFE: {mfe}R", "Label Format", group="MFE Labels", tooltip="Use {mfe} for MFE value")
max_signal_history = input.int(50, "Max Signal History", minval=20, maxval=200, step=10, group="MFE Labels", tooltip="Maximum number of signals to track (higher = more history but slower performance)")

// ============================================================================
// ENGULFING DETECTION (YOUR EXACT LOGIC)
// ============================================================================

prev_open = open[1]
prev_close = close[1]
curr_open = open
curr_close = close

bearish_engulfing = curr_close < curr_open and prev_close > prev_open and curr_open >= prev_close and curr_close < prev_open
bullish_engulfing = curr_close > curr_open and prev_close < prev_open and curr_open <= prev_close and curr_close > prev_open

bearish_sweep_engulfing = bearish_engulfing and high > high[1] and curr_close < prev_close
bullish_sweep_engulfing = bullish_engulfing and low < low[1] and curr_close > prev_close

// ============================================================================
// BIAS CALCULATION (YOUR EXACT LOGIC) - MATCHES ORIGINAL INDICATOR
// ============================================================================

get_bias() =>
    var string bias = "Neutral"
    var float ath = na
    var float atl = na
    var bull_fvg_highs = array.new<float>()
    var bull_fvg_lows = array.new<float>()
    var bear_fvg_highs = array.new<float>()
    var bear_fvg_lows = array.new<float>()
    var bull_ifvg_highs = array.new<float>()
    var bull_ifvg_lows = array.new<float>()
    var bear_ifvg_highs = array.new<float>()
    var bear_ifvg_lows = array.new<float>()

    if barstate.isconfirmed
        ath := na(ath) ? high : math.max(ath, high)
        atl := na(atl) ? low : math.min(atl, low)

        if close > ath[1] and bias != "Bullish"
            bias := "Bullish"
        else if close < atl[1] and bias != "Bearish"
            bias := "Bearish"

        c2_high = high[2]
        c2_low = low[2]
        c0_high = high
        c0_low = low

        bullish_fvg = c2_high < c0_low
        bearish_fvg = c2_low > c0_high

        if bullish_fvg
            array.push(bull_fvg_highs, c0_low)
            array.push(bull_fvg_lows, c2_high)

        if bearish_fvg
            array.push(bear_fvg_highs, c2_low)
            array.push(bear_fvg_lows, c0_high)

        if array.size(bull_fvg_highs) > 0
            for i = array.size(bull_fvg_highs) - 1 to 0
                if close < array.get(bull_fvg_lows, i)
                    array.push(bear_ifvg_highs, array.get(bull_fvg_highs, i))
                    array.push(bear_ifvg_lows, array.get(bull_fvg_lows, i))
                    array.remove(bull_fvg_highs, i)
                    array.remove(bull_fvg_lows, i)
                    bias := "Bearish"

        if array.size(bear_fvg_highs) > 0
            for i = array.size(bear_fvg_highs) - 1 to 0
                if close > array.get(bear_fvg_highs, i)
                    array.push(bull_ifvg_highs, array.get(bear_fvg_highs, i))
                    array.push(bull_ifvg_lows, array.get(bear_fvg_lows, i))
                    array.remove(bear_fvg_highs, i)
                    array.remove(bear_fvg_lows, i)
                    bias := "Bullish"

        if array.size(bear_ifvg_highs) > 0
            for i = array.size(bear_ifvg_highs) - 1 to 0
                if close > array.get(bear_ifvg_highs, i)
                    array.remove(bear_ifvg_highs, i)
                    array.remove(bear_ifvg_lows, i)
                    bias := "Bullish"

        if array.size(bull_ifvg_highs) > 0
            for i = array.size(bull_ifvg_highs) - 1 to 0
                if close < array.get(bull_ifvg_lows, i)
                    array.remove(bull_ifvg_highs, i)
                    array.remove(bull_ifvg_lows, i)
                    bias := "Bearish"

    bias

bias = get_bias()
// ALWAYS calculate HTF bias for webhook data (All Signals tab needs this)
// But only USE for filtering if enabled (chart stays 1M focused)
daily_bias = request.security(syminfo.tickerid, "1D", get_bias())
h4_bias = request.security(syminfo.tickerid, "240", get_bias())
h1_bias = request.security(syminfo.tickerid, "60", get_bias())
m15_bias = request.security(syminfo.tickerid, "15", get_bias())
m5_bias = request.security(syminfo.tickerid, "5", get_bias())

// HTF alignment
daily_bull_ok = not use_daily or daily_bias == "Bullish"
daily_bear_ok = not use_daily or daily_bias == "Bearish"
h4_bull_ok = not use_4h or h4_bias == "Bullish"
h4_bear_ok = not use_4h or h4_bias == "Bearish"
h1_bull_ok = not use_1h or h1_bias == "Bullish"
h1_bear_ok = not use_1h or h1_bias == "Bearish"
m15_bull_ok = not use_15m or m15_bias == "Bullish"
m15_bear_ok = not use_15m or m15_bias == "Bearish"
m5_bull_ok = not use_5m or m5_bias == "Bullish"
m5_bear_ok = not use_5m or m5_bias == "Bearish"

htf_bullish = daily_bull_ok and h4_bull_ok and h1_bull_ok and m15_bull_ok and m5_bull_ok
htf_bearish = daily_bear_ok and h4_bear_ok and h1_bear_ok and m15_bear_ok and m5_bear_ok

// ============================================================================
// SIGNAL GENERATION (YOUR EXACT LOGIC)
// ============================================================================

fvg_bull_signal = bias != bias[1] and bias == "Bullish" and (not htf_aligned_only or htf_bullish)
fvg_bear_signal = bias != bias[1] and bias == "Bearish" and (not htf_aligned_only or htf_bearish)

show_bull_triangle = require_sweep_engulfing ? (fvg_bull_signal and bullish_sweep_engulfing) : require_engulfing ? (fvg_bull_signal and bullish_engulfing) : fvg_bull_signal
show_bear_triangle = require_sweep_engulfing ? (fvg_bear_signal and bearish_sweep_engulfing) : require_engulfing ? (fvg_bear_signal and bearish_engulfing) : fvg_bear_signal

// ============================================================================
// PIVOT DETECTION (Supports 3-candle and 4-candle double-bottom/top pivots)
// ============================================================================

is_pivot_low(index) =>
    // Standard 3-candle pivot: low[index] < both adjacent lows
    bool is_3candle_pivot = low[index] < low[index-1] and low[index] < low[index+1]
    
    // 4-candle double-bottom pivot: two candles share equal low, flanked by higher lows
    // Check if current candle and next candle share same low, with higher lows on outside
    bool is_4candle_pivot = false
    if index >= 1 and index <= bar_index - 2
        // Pattern: [higher] [equal_low] [equal_low] [higher]
        is_4candle_pivot := low[index] == low[index+1] and low[index] < low[index-1] and low[index] < low[index+2]
    
    is_3candle_pivot or is_4candle_pivot

is_pivot_high(index) =>
    // Standard 3-candle pivot: high[index] > both adjacent highs
    bool is_3candle_pivot = high[index] > high[index-1] and high[index] > high[index+1]
    
    // 4-candle double-top pivot: two candles share equal high, flanked by lower highs
    // Check if current candle and next candle share same high, with lower highs on outside
    bool is_4candle_pivot = false
    if index >= 1 and index <= bar_index - 2
        // Pattern: [lower] [equal_high] [equal_high] [lower]
        is_4candle_pivot := high[index] == high[index+1] and high[index] > high[index-1] and high[index] > high[index+2]
    
    is_3candle_pivot or is_4candle_pivot

// ============================================================================
// POSITION SIZING & STOP LOSS AUTOMATION
// ============================================================================

var float signal_candle_high = na
var float signal_candle_low = na
var int signal_bar_index = na
var int signal_candle_time = na  // Store signal candle time for webhook
var string active_signal = "None"
var bool waiting_for_confirmation = false

var float entry_price = na
var float stop_loss_price = na
var float risk_distance = na
var int contract_size = na
var bool trade_ready = false
var bool confirmed_this_bar = false
var bool live_confirmed_sent_this_bar = false
var int mfe_batch_cursor = 0

// Multi-signal MFE tracking arrays
var array<float> signal_entries = array.new<float>()
var array<float> signal_stops = array.new<float>()
var array<float> signal_risks = array.new<float>()
var array<string> signal_directions = array.new<string>()
var array<float> signal_mfes = array.new<float>()
var array<float> signal_be_mfes = array.new<float>()  // MFE at BE=1 trigger
var array<float> signal_maes = array.new<float>()  // Global MAE in R (<= 0.0)
var array<bool> signal_be_triggered = array.new<bool>()  // Track if BE was triggered
var array<bool> signal_be_stopped = array.new<bool>()  // Track if BE=1 strategy hit entry after BE trigger (persistent)
var array<bool> signal_no_be_stopped = array.new<bool>()  // Track if No BE strategy hit original SL (persistent)
var array<bool> signal_completes = array.new<bool>()
var array<label> signal_labels = array.new<label>()
var array<int> signal_entry_times = array.new<int>()
var array<int> signal_triangle_times = array.new<int>()  // Canonical trade identity time (triangle time)
var array<float> signal_lowest_lows = array.new<float>()  // Track lowest low since signal (for bullish)
var array<float> signal_highest_highs = array.new<float>()  // Track highest high since signal (for bearish)
var array<bool> signal_has_entered = array.new<bool>()  // Track if trade has actually entered (after confirmation)
var array<int> signal_entry_bar_index = array.new<int>()  // Track bar_index when ENTRY webhook was sent
var array<bool> signal_confirmed_export_sent = array.new<bool>()  // Track if live confirmed export was sent

// ARRAY RESET LOGIC - Track version and clear when changed
var int stored_version = 0

if barstate.isfirst and ARRAY_VERSION != stored_version
    // Clear all arrays
    array.clear(signal_entries)
    array.clear(signal_stops)
    array.clear(signal_risks)
    array.clear(signal_directions)
    array.clear(signal_mfes)
    array.clear(signal_be_mfes)
    array.clear(signal_maes)
    array.clear(signal_be_triggered)
    array.clear(signal_be_stopped)
    array.clear(signal_no_be_stopped)
    array.clear(signal_completes)
    array.clear(signal_labels)
    array.clear(signal_entry_times)
    array.clear(signal_triangle_times)
    array.clear(signal_lowest_lows)
    array.clear(signal_highest_highs)
    array.clear(signal_has_entered)
    array.clear(signal_entry_bar_index)
    array.clear(signal_confirmed_export_sent)
    
    // Update stored version
    stored_version := ARRAY_VERSION

// CRITICAL: Track bar index when events occur (prevents historical webhook spam)
var array<int> signal_entry_bar = array.new<int>()  // Bar when entry confirmed
var array<int> signal_be_trigger_bar = array.new<int>()  // Bar when BE triggered (-1 if not triggered)
var array<int> signal_completion_bar = array.new<int>()  // Bar when trade completed (-1 if still active)
var array<bool> signal_entry_webhook_sent = array.new<bool>()  // Track if ENTRY webhook has been sent
var array<bool> signal_is_realtime = array.new<bool>()  // Track if signal occurred on real-time bar (eligible for webhooks)
var array<bool> signal_snapshot_sent = array.new<bool>()  // Track if one-off MFE snapshot has been sent (for non-realtime bars)

// ============================================================================
// ALL SIGNALS TRACKING (Every Triangle - Separate from Confirmed Signals)
// ============================================================================
var array<int> all_signal_times = array.new<int>()           // When triangle appeared
var array<string> all_signal_directions = array.new<string>() // Bullish/Bearish
var array<string> all_signal_status = array.new<string>()     // PENDING/CONFIRMED/CANCELLED
var array<int> all_signal_confirmation_times = array.new<int>() // When confirmed (0 if not)
var array<int> all_signal_bars_to_confirm = array.new<int>()  // Bars from signal to confirmation
var array<string> all_signal_daily_bias = array.new<string>()  // Daily bias at signal time
var array<string> all_signal_h4_bias = array.new<string>()     // 4H bias at signal time
var array<string> all_signal_h1_bias = array.new<string>()     // 1H bias at signal time
var array<string> all_signal_m15_bias = array.new<string>()    // 15M bias at signal time
var array<string> all_signal_m5_bias = array.new<string>()     // 5M bias at signal time
var array<string> all_signal_m1_bias = array.new<string>()     // 1M bias at signal time
var array<int> all_signal_confirmed_index = array.new<int>()  // Index in confirmed signals arrays (-1 if not confirmed)
var array<string> all_signal_htf_daily = array.new<string>()  // Daily bias at signal time
var array<string> all_signal_htf_4h = array.new<string>()     // 4H bias at signal time
var array<string> all_signal_htf_1h = array.new<string>()     // 1H bias at signal time
var array<string> all_signal_htf_15m = array.new<string>()    // 15M bias at signal time
var array<string> all_signal_htf_5m = array.new<string>()     // 5M bias at signal time

// ============================================================================
// TELEMETRY ENGINE STATE (Option B - Single Active Trade Lifecycle)
// ============================================================================
// Whether telemetry is currently active for an open trade
var bool telemetry_active = false
var string telemetry_direction = ""

// Trade identifiers for telemetry lifecycle
var string telemetry_trade_id = ""
var int    telemetry_entry_time = na        // milliseconds timestamp
var float  telemetry_entry_price = na
var float  telemetry_stop_price = na

// Telemetry MFE/MAE tracking (independent from chart arrays)
var float telemetry_max_mfe = 0.0
var float telemetry_mae_global = 0.0

// Telemetry BE trigger state
var bool telemetry_be_triggered = false

// Flags to ensure each webhook is sent EXACTLY once
var bool telemetry_entry_sent = false
var bool telemetry_be_sent = false
var bool telemetry_exit_be_sent = false
var bool telemetry_exit_sl_sent = false

// Guard to avoid sending telemetry on historical bars
var bool telemetry_initialized_this_session = false
// ============================================================================
// END TELEMETRY STATE BLOCK
// ============================================================================

// Store line references to manage them like MFE labels
var array<line> entry_lines = array.new<line>()
var array<line> sl_lines = array.new<line>()

// Reset confirmation flag at start of each bar
confirmed_this_bar := false
live_confirmed_sent_this_bar := false

// Detect new signals (only if not already waiting for same direction)
// Track if we need to send SIGNAL_CREATED webhook
var bool signal_created_bullish = false
var bool signal_created_bearish = false

if show_bull_triangle and active_signal != "Bullish"
    signal_candle_high := high
    signal_candle_low := low
    signal_bar_index := bar_index
    signal_candle_time := time  // Store signal candle time
    active_signal := "Bullish"
    waiting_for_confirmation := true
    trade_ready := false
    entry_price := na
    stop_loss_price := na
    signal_created_bullish := true  // Flag to send SIGNAL_CREATED webhook
    
    // ALL SIGNALS: Cancel any pending Bearish signals before adding new Bullish
    if array.size(all_signal_times) > 0
        for idx = array.size(all_signal_times) - 1 to 0
            if array.get(all_signal_directions, idx) == "Bearish" and array.get(all_signal_status, idx) == "PENDING"
                array.set(all_signal_status, idx, "CANCELLED")
    
    // ALL SIGNALS: Track every triangle
    array.push(all_signal_times, time)
    array.push(all_signal_directions, "Bullish")
    array.push(all_signal_status, "PENDING")
    array.push(all_signal_confirmation_times, 0)
    array.push(all_signal_bars_to_confirm, 0)
    array.push(all_signal_daily_bias, daily_bias)
    array.push(all_signal_h4_bias, h4_bias)
    array.push(all_signal_h1_bias, h1_bias)
    array.push(all_signal_m15_bias, m15_bias)
    array.push(all_signal_m5_bias, m5_bias)
    array.push(all_signal_m1_bias, bias)
    array.push(all_signal_confirmed_index, -1)  // Not confirmed yet
    array.push(all_signal_htf_daily, daily_bias)
    array.push(all_signal_htf_4h, h4_bias)
    array.push(all_signal_htf_1h, h1_bias)
    array.push(all_signal_htf_15m, m15_bias)
    array.push(all_signal_htf_5m, m5_bias)

if show_bear_triangle and active_signal != "Bearish"
    signal_candle_high := high
    signal_candle_low := low
    signal_bar_index := bar_index
    signal_candle_time := time  // Store signal candle time
    active_signal := "Bearish"
    
    // ALL SIGNALS: Cancel any pending Bullish signals before adding new Bearish
    if array.size(all_signal_times) > 0
        for idx = array.size(all_signal_times) - 1 to 0
            if array.get(all_signal_directions, idx) == "Bullish" and array.get(all_signal_status, idx) == "PENDING"
                array.set(all_signal_status, idx, "CANCELLED")
    
    // ALL SIGNALS: Track every triangle
    array.push(all_signal_times, time)
    array.push(all_signal_directions, "Bearish")
    array.push(all_signal_status, "PENDING")
    array.push(all_signal_confirmation_times, 0)
    array.push(all_signal_bars_to_confirm, 0)
    array.push(all_signal_daily_bias, daily_bias)
    array.push(all_signal_h4_bias, h4_bias)
    array.push(all_signal_h1_bias, h1_bias)
    array.push(all_signal_m15_bias, m15_bias)
    array.push(all_signal_m5_bias, m5_bias)
    array.push(all_signal_m1_bias, bias)
    array.push(all_signal_confirmed_index, -1)  // Not confirmed yet
    array.push(all_signal_htf_daily, daily_bias)
    array.push(all_signal_htf_4h, h4_bias)
    array.push(all_signal_htf_1h, h1_bias)
    array.push(all_signal_htf_15m, m15_bias)
    array.push(all_signal_htf_5m, m5_bias)
    waiting_for_confirmation := true
    trade_ready := false
    entry_price := na
    stop_loss_price := na
    signal_created_bearish := true  // Flag to send SIGNAL_CREATED webhook

// Cancel on opposite signal BEFORE confirmation (no ENTRY ever sent)
// NOTE: CANCELLED webhooks are sent later in the script after f_buildTradeId and f_buildPayload are defined
// We use a flag to track when cancellation should happen
var bool pending_cancel_bearish = false
var bool pending_cancel_bullish = false

if show_bull_triangle and active_signal == "Bearish"
    if waiting_for_confirmation and barstate.isrealtime
        pending_cancel_bearish := true
        
        // ALL SIGNALS: Mark previous Bearish signal as CANCELLED
        if array.size(all_signal_times) > 0
            for idx = array.size(all_signal_times) - 1 to 0
                if array.get(all_signal_directions, idx) == "Bearish" and array.get(all_signal_status, idx) == "PENDING"
                    array.set(all_signal_status, idx, "CANCELLED")
                    break
    
    // Clear state
    active_signal := "None"
    waiting_for_confirmation := false

if show_bear_triangle and active_signal == "Bullish"
    if waiting_for_confirmation and barstate.isrealtime
        pending_cancel_bullish := true
        
        // ALL SIGNALS: Mark previous Bullish signal as CANCELLED
        if array.size(all_signal_times) > 0
            for idx = array.size(all_signal_times) - 1 to 0
                if array.get(all_signal_directions, idx) == "Bullish" and array.get(all_signal_status, idx) == "PENDING"
                    array.set(all_signal_status, idx, "CANCELLED")
                    break
    
    active_signal := "None"
    waiting_for_confirmation := false

// ============================================================================
// BULLISH CONFIRMATION & STOP LOSS CALCULATION
// ============================================================================

if waiting_for_confirmation and active_signal == "Bullish"
    if close > signal_candle_high
        waiting_for_confirmation := false
        // Entry happens at OPEN of NEXT bar, not close of confirmation bar
        // But we don't know next bar's open yet, so we'll update it on the next bar
        entry_price := close  // Temporary - will be updated to next bar's open
        
        // Find lowest point from signal candle to current (confirmation) candle
        int bars_since_signal = bar_index - signal_bar_index
        float lowest_low = signal_candle_low
        int lowest_bar_offset = bars_since_signal
        
        // Check all candles between signal and confirmation
        for i = 1 to bars_since_signal - 1
            if low[i] < lowest_low
                lowest_low := low[i]
                lowest_bar_offset := i
        
        // Check current confirmation candle
        if low < lowest_low
            lowest_low := low
            lowest_bar_offset := 0
        
        // Apply your exact methodology
        bool lowest_is_pivot = false
        
        // Check if lowest point is a pivot (including signal candle)
        if lowest_bar_offset >= 1
            lowest_is_pivot := is_pivot_low(lowest_bar_offset)
        
        if lowest_is_pivot
            // Scenario A or B: Lowest point is a pivot (could be signal candle or between)
            stop_loss_price := lowest_low - buffer_points
        else
            // Lowest point is NOT a pivot - search left 5 candles from signal for pivot
            // This applies whether lowest is signal candle, between candles, or confirmation
            bool found_pivot = false
            float pivot_low = na
            
            // Start from 1 candle left of signal, search up to 5 candles left
            int search_start = bars_since_signal + 1
            int search_end = bars_since_signal + 5
            
            for i = search_start to math.min(search_end, bar_index - 1)
                // Need at least 1 bar on each side for valid pivot check
                if i >= 1 and i <= bar_index - 1
                    // Check if this candle is a 3-candle or 4-candle pivot
                    if is_pivot_low(i)
                        pivot_low := low[i]
                        found_pivot := true
                        break
            
            if found_pivot
                stop_loss_price := pivot_low - buffer_points
            else
                // No pivot found - use first bearish candle low in the 5-candle search
                float bearish_candle_low = signal_candle_low
                for i = search_start to math.min(search_end, bar_index)
                    if close[i] < open[i]
                        bearish_candle_low := low[i]
                        break
                stop_loss_price := bearish_candle_low - buffer_points
        
        risk_distance := entry_price - stop_loss_price
        float risk_amount = account_size * (risk_percent / 100)
        // For futures: risk per contract = risk_distance * point_value
        float risk_per_contract = risk_distance * point_value
        float calculated_contracts = risk_per_contract > 0 ? risk_amount / risk_per_contract : 0
        // Ensure at least 1 contract (use math.max to prevent 0 contracts)
        contract_size := calculated_contracts > 0 ? math.max(1, math.floor(calculated_contracts)) : 0
        trade_ready := true
        
        // Add this signal to tracking arrays (for visual display and MFE tracking)
        array.push(signal_entries, entry_price)
        array.push(signal_stops, stop_loss_price)
        array.push(signal_risks, risk_distance)
        array.push(signal_directions, "Bullish")
        array.push(signal_mfes, 0.0)
        array.push(signal_be_mfes, 0.0)  // BE MFE starts at 0
        array.push(signal_maes, 0.0)  // start with 0 adverse movement
        array.push(signal_be_triggered, false)  // BE not triggered yet
        array.push(signal_be_stopped, false)  // BE=1 strategy starts active
        array.push(signal_no_be_stopped, false)  // No BE strategy starts active
        array.push(signal_completes, false)
        array.push(signal_labels, label(na))
        array.push(signal_entry_times, time)  // Use CURRENT time (confirmation bar) for MFE tracking
        array.push(signal_triangle_times, signal_candle_time)  // Canonical trade identity time (triangle time)
        array.push(signal_lowest_lows, entry_price)  // Initialize with entry price for accurate MFE tracking
        array.push(signal_highest_highs, entry_price)  // Initialize with entry price for accurate MFE tracking
        array.push(signal_has_entered, false)  // Will be set to true on NEXT bar (after entry)
        array.push(signal_entry_bar_index, bar_index)  // CRITICAL: Track bar_index for minimum duration checks
        array.push(signal_entry_webhook_sent, false)  // ENTRY webhook not sent yet
        array.push(signal_is_realtime, barstate.isrealtime)  // Track if signal is eligible for webhooks
        array.push(signal_snapshot_sent, false)  // MFE snapshot not sent yet
        array.push(signal_confirmed_export_sent, false)  // Live confirmed export not sent yet
        
        // CRITICAL: Track bar index when events occur (prevents historical webhook spam)
        array.push(signal_entry_bar, bar_index)  // Entry confirmed THIS bar
        array.push(signal_be_trigger_bar, -1)  // BE not triggered yet
        array.push(signal_completion_bar, -1)  // Trade not completed yet
        
        // CRITICAL FIX: Mark as confirmed but DON'T reset trade_ready yet
        // Let webhook code execute first, then reset on next bar
        confirmed_this_bar := true
        
        // ALL SIGNALS: Update most recent Bullish signal to CONFIRMED
        if array.size(all_signal_times) > 0
            int last_idx = array.size(all_signal_times) - 1
            if array.get(all_signal_directions, last_idx) == "Bullish"
                array.set(all_signal_status, last_idx, "CONFIRMED")
                array.set(all_signal_confirmation_times, last_idx, time)
                int bars_waited = bar_index - signal_bar_index
                array.set(all_signal_bars_to_confirm, last_idx, bars_waited)
                // Link to confirmed signals array (will be added next bar)
                array.set(all_signal_confirmed_index, last_idx, array.size(signal_entries) - 1)

// ============================================================================
// BEARISH CONFIRMATION & STOP LOSS CALCULATION
// ============================================================================

if waiting_for_confirmation and active_signal == "Bearish"
    if close < signal_candle_low
        waiting_for_confirmation := false
        entry_price := close
        
        // Find highest point from signal candle to current (confirmation) candle
        int bars_since_signal = bar_index - signal_bar_index
        float highest_high = signal_candle_high
        int highest_bar_offset = bars_since_signal
        
        // Check all candles between signal and confirmation
        for i = 1 to bars_since_signal - 1
            if high[i] > highest_high
                highest_high := high[i]
                highest_bar_offset := i
        
        // Check current confirmation candle
        if high > highest_high
            highest_high := high
            highest_bar_offset := 0
        
        // Apply your exact methodology
        bool highest_is_pivot = false
        
        // Check if highest point is a pivot (including signal candle)
        if highest_bar_offset >= 1
            highest_is_pivot := is_pivot_high(highest_bar_offset)
        
        if highest_is_pivot
            // Scenario A or B: Highest point is a pivot (could be signal candle or between)
            stop_loss_price := highest_high + buffer_points
        else
            // Highest point is NOT a pivot - search left 5 candles from signal for pivot
            // This applies whether highest is signal candle, between candles, or confirmation
            bool found_pivot = false
            float pivot_high = na
            
            // Start from 1 candle left of signal, search up to 5 candles left
            int search_start = bars_since_signal + 1
            int search_end = bars_since_signal + 5
            
            for i = search_start to math.min(search_end, bar_index - 1)
                // Need at least 1 bar on each side for valid pivot check
                if i >= 1 and i <= bar_index - 1
                    // Check if this candle is a 3-candle or 4-candle pivot
                    if is_pivot_high(i)
                        pivot_high := high[i]
                        found_pivot := true
                        break
            
            if found_pivot
                stop_loss_price := pivot_high + buffer_points
            else
                // No pivot found - use first bullish candle high in the 5-candle search
                float bullish_candle_high = signal_candle_high
                for i = search_start to math.min(search_end, bar_index)
                    if close[i] > open[i]
                        bullish_candle_high := high[i]
                        break
                stop_loss_price := bullish_candle_high + buffer_points
        
        risk_distance := stop_loss_price - entry_price
        float risk_amount = account_size * (risk_percent / 100)
        // For futures: risk per contract = risk_distance * point_value
        float risk_per_contract = risk_distance * point_value
        float calculated_contracts = risk_per_contract > 0 ? risk_amount / risk_per_contract : 0
        // Ensure at least 1 contract (use math.max to prevent 0 contracts)
        contract_size := calculated_contracts > 0 ? math.max(1, math.floor(calculated_contracts)) : 0
        trade_ready := true
        
        // Add this signal to tracking arrays (for visual display and MFE tracking)
        array.push(signal_entries, entry_price)
        array.push(signal_stops, stop_loss_price)
        array.push(signal_risks, risk_distance)
        array.push(signal_directions, "Bearish")
        array.push(signal_mfes, 0.0)
        array.push(signal_be_mfes, 0.0)  // BE MFE starts at 0
        array.push(signal_maes, 0.0)  // start with 0 adverse movement
        array.push(signal_be_triggered, false)  // BE not triggered yet
        array.push(signal_be_stopped, false)  // BE=1 strategy starts active
        array.push(signal_no_be_stopped, false)  // No BE strategy starts active
        array.push(signal_completes, false)
        array.push(signal_labels, label(na))
        array.push(signal_entry_times, time)  // Use CURRENT time (confirmation bar) for MFE tracking
        array.push(signal_triangle_times, signal_candle_time)  // Canonical trade identity time (triangle time)
        array.push(signal_lowest_lows, entry_price)  // Initialize with entry price for accurate MFE tracking
        array.push(signal_highest_highs, entry_price)  // Initialize with entry price for accurate MFE tracking
        array.push(signal_has_entered, false)  // Will be set to true on NEXT bar (after entry)
        array.push(signal_entry_bar_index, bar_index)  // CRITICAL: Track bar_index for minimum duration checks
        array.push(signal_entry_webhook_sent, false)  // ENTRY webhook not sent yet
        array.push(signal_is_realtime, barstate.isrealtime)  // Track if signal is eligible for webhooks
        array.push(signal_snapshot_sent, false)  // MFE snapshot not sent yet
        array.push(signal_confirmed_export_sent, false)  // Live confirmed export not sent yet
        
        // CRITICAL FIX: Mark as confirmed but DON'T reset trade_ready yet
        // Let webhook code execute first, then reset on next bar
        confirmed_this_bar := true
        
        // ALL SIGNALS: Update most recent Bearish signal to CONFIRMED
        if array.size(all_signal_times) > 0
            int last_idx = array.size(all_signal_times) - 1
            if array.get(all_signal_directions, last_idx) == "Bearish"
                array.set(all_signal_status, last_idx, "CONFIRMED")
                array.set(all_signal_confirmation_times, last_idx, time)
                int bars_waited = bar_index - signal_bar_index
                array.set(all_signal_bars_to_confirm, last_idx, bars_waited)
                // Link to confirmed signals array (will be added next bar)
                array.set(all_signal_confirmed_index, last_idx, array.size(signal_entries) - 1)

// ============================================================================
// VISUALIZATION
// ============================================================================

plotshape(triangle_size == "Small" and show_bull_triangle, "Bullish Signal", shape.triangleup, location.belowbar, bull_color, size=size.small)
plotshape(triangle_size == "Small" and show_bear_triangle, "Bearish Signal", shape.triangledown, location.abovebar, bear_color, size=size.small)

// Entry/SL lines are now drawn in the MFE tracking loop below (when show_entry_sl_lines is enabled)
// This ensures they display for ALL historical signals, matching the MFE labels

// ============================================================================
// MAE HELPER FUNCTION (SINGLE SOURCE OF TRUTH)
// ============================================================================
// Returns MAE in R, always <= 0.0
// LONG  : (lowestLow - entryPrice) / riskR
// SHORT : (entryPrice - highestHigh) / riskR
f_calcMaeR(direction, entryPrice, lowestLow, highestHigh, riskR) =>
    float mae = 0.0
    float adverse = 0.0
    // Only compute if we have a valid risk
    if not na(riskR) and riskR > 0
        // Bullish / LONG: adverse move is price going BELOW entry
        if direction == "Bullish" or direction == "LONG"
            if not na(lowestLow)
                adverse := lowestLow - entryPrice
        // Bearish / SHORT: adverse move is price going ABOVE entry
        else if direction == "Bearish" or direction == "SHORT"
            if not na(highestHigh)
                adverse := entryPrice - highestHigh
        // Convert price adverse move into R-multiple
        mae := adverse / riskR
    // MAE must NEVER be positive
    mae := math.min(mae, 0.0)
    mae

// ============================================================================
// MULTI-SIGNAL MFE TRACKING
// ============================================================================

// Loop through all tracked signals and update MFE
// CRITICAL: This loop ALWAYS runs to calculate MFE data for webhooks
// Visual objects (labels/lines) only created when display settings are ON
if array.size(signal_entries) > 0
    // Pre-calculate label size once (not per signal) - only needed if showing labels
    string label_size_value = mfe_label_size == "Tiny" ? size.tiny : 
                             mfe_label_size == "Small" ? size.small : 
                             mfe_label_size == "Normal" ? size.normal : 
                             mfe_label_size == "Large" ? size.large : size.huge
    
    // OPTIMIZED: Only process ACTIVE signals after cutoff date
    // Completed signals don't need MFE updates (already stopped out)
    // Old signals before cutoff date are frozen (performance optimization)
    for i = 0 to array.size(signal_entries) - 1
        // Skip completed signals for performance
        bool sig_already_stopped = array.get(signal_no_be_stopped, i)
        if sig_already_stopped
            continue
        bool sig_was_complete = array.get(signal_completes, i)  // Was it complete BEFORE this bar?
        
        // Get signal data
        float sig_entry = array.get(signal_entries, i)
        float sig_stop = array.get(signal_stops, i)
        float sig_risk = array.get(signal_risks, i)
        string sig_dir = array.get(signal_directions, i)
        float sig_mfe = array.get(signal_mfes, i)
        float sig_be_mfe = array.get(signal_be_mfes, i)
        float sig_mae = array.get(signal_maes, i)
        bool sig_be_triggered = array.get(signal_be_triggered, i)
        bool sig_be_stopped = array.get(signal_be_stopped, i)
        bool sig_no_be_stopped = array.get(signal_no_be_stopped, i)
        float sig_lowest_low = array.get(signal_lowest_lows, i)
        float sig_highest_high = array.get(signal_highest_highs, i)
        int sig_entry_time = array.get(signal_entry_times, i)
        
        // Mark signal as entered on the bar AFTER it was added (entry happens at open of next bar)
        bool sig_has_entered = array.get(signal_has_entered, i)
        if not sig_has_entered and time > sig_entry_time
            // FIRST bar after confirmation - initialize extremes with THIS bar's OPEN (actual entry price)
            // This ensures MFE tracking starts from actual entry, not confirmation close
            array.set(signal_lowest_lows, i, open)
            array.set(signal_highest_highs, i, open)
            array.set(signal_has_entered, i, true)
            sig_has_entered := true
            sig_lowest_low := open
            sig_highest_high := open
            
            // LIVE CONFIRMED EXPORT - Send ONE confirmed signal immediately when entry bar begins
            if ENABLE_LIVE_CONFIRMED_EXPORT and barstate.isrealtime and barstate.isconfirmed and not live_confirmed_sent_this_bar
                bool already_sent = array.get(signal_confirmed_export_sent, i)
                if not already_sent
                    int sig_triangle_time = array.get(signal_triangle_times, i)
                    string dir_tag = sig_dir == "Bullish" ? "BULLISH" : "BEARISH"
                    string trade_id = str.tostring(year(sig_triangle_time, "America/New_York")) + str.tostring(month(sig_triangle_time, "America/New_York"), "00") + str.tostring(dayofmonth(sig_triangle_time, "America/New_York"), "00") + "_" + str.tostring(hour(sig_triangle_time, "America/New_York"), "00") + str.tostring(minute(sig_triangle_time, "America/New_York"), "00") + str.tostring(second(sig_triangle_time, "America/New_York"), "00") + "000_" + dir_tag
                    string date_str = str.tostring(year(sig_triangle_time, "America/New_York")) + "-" + str.tostring(month(sig_triangle_time, "America/New_York"), "00") + "-" + str.tostring(dayofmonth(sig_triangle_time, "America/New_York"), "00")
                    int h = hour(sig_triangle_time, "America/New_York")
                    int m = minute(sig_triangle_time, "America/New_York")
                    string session_str = h >= 20 ? "ASIA" : h < 6 ? "LONDON" : (h < 8 or (h == 8 and m < 30)) ? "NY PRE" : ((h == 8 and m >= 30) or h < 12) ? "NY AM" : h == 12 ? "NY LUNCH" : h < 16 ? "NY PM" : "AFTER_HOURS"
                    
                    string confirmed_signal = '{"trade_id":"' + trade_id + '","triangle_time":' + str.tostring(sig_triangle_time) + ',"confirmation_time":' + str.tostring(sig_entry_time) + ',"date":"' + date_str + '","direction":"' + sig_dir + '","session":"' + session_str + '","entry":' + str.tostring(open) + ',"stop":' + str.tostring(sig_stop) + ',"be_mfe":0,"no_be_mfe":0,"mae":0,"completed":false}'
                    
                    string confirmed_payload = '{"event_type":"INDICATOR_EXPORT_V2","batch_number":-1,"batch_size":1,"total_signals":1,"signals":[' + confirmed_signal + ']}'
                    
                    alert(confirmed_payload, alert.freq_once_per_bar_close)
                    
                    array.set(signal_confirmed_export_sent, i, true)
                    live_confirmed_sent_this_bar := true
        
        // CRITICAL: Check if ORIGINAL stop loss is hit on THIS bar BEFORE updating extremes
        // This prevents capturing price movement on the bar where No-BE strategy is closed
        // CRITICAL FIX: Update extreme prices FIRST, then check stop
        // This ensures we capture the high/low of the bar where stop is hit
        if sig_has_entered
            if sig_dir == "Bullish"
                // For bullish: track HIGHEST high (favorable) and LOWEST low (for stop check)
                if high > sig_highest_high
                    array.set(signal_highest_highs, i, high)
                    sig_highest_high := high
                if low < sig_lowest_low
                    array.set(signal_lowest_lows, i, low)
                    sig_lowest_low := low
            else  // Bearish
                // For bearish: track LOWEST low (favorable) and HIGHEST high (for stop check)
                if low < sig_lowest_low
                    array.set(signal_lowest_lows, i, low)
                    sig_lowest_low := low
                if high > sig_highest_high
                    array.set(signal_highest_highs, i, high)
                    sig_highest_high := high
        
        // NOW check if stop was hit (after updating extremes)
        bool no_be_stop_hit_this_bar = false
        if sig_dir == "Bullish"
            // Check if No BE stop loss (original stop) is hit on this bar
            if not sig_no_be_stopped and low <= sig_stop
                no_be_stop_hit_this_bar := true
        else  // Bearish
            // Check if No BE stop loss (original stop) is hit on this bar
            if not sig_no_be_stopped and high >= sig_stop
                no_be_stop_hit_this_bar := true
        
        // --- MAE CALCULATION (ALWAYS <= 0) ---
        // Only process signals from last 30 days for performance
        bool is_recent_mae = (time - sig_entry_time) < 2592000000  // 30 days in milliseconds
        if sig_has_entered and is_recent_mae
            float maeR = f_calcMaeR(sig_dir, sig_entry, sig_lowest_low, sig_highest_high, sig_risk)
            // Update stored MAE to the worst (most negative) value seen so far
            if array.size(signal_maes) > i
                float prevMae = array.get(signal_maes, i)
                float newMae = na(prevMae) ? maeR : math.min(prevMae, maeR)
                array.set(signal_maes, i, newMae)
                sig_mae := newMae
            else
                // Fallback in case of any index mismatch
                array.push(signal_maes, maeR)
                sig_mae := maeR
        
        // Calculate current MFE for all signals (to capture maximum even after completion)
        float current_mfe = 0.0
        bool just_completed = false
        bool be_just_triggered = false
        
        // Only process signals from last 30 days for performance
        bool is_recent = (time - sig_entry_time) < 2592000000  // 30 days in milliseconds
        
        // Calculate MFE using MAXIMUM favorable price movement (not current bar)
        // MFE = Maximum Favorable Excursion (the best price achieved, not current price)
        // CRITICAL FIX: Only calculate MFE AFTER trade has entered
        // Entry happens when time > sig_entry_time, so on entry bar time == sig_entry_time + 1 bar
        // We need to skip MFE calculation on the entry bar itself
        int bars_since_entry_time = math.floor((time - sig_entry_time) / (timeframe.in_seconds() * 1000))
        
        // Calculate MFE for ALL signals (historical and real-time) for visual display
        // Webhook sending is controlled separately by signal_is_realtime flag
        if sig_has_entered and is_recent and bars_since_entry_time > 0
            if sig_dir == "Bullish"
                // Use highest high achieved, not current bar's high
                current_mfe := (sig_highest_high - sig_entry) / sig_risk
            else  // Bearish
                // Use lowest low achieved, not current bar's low
                current_mfe := (sig_entry - sig_lowest_low) / sig_risk
        
        // FIRST: Update stopped flags on ALL bars (not just incomplete trades)
        // CRITICAL: Flag updates run regardless of is_recent to ensure historical completion detection
        // CRITICAL FIX: Only check stops AFTER trade has entered (not on confirmation bar)
        if sig_has_entered and sig_dir == "Bullish"
            // ALWAYS check if No BE strategy should be stopped out (original SL hit)
            // This runs regardless of track_be_mfe setting
            if not sig_no_be_stopped
                if low <= sig_stop
                    array.set(signal_no_be_stopped, i, true)
                    sig_no_be_stopped := true
                    // CRITICAL: If original SL hit BEFORE BE triggered, BE=1 also stops
                    // Both strategies have same stop until +1R is achieved
                    if track_be_mfe and not sig_be_triggered
                        array.set(signal_be_stopped, i, true)
                        sig_be_stopped := true
            
            // Check if BE=1 strategy should be stopped out (entry hit after BE trigger)
            // This only runs when BE tracking is enabled
            if track_be_mfe and sig_be_triggered and not sig_be_stopped
                if low <= sig_entry
                    array.set(signal_be_stopped, i, true)
                    sig_be_stopped := true
            
            // BE=1 trigger detection (runs on ALL bars to ensure historical detection)
            // CRITICAL FIX: Only check BE trigger AFTER trade has entered
            if sig_has_entered and track_be_mfe and not sig_be_triggered and is_recent and current_mfe >= 1.0
                array.set(signal_be_triggered, i, true)
                // CRITICAL ENFORCEMENT: BE MFE can NEVER exceed No BE MFE
                float capped_be_mfe_bull = math.min(current_mfe, sig_mfe)
                array.set(signal_be_mfes, i, capped_be_mfe_bull)
                sig_be_triggered := true
                sig_be_mfe := capped_be_mfe_bull
                be_just_triggered := true
        else  // Bearish
            // ALWAYS check if No BE strategy should be stopped out (original SL hit)
            // This runs regardless of track_be_mfe setting
            // CRITICAL FIX: Only check stops AFTER trade has entered (not on confirmation bar)
            if sig_has_entered and not sig_no_be_stopped
                if high >= sig_stop
                    array.set(signal_no_be_stopped, i, true)
                    sig_no_be_stopped := true
                    // CRITICAL: If original SL hit BEFORE BE triggered, BE=1 also stops
                    // Both strategies have same stop until +1R is achieved
                    if track_be_mfe and not sig_be_triggered
                        array.set(signal_be_stopped, i, true)
                        sig_be_stopped := true
            
            // Check if BE=1 strategy should be stopped out (entry hit after BE trigger)
            // This only runs when BE tracking is enabled
            if sig_has_entered and track_be_mfe and sig_be_triggered and not sig_be_stopped
                if high >= sig_entry
                    array.set(signal_be_stopped, i, true)
                    sig_be_stopped := true
            
            // BE=1 trigger detection (runs on ALL bars to ensure historical detection)
            // CRITICAL FIX: Only check BE trigger AFTER trade has entered
            if sig_has_entered and track_be_mfe and not sig_be_triggered and is_recent and current_mfe >= 1.0
                array.set(signal_be_triggered, i, true)
                // CRITICAL ENFORCEMENT: BE MFE can NEVER exceed No BE MFE
                float capped_be_mfe_bear = math.min(current_mfe, sig_mfe)
                array.set(signal_be_mfes, i, capped_be_mfe_bear)
                sig_be_triggered := true
                sig_be_mfe := capped_be_mfe_bear
                be_just_triggered := true
        
        // THEN: Check if trade should be marked complete
        if is_recent
            bool trade_stopped_out = false
            if track_be_mfe
                // With BE tracking: complete if EITHER strategy stopped
                trade_stopped_out := sig_be_stopped or sig_no_be_stopped
            else
                // Without BE tracking: complete if No BE strategy stopped
                // (sig_no_be_stopped is now always tracked regardless of track_be_mfe)
                trade_stopped_out := sig_no_be_stopped
            
            // Mark as complete if not already complete
            if trade_stopped_out and not sig_was_complete
                array.set(signal_completes, i, true)
                just_completed := true
        
        // Calculate if MFE changed (used by both strategies)
        bool mfe_changed = current_mfe > sig_mfe
        
        // CRITICAL FIX: Save previous No BE MFE BEFORE updating
        // This is needed for proper BE MFE capping
        float previous_no_be_mfe = sig_mfe
        
        // Update No BE MFE - always update if trade is active (not just when increased)
        // This ensures webhooks always send current No-BE MFE value
        if is_recent and not sig_no_be_stopped
            array.set(signal_mfes, i, current_mfe)
            sig_mfe := current_mfe
        
        // BE MFE tracking: Track MFE for BE=1 strategy
        // CRITICAL: BE MFE NEVER FREEZES - it continues to track maximum favorable movement
        // The ONLY difference from No BE MFE is WHEN it stops:
        // - No BE MFE stops when: price hits original stop loss
        // - BE=1 MFE stops when: price hits entry (after +1R) OR original stop loss (before +1R)
        if track_be_mfe
            // BE MFE continues to update as long as BE=1 strategy hasn't been stopped out
            // CRITICAL FIX: Always update BE MFE when trade is active (not just when increased)
            // This ensures webhooks always send current BE MFE value
            if is_recent and not sig_be_stopped
                // Use current_mfe directly (don't cap to just-updated sig_mfe)
                array.set(signal_be_mfes, i, current_mfe)
                sig_be_mfe := current_mfe
        
        // Re-read final values from arrays to ensure label shows latest data
        float final_mfe = array.get(signal_mfes, i)
        float final_be_mfe = track_be_mfe ? array.get(signal_be_mfes, i) : 0.0
        // Note: BE MFE may exceed No BE MFE temporarily, but will be corrected when BE stops
        
        // ONLY CREATE LABELS ON THE LAST BAR (current bar) to avoid performance issues
        // ONLY show labels for ACTIVE signals (at least one strategy still active)
        bool at_least_one_active = track_be_mfe ? (not sig_be_stopped or not sig_no_be_stopped) : not sig_no_be_stopped
        if barstate.islast and show_mfe_labels and at_least_one_active
            // Delete old label
            label old_label = array.get(signal_labels, i)
            if not na(old_label)
                label.delete(old_label)
            
            // Create new label for active signals only
            // Format: "BE_MFE, No_BE_MFE" if BE tracking enabled, otherwise just "MFE"
            string mfe_text = ""
            if track_be_mfe
                string no_be_mfe_str = str.tostring(final_mfe, "#.##")
                string be_mfe_str = str.tostring(final_be_mfe, "#.##")
                mfe_text := be_mfe_str + ", " + no_be_mfe_str
            else
                string mfe_value_str = str.tostring(final_mfe, "#.##")
                mfe_text := str.replace(mfe_label_format, "{mfe}", mfe_value_str)
            
            // PROPER COMPLETION DETECTION: Use tracked extreme prices
            bool is_completed = false
            if track_be_mfe
                // With BE tracking: Check if EITHER strategy would be stopped out
                bool no_be_would_stop = false
                bool be_would_stop = false
                
                if sig_dir == "Bullish"
                    // No BE stops if lowest low hit stop loss
                    no_be_would_stop := sig_lowest_low <= sig_stop
                    // BE stops if: reached +1R AND then lowest low hit entry
                    be_would_stop := final_be_mfe >= 1.0 and sig_lowest_low <= sig_entry
                else  // Bearish
                    // No BE stops if highest high hit stop loss
                    no_be_would_stop := sig_highest_high >= sig_stop
                    // BE stops if: reached +1R AND then highest high hit entry
                    be_would_stop := final_be_mfe >= 1.0 and sig_highest_high >= sig_entry
                
                is_completed := no_be_would_stop or be_would_stop
            else
                // Without BE tracking: Check if extreme price hit stop loss
                if sig_dir == "Bullish"
                    is_completed := sig_lowest_low <= sig_stop
                else
                    is_completed := sig_highest_high >= sig_stop
            
            color label_bg_color = is_completed ? mfe_complete_color : mfe_active_color
            color label_text_color = is_completed ? mfe_complete_text_color : mfe_active_text_color
            
            label new_label = label.new(
                 x=sig_entry_time, 
                 y=sig_stop, 
                 text=mfe_text, 
                 xloc=xloc.bar_time,
                 style=label.style_label_left,
                 color=label_bg_color,
                 textcolor=label_text_color,
                 size=label_size_value)
            
            array.set(signal_labels, i, new_label)

// Draw entry/SL lines for all signals when enabled - ONLY ON LAST BAR
if show_entry_sl_lines and barstate.islast and array.size(signal_entries) > 0
    // Clear old lines first
    if array.size(entry_lines) > 0
        for i = 0 to array.size(entry_lines) - 1
            line.delete(array.get(entry_lines, i))
        array.clear(entry_lines)
    
    if array.size(sl_lines) > 0
        for i = 0 to array.size(sl_lines) - 1
            line.delete(array.get(sl_lines, i))
        array.clear(sl_lines)
    
    // Redraw ALL lines from stored data (same as MFE labels)
    for i = 0 to array.size(signal_entry_times) - 1
        int entry_time = array.get(signal_entry_times, i)
        float entry_px = array.get(signal_entries, i)
        float stop_px = array.get(signal_stops, i)
        int line_end_time = entry_time + (5 * timeframe.in_seconds() * 1000)
        
        // Draw entry line (green)
        line entry_line = line.new(entry_time, entry_px, line_end_time, entry_px, xloc=xloc.bar_time, extend=extend.none, color=color.new(color.green, 0), width=2, style=line.style_solid)
        array.push(entry_lines, entry_line)
        
        // Draw stop loss line (red)
        line sl_line = line.new(entry_time, stop_px, line_end_time, stop_px, xloc=xloc.bar_time, extend=extend.none, color=color.new(color.red, 0), width=2, style=line.style_solid)
        array.push(sl_lines, sl_line)

// ============================================================================
// CONTRACT ROLLOVER HELPER FUNCTIONS
// ============================================================================

// Get contract month code from symbol (H=Mar, M=Jun, U=Sep, Z=Dec)
f_getContractMonth(ticker) =>
    string month_code = str.substring(ticker, str.length(ticker) - 5, str.length(ticker) - 4)
    month_code

// Get contract year from symbol
f_getContractYear(ticker) =>
    string year_str = str.substring(ticker, str.length(ticker) - 4)
    int(str.tonumber(year_str))

// Calculate expiry date (3rd Friday of contract month)
f_getExpiryTimestamp(month_code, year) =>
    int expiry_month = month_code == "H" ? 3 : month_code == "M" ? 6 : month_code == "U" ? 9 : 12
    
    // 3rd Friday = 15th + days to next Friday
    timestamp(year, expiry_month, 15, 0, 0, 0)

// Get next contract symbol
f_getNextContract(current_month_code, current_year) =>
    string next_code = current_month_code == "H" ? "M" : current_month_code == "M" ? "U" : current_month_code == "U" ? "Z" : "H"
    float next_year_float = current_month_code == "Z" ? current_year + 1 : current_year
    string base = str.substring(syminfo.ticker, 0, str.length(syminfo.ticker) - 5)
    base + next_code + str.tostring(int(next_year_float))

// ============================================================================
// POSITION SIZING TABLE
// ============================================================================

if show_position_table
    // Determine table position based on user selection
    string table_position = position_table_location == "Top Left" ? position.top_left : 
                           position_table_location == "Top Right" ? position.top_right : 
                           position_table_location == "Bottom Left" ? position.bottom_left : 
                           position.bottom_right
    
    // Calculate intended vs actual risk to determine if suggestion is needed
    float intended_risk = account_size * (risk_percent / 100)
    float actual_risk = trade_ready ? contract_size * risk_distance * point_value : 0
    float actual_risk_pct = trade_ready ? (actual_risk / account_size) * 100 : 0
    // Show suggestion ONLY if actual risk would exceed 0.15% (cannot trade with standard contract)
    bool show_suggestion = trade_ready and actual_risk_pct > 0.15
    
    // Expanded table for comprehensive trading info - 15 rows
    var table pos_table = table.new(table_position, 2, 15, border_width=2)
    
    table.cell(pos_table, 0, 0, "üéØ TRADE READY", text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
    table.merge_cells(pos_table, 0, 0, 1, 0)
    
    string status_text = waiting_for_confirmation ? "‚è≥ Waiting" : trade_ready ? "‚úÖ READY" : "‚ö™ No Signal"
    color status_color = waiting_for_confirmation ? color.orange : trade_ready ? color.green : color.gray
    table.cell(pos_table, 0, 1, "Status:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 1, status_text, text_color=color.white, bgcolor=color.new(status_color, 50))
    
    table.cell(pos_table, 0, 2, "Signal:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 2, active_signal, text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    table.cell(pos_table, 0, 3, "Entry:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 3, trade_ready ? str.tostring(entry_price, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    table.cell(pos_table, 0, 4, "Stop Loss:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 4, trade_ready ? str.tostring(stop_loss_price, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    table.cell(pos_table, 0, 5, "Risk (pts):", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 5, trade_ready ? str.tostring(risk_distance, "#.##") : "-", text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    table.cell(pos_table, 0, 6, "üìä CONTRACTS:", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.large)
    table.cell(pos_table, 1, 6, trade_ready ? str.tostring(contract_size) : "-", text_color=color.yellow, bgcolor=color.new(color.blue, 30), text_size=size.large)
    
    // CONTRACT ROLLOVER TRACKING
    // Use syminfo.root + current month/year to build contract name
    // For continuous contracts (MNQ1!), we need to determine the actual front month
    string ticker = syminfo.ticker
    bool is_continuous = str.contains(ticker, "!")
    
    // For continuous contracts, manually set current contract (update quarterly)
    // December 2025 contract (expires 3rd Friday of December)
    string current_contract = is_continuous ? "MNQZ2025" : ticker
    string display_contract = is_continuous ? "MNQ Dec'25 (Z)" : ticker
    
    // Next contract (March 2026)
    string next_contract = "MNQH2026"
    string next_display = "MNQ Mar'26 (H)"
    
    // Expiry: 3rd Friday of December 2025 = December 19, 2025
    int expiry_ts = timestamp(2025, 12, 19, 16, 0, 0)  // 4:00 PM ET on Dec 19
    int days_to_expiry = int(math.floor((expiry_ts - time) / 86400000))
    
    // Color code based on days remaining
    color rollover_bg = days_to_expiry > 14 ? color.new(color.green, 70) : days_to_expiry > 7 ? color.new(color.orange, 50) : color.new(color.red, 50)
    color rollover_text = days_to_expiry > 14 ? color.white : days_to_expiry > 7 ? color.yellow : color.red
    string rollover_icon = days_to_expiry > 14 ? "‚úÖ" : days_to_expiry > 7 ? "‚ö†Ô∏è" : "üö®"
    
    table.cell(pos_table, 0, 7, "Contract:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 7, display_contract, text_color=color.white, bgcolor=color.new(color.gray, 70))
    
    table.cell(pos_table, 0, 8, "Expiry:", text_color=color.white, bgcolor=rollover_bg)
    table.cell(pos_table, 1, 8, rollover_icon + " " + str.tostring(days_to_expiry) + " days", text_color=rollover_text, bgcolor=rollover_bg, text_size=size.normal)
    
    // Show rollover alert if <14 days
    if days_to_expiry < 14 and days_to_expiry > 0
        table.cell(pos_table, 0, 9, "‚ö†Ô∏è ROLLOVER TO:", text_color=color.yellow, bgcolor=color.new(color.orange, 30), text_size=size.normal)
        table.cell(pos_table, 1, 9, next_display, text_color=color.yellow, bgcolor=color.new(color.orange, 30), text_size=size.normal)
    else if days_to_expiry <= 0
        table.cell(pos_table, 0, 9, "üö® EXPIRED!", text_color=color.red, bgcolor=color.new(color.red, 30), text_size=size.large)
        table.cell(pos_table, 1, 9, "USE: " + next_display, text_color=color.red, bgcolor=color.new(color.red, 30), text_size=size.large)
    
    // TRACKING STATISTICS (Rows 10-14)
    // Use simple counts instead of looping through all signals (performance optimization)
    int total_signals = array.size(signal_entries)
    
    // Count only last 100 signals for performance (representative sample)
    int active_count = 0
    int completed_count = 0
    int sample_size = math.min(100, total_signals)
    int start_sample = math.max(0, total_signals - sample_size)
    
    if total_signals > 0 and array.size(signal_no_be_stopped) > 0
        for i = start_sample to total_signals - 1
            if i < array.size(signal_no_be_stopped)
                bool no_be_stopped = array.get(signal_no_be_stopped, i)
                if not no_be_stopped
                    active_count := active_count + 1
                else
                    completed_count := completed_count + 1
    
    // Extrapolate to full dataset
    float completion_rate = sample_size > 0 ? completed_count / sample_size : 0
    int estimated_completed = int(total_signals * completion_rate)
    int estimated_active = total_signals - estimated_completed
    
    // Use estimates for display
    int display_active = sample_size == total_signals ? active_count : estimated_active
    int display_completed = sample_size == total_signals ? completed_count : estimated_completed
    
    // Today's signals - just show 0 for now (too slow to calculate)
    int today_signals = 0
    
    // TRACKING SUMMARY HEADER
    table.cell(pos_table, 0, 10, "üìä TRACKING", text_color=color.white, bgcolor=color.new(color.purple, 20), text_size=size.normal)
    table.merge_cells(pos_table, 0, 10, 1, 10)
    
    // Active Trades
    table.cell(pos_table, 0, 11, "Active Trades:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 11, str.tostring(display_active), text_color=color.green, bgcolor=color.new(color.gray, 70), text_size=size.normal)
    
    // Completed Trades
    table.cell(pos_table, 0, 12, "Completed:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 12, str.tostring(display_completed), text_color=color.blue, bgcolor=color.new(color.gray, 70))
    
    // Today's Activity
    table.cell(pos_table, 0, 13, "Today's Signals:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 13, str.tostring(today_signals), text_color=color.yellow, bgcolor=color.new(color.gray, 70))
    
    // Current Session (inline calculation)
    int h = hour(time, "America/New_York")
    int m = minute(time, "America/New_York")
    string current_session_display = 
         (h >= 20 and h <= 23) ? "ASIA" :
         (h >= 0 and h <= 5) ? "LONDON" :
         (h == 6 or (h == 8 and m <= 29)) ? "NY PRE" :
         ((h == 8 and m >= 30) or (h >= 9 and h <= 11)) ? "NY AM" :
         (h == 12) ? "NY LUNCH" :
         (h >= 13 and h <= 15) ? "NY PM" : "AFTER_HOURS"
    
    color session_color = current_session_display == "NY AM" or current_session_display == "NY PM" ? color.green : 
                         current_session_display == "LONDON" ? color.blue :
                         current_session_display == "ASIA" ? color.purple : color.gray
    
    table.cell(pos_table, 0, 14, "Session:", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(pos_table, 1, 14, current_session_display, text_color=color.white, bgcolor=color.new(session_color, 50))

    
    // Show suggestion row ONLY when actual risk exceeds 0.15% (cannot trade with standard contract)
    if show_suggestion
        // Calculate Micro contract sizing (NQ Micro = $2 per point, 1/10th of standard)
        float micro_point_value = point_value / 10.0
        float micro_contracts = intended_risk / (risk_distance * micro_point_value)
        float micro_actual_risk = math.floor(micro_contracts) * risk_distance * micro_point_value
        float micro_risk_pct = (micro_actual_risk / account_size) * 100
        
        table.cell(pos_table, 0, 9, "‚ö†Ô∏è SWITCH TO MICRO:", text_color=color.white, bgcolor=color.new(color.red, 0), text_size=size.normal)
        string suggestion_text = str.tostring(math.floor(micro_contracts), "#") + " MNQ @ $" + str.tostring(micro_point_value, "#.#") + "/pt (" + str.tostring(micro_risk_pct, "#.##") + "%)"
        table.cell(pos_table, 1, 9, suggestion_text, text_color=color.yellow, bgcolor=color.new(color.red, 0), text_size=size.normal)
    else
        // Hide row 9 with transparent cells (appears as 9-row table)
        table.cell(pos_table, 0, 9, "", text_color=color.new(color.white, 100), bgcolor=color.new(color.white, 100))
        table.cell(pos_table, 1, 9, "", text_color=color.new(color.white, 100), bgcolor=color.new(color.white, 100))

// ============================================================================
// HTF STATUS TABLE
// ============================================================================

if show_htf_status
    var table htf_table = table.new(position.top_right, 3, 8, border_width=1)
    
    table.cell(htf_table, 0, 0, "TF", text_color=color.white, text_size=size.small)
    table.cell(htf_table, 1, 0, "Bias", text_color=color.white, text_size=size.small)
    table.cell(htf_table, 2, 0, "‚úì", text_color=color.white, text_size=size.small)
    
    color current_color = bias == "Bullish" ? bull_color : bias == "Bearish" ? bear_color : neutral_color
    table.cell(htf_table, 0, 1, "1M", text_color=color.white, text_size=size.small)
    table.cell(htf_table, 1, 1, bias, text_color=current_color, text_size=size.small)
    table.cell(htf_table, 2, 1, "NOW", text_color=color.yellow, text_size=size.small)
    
    int row = 2
    if use_5m
        color htf_color = m5_bias == "Bullish" ? bull_color : m5_bias == "Bearish" ? bear_color : neutral_color
        string align_status = (bias == "Bullish" and m5_bull_ok) or (bias == "Bearish" and m5_bear_ok) ? "‚úì" : "‚úó"
        color align_color = (bias == "Bullish" and m5_bull_ok) or (bias == "Bearish" and m5_bear_ok) ? color.green : color.red
        table.cell(htf_table, 0, row, "5M", text_color=color.white, text_size=size.small)
        table.cell(htf_table, 1, row, m5_bias, text_color=htf_color, text_size=size.small)
        table.cell(htf_table, 2, row, align_status, text_color=align_color, text_size=size.small)
        row := row + 1
    
    if use_15m
        color htf_color = m15_bias == "Bullish" ? bull_color : m15_bias == "Bearish" ? bear_color : neutral_color
        string align_status = (bias == "Bullish" and m15_bull_ok) or (bias == "Bearish" and m15_bear_ok) ? "‚úì" : "‚úó"
        color align_color = (bias == "Bullish" and m15_bull_ok) or (bias == "Bearish" and m15_bear_ok) ? color.green : color.red
        table.cell(htf_table, 0, row, "15M", text_color=color.white, text_size=size.small)
        table.cell(htf_table, 1, row, m15_bias, text_color=htf_color, text_size=size.small)
        table.cell(htf_table, 2, row, align_status, text_color=align_color, text_size=size.small)
        row := row + 1
    
    if use_1h
        color htf_color = h1_bias == "Bullish" ? bull_color : h1_bias == "Bearish" ? bear_color : neutral_color
        string align_status = (bias == "Bullish" and h1_bull_ok) or (bias == "Bearish" and h1_bear_ok) ? "‚úì" : "‚úó"
        color align_color = (bias == "Bullish" and h1_bull_ok) or (bias == "Bearish" and h1_bear_ok) ? color.green : color.red
        table.cell(htf_table, 0, row, "1H", text_color=color.white, text_size=size.small)
        table.cell(htf_table, 1, row, h1_bias, text_color=htf_color, text_size=size.small)
        table.cell(htf_table, 2, row, align_status, text_color=align_color, text_size=size.small)
        row := row + 1
    
    if use_4h
        color htf_color = h4_bias == "Bullish" ? bull_color : h4_bias == "Bearish" ? bear_color : neutral_color
        string align_status = (bias == "Bullish" and h4_bull_ok) or (bias == "Bearish" and h4_bear_ok) ? "‚úì" : "‚úó"
        color align_color = (bias == "Bullish" and h4_bull_ok) or (bias == "Bearish" and h4_bear_ok) ? color.green : color.red
        table.cell(htf_table, 0, row, "4H", text_color=color.white, text_size=size.small)
        table.cell(htf_table, 1, row, h4_bias, text_color=htf_color, text_size=size.small)
        table.cell(htf_table, 2, row, align_status, text_color=align_color, text_size=size.small)
        row := row + 1
    
    if use_daily
        color htf_color = daily_bias == "Bullish" ? bull_color : daily_bias == "Bearish" ? bear_color : neutral_color
        string align_status = (bias == "Bullish" and daily_bull_ok) or (bias == "Bearish" and daily_bear_ok) ? "‚úì" : "‚úó"
        color align_color = (bias == "Bullish" and daily_bull_ok) or (bias == "Bearish" and daily_bear_ok) ? color.green : color.red
        table.cell(htf_table, 0, row, "1D", text_color=color.white, text_size=size.small)
        table.cell(htf_table, 1, row, daily_bias, text_color=htf_color, text_size=size.small)
        table.cell(htf_table, 2, row, align_status, text_color=align_color, text_size=size.small)


// ============================================================================
// AUTOMATED SIGNAL LAB WEBHOOK ALERTS
// ============================================================================

// Helper function to determine session
get_session() =>
    // CRITICAL: Use America/New_York timezone to match session definitions
    hour_val = hour(time, "America/New_York")
    minute_val = minute(time, "America/New_York")
    session_name = "Other"
    
    // ASIA: 20:00-23:59 Eastern
    if hour_val >= 20 and hour_val <= 23
        session_name := "ASIA"
    // LONDON: 00:00-05:59 Eastern
    else if hour_val >= 0 and hour_val <= 5
        session_name := "LONDON"
    // NY PRE: 06:00-08:29 Eastern
    else if hour_val >= 6 and (hour_val < 8 or (hour_val == 8 and minute_val < 30))
        session_name := "NY PRE"
    // NY AM: 08:30-11:59 Eastern
    else if (hour_val == 8 and minute_val >= 30) or (hour_val >= 9 and hour_val < 12)
        session_name := "NY AM"
    // NY LUNCH: 12:00-12:59 Eastern
    else if hour_val == 12
        session_name := "NY LUNCH"
    // NY PM: 13:00-15:59 Eastern
    else if hour_val >= 13 and hour_val < 16
        session_name := "NY PM"
    // Everything else (16:00-19:59) is "Other"
    session_name

// Helper function to create signal ID
// ============================================================================
// TRADE ID BUILDER (CANONICAL FORMAT)
// ============================================================================
// Format: YYYYMMDD_HHMMSSMMM_DIRECTION
// Example: 20251120_170200000_BULLISH
// CRITICAL: Uses America/New_York timezone to match TradingView chart display
f_buildTradeId(datetime, direction) =>
    year_str = str.tostring(year(datetime, "America/New_York"))
    month_str = str.tostring(month(datetime, "America/New_York"), "00")
    day_str = str.tostring(dayofmonth(datetime, "America/New_York"), "00")
    hour_str = str.tostring(hour(datetime, "America/New_York"), "00")
    minute_str = str.tostring(minute(datetime, "America/New_York"), "00")
    second_str = str.tostring(second(datetime, "America/New_York"), "00")
    millis_str = str.tostring(datetime % 1000, "000")  // Milliseconds for uniqueness
    date_str = year_str + month_str + day_str
    time_str = hour_str + minute_str + second_str + millis_str
    date_str + "_" + time_str + "_" + str.upper(direction)


// ============================================================================
// TELEMETRY CONFIGURATION
// ============================================================================
telemetry_schema_version   = input.string("1.0.0", "Telemetry Schema Version")
telemetry_engine_version   = input.string("1.0.0", "Telemetry Engine Version")
telemetry_strategy_name    = input.string("NQ_FVG_CORE", "Strategy Name")
telemetry_strategy_id      = input.string("NQ_FVG_CORE", "Strategy ID")
telemetry_strategy_version = input.string("2025.11.20", "Strategy Version")
telemetry_symbol_override  = input.symbol("", "Symbol Override")

// Fallback to actual chart symbol
f_symbol() =>
    telemetry_symbol_override != "" ? telemetry_symbol_override : syminfo.ticker


// ============================================================================
// HELPER FUNCTIONS (TOP-LEVEL)
// ============================================================================

// Zero-pad helper for timestamps
pad(x) =>
    x < 10 ? "0" + str.tostring(x) : str.tostring(x)

// ============================================================================
// ISO 8601 TIMESTAMP BUILDER
// ============================================================================
// Outputs Eastern Time timestamps like "2025-11-18T17:02:00-05:00"
// CRITICAL: Uses America/New_York timezone to match trade_id and TradingView display
f_isoTimestamp(timeMs) =>
    y  = year(timeMs, "America/New_York")
    mo = month(timeMs, "America/New_York")
    d  = dayofmonth(timeMs, "America/New_York")
    h  = hour(timeMs, "America/New_York")
    mi = minute(timeMs, "America/New_York")
    s  = second(timeMs, "America/New_York")
    str.tostring(y) + "-" + pad(mo) + "-" + pad(d) + "T" + pad(h) + ":" + pad(mi) + ":" + pad(s)

// ============================================================================
// SESSION CLASSIFIER
// ============================================================================
// Must match backend session model EXACTLY
f_sessionLabel(timeMs) =>
    // Use the ACTUAL event timestamp (signal/entry/MFE/BE), not timenow
    h = hour(timeMs, "America/New_York")
    m = minute(timeMs, "America/New_York")
    
    // Session logic (MUST MATCH BACKEND):
    // ASIA:       20:00 - 23:59 ET
    // LONDON:     00:00 - 05:59 ET
    // NY PRE:     06:00 - 08:29 ET
    // NY AM:      08:30 - 11:59 ET
    // NY LUNCH:   12:00 - 12:59 ET
    // NY PM:      13:00 - 15:59 ET
    // AFTER_HOURS 16:00 - 19:59 ET
    session = h >= 20 ? "ASIA" : h < 6 ? "LONDON" : h < 8 or (h == 8 and m < 30) ? "NY PRE" : (h == 8 and m >= 30) or h < 12 ? "NY AM" : h == 12 ? "NY LUNCH" : h < 16 ? "NY PM" : "AFTER_HOURS"
    session

// ============================================================================
// JSON HELPER FUNCTIONS
// ============================================================================
// Number or null
f_num(x) =>
    na(x) ? "null" : str.tostring(x)

// String or null
f_str(x) =>
    x == "" ? "null" : '"' + x + '"'

// ============================================================================
// TARGETS JSON BUILDER
// ============================================================================
f_targetsJson(tp1, tp2, tp3, r1, r2, r3) =>
    '"targets":{"tp1_price":' + f_num(tp1) + ',"tp2_price":' + f_num(tp2) + ',"tp3_price":' + f_num(tp3) + ',"target_Rs":[' + f_num(r1) + ',' + f_num(r2) + ',' + f_num(r3) + ']}'

// ============================================================================
// SETUP JSON BUILDER
// ============================================================================
f_setupJson(setupFamily, setupVariant, setupId, strength, trendScore, structureScore, volScore) =>
    '"setup":{"setup_family":"' + setupFamily + '","setup_variant":"' + setupVariant + '","setup_id":"' + setupId + '","signal_strength":' + f_num(strength) + ',"confidence_components":{"trend_alignment":' + f_num(trendScore) + ',"structure_quality":' + f_num(structureScore) + ',"volatility_fit":' + f_num(volScore) + '}}'

// ============================================================================
// MARKET STATE JSON BUILDER
// ============================================================================
f_marketStateJson(trendRegime, trendScore, volRegime, atrVal, atrPct20, dayRangePct20, priceVsOpen, priceVsVwap, distHTF, swingState, bosChoCh, liquCtx) =>
    '"market_state":{"trend_regime":"' + trendRegime + '","trend_score":' + f_num(trendScore) + ',"volatility_regime":"' + volRegime + '","atr":' + f_num(atrVal) + ',"atr_percentile_20d":' + f_num(atrPct20) + ',"daily_range_percentile_20d":' + f_num(dayRangePct20) + ',"price_location":{"vs_daily_open":' + f_num(priceVsOpen) + ',"vs_vwap":' + f_num(priceVsVwap) + ',"distance_to_HTF_level_points":' + f_num(distHTF) + '},"structure":{"swing_state":"' + swingState + '","bos_choch_signal":"' + bosChoCh + '","liquidity_context":"' + liquCtx + '"}}'

// ---------------------------------------------------------------------------
// JSON FIELD BUILDER (Compact, Pine-Safe)
// ---------------------------------------------------------------------------
jsonField(name, value) =>
    '"' + name + '":' + value + ','

// helper to wrap JSON object without trailing comma
jsonWrap(payload) =>
    "{" + str.replace_all(payload, ",}", "}") + "}"
// ---------------------------------------------------------------------------
// COMPACT JSON PAYLOAD BUILDER (Pine-Safe, No Size Limits)
// ---------------------------------------------------------------------------
f_buildPayload(eventType, tradeId, dir, entryPrice, stopPrice, bePrice, riskR, posSize, beMfeR, noBeMfeR, maeGlobalR, finalMfeR, exitPrice, exitReason, tp1, tp2, tp3, setupFam, setupVar, htfBias, symbol, timeframeStr, signalTimeMs) =>
    // --- Enforce MAE is never positive ---
    float maeGlobalR_clean = math.min(nz(maeGlobalR, 0.0), 0.0)
    ts = f_isoTimestamp(signalTimeMs)
    session = f_sessionLabel(signalTimeMs)
    sym = f_symbol()
    string p = ""
    p += jsonField("schema_version", '"' + telemetry_schema_version + '"')
    p += jsonField("engine_version", '"' + telemetry_engine_version + '"')
    p += jsonField("strategy_name", '"' + telemetry_strategy_name + '"')
    p += jsonField("strategy_id", '"' + telemetry_strategy_id + '"')
    p += jsonField("strategy_version", '"' + telemetry_strategy_version + '"')
    p += jsonField("trade_id", '"' + tradeId + '"')
    p += jsonField("event_type", '"' + eventType + '"')
    p += jsonField("event_timestamp", '"' + ts + '"')
    p += jsonField("symbol", '"' + sym + '"')
    p += jsonField("exchange", '"' + symbol + '"')
    p += jsonField("timeframe", '"' + timeframeStr + '"')
    p += jsonField("session", '"' + session + '"')
    p += jsonField("direction", f_str(dir))
    p += jsonField("entry_price", f_num(entryPrice))
    p += jsonField("stop_loss", f_num(stopPrice))
    p += jsonField("risk_R", f_num(riskR))
    p += jsonField("position_size", f_num(posSize))
    p += jsonField("be_price", f_num(bePrice))
    p += jsonField("be_mfe", f_num(beMfeR))
    p += jsonField("no_be_mfe", f_num(noBeMfeR))
    p += jsonField("mae_global_r", f_num(maeGlobalR_clean))
    p += jsonField("final_mfe_R", f_num(finalMfeR))
    p += jsonField("exit_price", f_num(exitPrice))
    p += jsonField("exit_timestamp", "null")
    p += jsonField("exit_reason", f_str(exitReason))
    // Targets block remains embedded compactly
    p += '"targets":{"tp1_price":' + f_num(tp1) + ',"tp2_price":' + f_num(tp2) + ',"tp3_price":' + f_num(tp3) + ',"target_Rs":[1,2,3]},'
    // Setup block compact
    p += '"setup":{"setup_family":"' + setupFam + '","setup_variant":"' + setupVar + '","setup_id":"' + setupFam + "_" + setupVar + '","signal_strength":75},'
    // Market state block (compact)
    p += '"market_state":{"trend_regime":"' + htfBias + '","trend_score":' + f_num(1.0) + ',"volatility_regime":"NORMAL"},'
    // HTF alignment data (calculated but not used for filtering)
    p += '"htf_alignment":{"daily":"' + daily_bias + '","h4":"' + h4_bias + '","h1":"' + h1_bias + '","m15":"' + m15_bias + '","m5":"' + m5_bias + '","m1":"' + bias + '","all_bullish":' + str.tostring(htf_bullish) + ',"all_bearish":' + str.tostring(htf_bearish) + '}'
    jsonWrap(p)

// Variables to track webhook sending for MULTIPLE signals
var array<string> active_signal_ids = array.new_string(0)
var array<int> active_signal_indices = array.new_int(0)  // BULLETPROOF: Store signal array index for each active signal
var array<bool> be_trigger_sent_flags = array.new_bool(0)
var array<bool> completion_sent_flags = array.new_bool(0)
var array<bool> be_exit_sent_flags = array.new_bool(0)   // Track if EXIT_BE was sent (separate from EXIT_SL)
var array<bool> sl_exit_sent_flags = array.new_bool(0)   // Track if EXIT_SL was sent
var bool webhook_sent_this_bar = false

// Helper function to find signal index by ID
find_signal_index(signal_id) =>
    int found_index = -1
    if array.size(active_signal_ids) > 0
        for i = 0 to array.size(active_signal_ids) - 1
            if array.get(active_signal_ids, i) == signal_id
                found_index := i
                break
    found_index

// Reset webhook flag on new bar
if barstate.isconfirmed
    webhook_sent_this_bar := false

// SIGNAL_CREATED WEBHOOKS
// Send when triangle first appears (before confirmation)
if signal_created_bullish and barstate.isrealtime and barstate.isconfirmed
    string signal_direction = "Bullish"
    // DISABLED: SIGNAL_CREATED webhook (using export system instead)
    // string signal_id = f_buildTradeId(signal_candle_time, signal_direction)
    // string signal_payload = f_buildPayload(EVENT_SIGNAL_CREATED, signal_id, signal_direction, float(na), float(na), float(na), 0.0, 0, 0.0, 0.0, float(na), float(na), float(na), "triangle_appeared", float(na), float(na), float(na), "FVG_CORE", "PENDING_CONFIRMATION", bias, syminfo.ticker, timeframe.period, signal_candle_time)
    // alert(signal_payload, alert.freq_once_per_bar_close)
    signal_created_bullish := false

if signal_created_bearish and barstate.isrealtime and barstate.isconfirmed
    // DISABLED: SIGNAL_CREATED webhook (using export system instead)
    // string signal_direction = "Bearish"
    // string signal_id = f_buildTradeId(signal_candle_time, signal_direction)
    // string signal_payload = f_buildPayload(EVENT_SIGNAL_CREATED, signal_id, signal_direction, float(na), float(na), float(na), 0.0, 0, 0.0, 0.0, float(na), float(na), float(na), "triangle_appeared", float(na), float(na), float(na), "FVG_CORE", "PENDING_CONFIRMATION", bias, syminfo.ticker, timeframe.period, signal_candle_time)
    // alert(signal_payload, alert.freq_once_per_bar_close)
    signal_created_bearish := false

// DISABLED: CANCELLED SIGNAL WEBHOOKS (using export system instead)
// if pending_cancel_bearish and barstate.isrealtime
//     string cancel_direction = "Bearish"
//     string cancel_trade_id = f_buildTradeId(signal_candle_time, cancel_direction)
//     string cancel_payload = f_buildPayload(EVENT_CANCELLED, cancel_trade_id, cancel_direction, float(na), float(na), float(na), 0.0, 0, 0.0, 0.0, float(na), float(na), float(na), "opposite_signal_before_confirmation", float(na), float(na), float(na), "FVG_CORE", "CANCELLED", bias, syminfo.ticker, timeframe.period, signal_candle_time)
//     alert(cancel_payload, alert.freq_once_per_bar_close)
//     pending_cancel_bearish := false

// if pending_cancel_bullish and barstate.isrealtime
//     string cancel_direction = "Bullish"
//     string cancel_trade_id = f_buildTradeId(signal_candle_time, cancel_direction)
//     string cancel_payload = f_buildPayload(EVENT_CANCELLED, cancel_trade_id, cancel_direction, float(na), float(na), float(na), 0.0, 0, 0.0, 0.0, float(na), float(na), float(na), "opposite_signal_before_confirmation", float(na), float(na), float(na), "FVG_CORE", "CANCELLED", bias, syminfo.ticker, timeframe.period, signal_candle_time)
//     alert(cancel_payload, alert.freq_once_per_bar_close)
//     pending_cancel_bullish := false

// 1. SIGNAL CREATION WEBHOOK
// Send when new trade is ready (entry conditions met)
// CRITICAL: Only send webhooks for real-time signals to prevent historical replay spam
if confirmed_this_bar and not webhook_sent_this_bar and barstate.isconfirmed and barstate.isrealtime and array.size(signal_entries) > 0
    // Get the most recent signal (just added)
    int last_index = array.size(signal_entries) - 1
    
    // Send ENTRY webhook for all confirmed signals (remove sig_is_realtime check)
    // This ensures signals confirmed during indicator load are also tracked
    float sig_entry = array.get(signal_entries, last_index)
    float sig_stop = array.get(signal_stops, last_index)
    float sig_risk = array.get(signal_risks, last_index)
    string sig_dir = array.get(signal_directions, last_index)
        
    signal_direction = sig_dir  // "Bullish" or "Bearish"
    signal_id = f_buildTradeId(signal_candle_time, signal_direction)
    current_session = get_session()
    
    // Calculate target prices using signal data from arrays
    target_1r = signal_direction == "Bullish" ? sig_entry + sig_risk : sig_entry - sig_risk
    target_2r = signal_direction == "Bullish" ? sig_entry + (2 * sig_risk) : sig_entry - (2 * sig_risk)
    target_3r = signal_direction == "Bullish" ? sig_entry + (3 * sig_risk) : sig_entry - (3 * sig_risk)
    
    // Create JSON payload using SIGNAL CANDLE time (not current bar time)
    // Force US/Eastern timezone for consistency with session validation
    // CRITICAL: Backend expects event_type "ENTRY" not "signal_created"
    
    // Determine setup family and variant
    setup_family = "FVG_CORE"
    setup_variant = htf_bullish or htf_bearish ? "HTF_ALIGNED" : "STANDARD"
    
    // Build telemetry payload for ENTRY event
    entry_payload = f_buildPayload(EVENT_ENTRY, signal_id, signal_direction, sig_entry, sig_stop, float(na), 1.0, contract_size, 0.0, 0.0, float(na), float(na), float(na), "", target_1r, target_2r, target_3r, setup_family, setup_variant, bias, syminfo.ticker, timeframe.period, signal_candle_time)
    
    // DISABLED: ENTRY webhook (using export system instead)
    // alert(entry_payload, alert.freq_once_per_bar_close)
    
    // ============================================================================
    // TELEMETRY ENGINE ‚Äî ENTRY INITIALIZATION
    // ============================================================================
    telemetry_active := true
    telemetry_trade_id := signal_id
    // ENTRY timestamp is the signal candle time already used for trade_id
    telemetry_entry_time := signal_candle_time
    telemetry_entry_price := sig_entry
    telemetry_direction := signal_direction
    telemetry_stop_price  := sig_stop
    // Reset telemetry tracking values
    telemetry_max_mfe := 0.0
    telemetry_mae_global := 0.0
    telemetry_be_triggered := false
    // Reset webhook sent flags
    telemetry_entry_sent := true          // entry already sent
    telemetry_be_sent := false
    telemetry_exit_be_sent := false
    telemetry_exit_sl_sent := false
    // Mark telemetry session as initialized
    telemetry_initialized_this_session := true
    // ============================================================================
    // END TELEMETRY ENTRY INITIALIZATION
    // ============================================================================
    
    // Mark that ENTRY webhook has been sent for this signal
    array.set(signal_entry_webhook_sent, last_index, true)
    
    // BULLETPROOF: Check for duplicate signal_id before adding to tracking arrays
    int existing_idx = find_signal_index(signal_id)
    if existing_idx < 0
        // Signal ID is unique - add to tracking arrays
        array.push(active_signal_ids, signal_id)
        array.push(active_signal_indices, last_index)  // BULLETPROOF: Store the signal array index
        array.push(be_trigger_sent_flags, false)
        array.push(completion_sent_flags, false)
        array.push(be_exit_sent_flags, false)   // Track EXIT_BE separately
        array.push(sl_exit_sent_flags, false)   // Track EXIT_SL separately
    // NOTE: signal_entry_bar_index already pushed when signal was added to tracking arrays
    webhook_sent_this_bar := true
    
    // NOW reset state for next signal (AFTER webhook sent)
    active_signal := "None"
    waiting_for_confirmation := false
    trade_ready := false

// TEST: Send heartbeat alert every bar to verify alert system
// REMOVED: Heartbeat alerts (using export system instead)
// if barstate.isconfirmed
//     string heartbeat = '{"event_type":"HEARTBEAT","timestamp":"' + f_isoTimestamp(time) + '","signal_count":' + str.tostring(array.size(signal_entries)) + ',"realtime":' + str.tostring(barstate.isrealtime) + '}'
//     alert(heartbeat, alert.freq_once_per_bar_close)

// 2. MFE UPDATE WEBHOOK - ROBUST BATCH MODE
// HYBRID SYNC SYSTEM: Includes ALL active signals (last 500)
// Prevents orphaned signals by looping arrays directly
if barstate.isconfirmed and barstate.isrealtime and array.size(signal_entries) > 0
    // Build batch payload for all active signals
    string batch_payload = ""
    int signals_in_batch = 0
    int signals_skipped = 0
    
    // Declare loop variables outside loop
    float current_mfe_be = 0.0
    float current_mfe_none = 0.0
    float sig_mae = 0.0
    bool sig_be_triggered = false
    float sig_entry = na
    float sig_stop = na
    string sig_session = ""
    string signal_id = ""
    string signal_json = ""
    string test_add = ""
    int new_size = 0
    
    // Round-robin scan starting from cursor (clamp to bounds)
    int cursor_start = math.min(mfe_batch_cursor, array.size(signal_entries) - 1)
    int scan_limit = 500
    int scanned = 0
    int last_i = cursor_start
    
    for i = cursor_start to 0
        scanned := scanned + 1
        if scanned > scan_limit or signals_in_batch >= 12
            last_i := i
            break
        
        // Bounds check for all arrays
        if i >= array.size(signal_entry_times) or i >= array.size(signal_directions)
            continue
        
        // Get signal data
        int confirm_time = array.get(signal_entry_times, i)
        int tri_time = i < array.size(signal_triangle_times) ? array.get(signal_triangle_times, i) : confirm_time
        string sig_direction = array.get(signal_directions, i)
        
        // Check if No-BE stopped (signal completed)
        bool sig_no_be_stopped = i < array.size(signal_no_be_stopped) ? array.get(signal_no_be_stopped, i) : false
        
        // Skip completed signals (only include ACTIVE)
        if sig_no_be_stopped
            continue
        
        last_i := i
        
        // Include this ACTIVE signal
        // Get MFE/MAE data with bounds checks
        current_mfe_be := i < array.size(signal_be_mfes) ? array.get(signal_be_mfes, i) : 0.0
        current_mfe_none := i < array.size(signal_mfes) ? array.get(signal_mfes, i) : 0.0
        sig_mae := i < array.size(signal_maes) ? array.get(signal_maes, i) : 0.0
        sig_be_triggered := i < array.size(signal_be_triggered) ? array.get(signal_be_triggered, i) : false
        
        // Build trade_id from TRIANGLE TIME (canonical)
        signal_id := f_buildTradeId(tri_time, sig_direction)
        
        // Get all signal data
        sig_entry := i < array.size(signal_entries) ? array.get(signal_entries, i) : na
        sig_stop := i < array.size(signal_stops) ? array.get(signal_stops, i) : na
        sig_session := f_sessionLabel(tri_time)  // Calculate session from triangle time
        
        // Build MFE_UPDATE_BATCH signal JSON (exact schema for confirmed_signals_ledger)
        signal_json := '"trade_id":"' + signal_id + '","triangle_time":' + str.tostring(tri_time) + ',"confirmation_time":' + str.tostring(confirm_time) + ',"direction":"' + sig_direction + '","session":"' + sig_session + '","entry_price":' + f_num(sig_entry) + ',"stop_loss":' + f_num(sig_stop) + ',"be_mfe":' + f_num(current_mfe_be) + ',"no_be_mfe":' + f_num(current_mfe_none) + ',"mae_global_r":' + f_num(math.min(sig_mae, 0.0)) + ',"completed":' + str.tostring(sig_no_be_stopped)
            
            // Check payload size before adding (stay under 4000 chars)
        test_add := signals_in_batch > 0 ? ",{" + signal_json + "}" : "{" + signal_json + "}"
        new_size := str.length(batch_payload) + str.length(test_add)
        
        if new_size < 3900
            // Add to batch
            batch_payload := signals_in_batch > 0 ? batch_payload + ",{" + signal_json + "}" : "{" + signal_json + "}"
            signals_in_batch := signals_in_batch + 1
        else
            // Payload full - stop scanning
            break
    
    // Update cursor for next batch
    mfe_batch_cursor := cursor_start - signals_in_batch
    if mfe_batch_cursor < 0
        mfe_batch_cursor := array.size(signal_entries) - 1
    
    // Send MFE batch alert
    string ts = str.format("{0,date,yyyy-MM-dd}T{0,time,HH:mm:ss}", time)
    if signals_in_batch > 0
        string batch_envelope = '{"event_type":"MFE_UPDATE_BATCH","timestamp":"' + ts + '","signals":[' + batch_payload + '],"batch_size":' + str.tostring(signals_in_batch) + ',"skipped":' + str.tostring(signals_skipped) + '}'
        alert(batch_envelope, alert.freq_once_per_bar_close)

// ============================================================================
// TELEMETRY ENGINE ‚Äî MFE_UPDATE SENDER (DISABLED - Using batch system instead)
// ============================================================================
// DISABLED: Old individual MFE updates replaced by batch system above
// This prevents duplicate alerts and rate limiting
// END TELEMETRY MFE_UPDATE ENGINE

// ============================================================================
// TELEMETRY ENGINE ‚Äî BE_TRIGGERED SENDER (DISABLED - Using main system)
// ============================================================================
// DISABLED: Duplicate BE alerts handled by main system (line 1600+)
// END TELEMETRY BE_TRIGGERED ENGINE

// ============================================================================
// TELEMETRY ENGINE ‚Äî EXIT_BE SENDER
// ============================================================================
if telemetry_active and telemetry_be_triggered and barstate.isrealtime
    if not telemetry_exit_be_sent and not telemetry_exit_sl_sent
        bool be_stop_hit = false
        if telemetry_direction == "Bullish" or telemetry_direction == "LONG"
            be_stop_hit := (low <= telemetry_entry_price)
        else
            be_stop_hit := (high >= telemetry_entry_price)
        if be_stop_hit
            // READ VISUAL ARRAYS for true MFE/MAE values
            int exit_be_idx = array.size(signal_entries) - 1
            float true_be_mfe_exit = exit_be_idx >= 0 ? array.get(signal_be_mfes, exit_be_idx) : telemetry_max_mfe
            float true_no_be_mfe_exit = exit_be_idx >= 0 ? array.get(signal_mfes, exit_be_idx) : telemetry_max_mfe
            float sig_entry_exit = exit_be_idx >= 0 ? array.get(signal_entries, exit_be_idx) : telemetry_entry_price
            float sig_risk_exit = exit_be_idx >= 0 ? array.get(signal_risks, exit_be_idx) : 1.0
            string sig_dir_exit = exit_be_idx >= 0 ? array.get(signal_directions, exit_be_idx) : telemetry_direction
            float mae_source_low_exit = exit_be_idx >= 0 ? array.get(signal_lowest_lows, exit_be_idx) : 0.0
            float mae_source_high_exit = exit_be_idx >= 0 ? array.get(signal_highest_highs, exit_be_idx) : 0.0
            // --- Use f_calcMaeR for consistent MAE calculation ---
            float true_mae_global_exit = f_calcMaeR(sig_dir_exit, sig_entry_exit, mae_source_low_exit, mae_source_high_exit, sig_risk_exit)
            string exit_be_payload = f_buildPayload(EVENT_EXIT_BREAK_EVEN, telemetry_trade_id, telemetry_direction, telemetry_entry_price, telemetry_stop_price, telemetry_entry_price, 1.0, contract_size, true_be_mfe_exit, true_no_be_mfe_exit, true_mae_global_exit, true_be_mfe_exit, telemetry_entry_price, "be_stop_loss_hit", 0.0, 0.0, 0.0, "FVG_CORE", "EXIT_BE", bias, syminfo.ticker, timeframe.period, time)
            // DISABLED: Duplicate alert - main system handles EXIT_BE (line 1655)
            // alert(exit_be_payload, alert.freq_once_per_bar_close)
            telemetry_exit_be_sent := true
            telemetry_active := false
// END TELEMETRY EXIT_BE ENGINE

// ============================================================================
// TELEMETRY ENGINE ‚Äî EXIT_SL SENDER
// ============================================================================
if telemetry_active and barstate.isrealtime
    if not telemetry_exit_sl_sent and not telemetry_exit_be_sent
        bool sl_hit = false
        if telemetry_direction == "Bullish" or telemetry_direction == "LONG"
            sl_hit := (low <= telemetry_stop_price)
        else
            sl_hit := (high >= telemetry_stop_price)
        if sl_hit
            // READ VISUAL ARRAYS for true MFE/MAE values
            int exit_sl_idx = array.size(signal_entries) - 1
            float true_be_mfe_sl = exit_sl_idx >= 0 ? array.get(signal_be_mfes, exit_sl_idx) : telemetry_max_mfe
            float true_no_be_mfe_sl = exit_sl_idx >= 0 ? array.get(signal_mfes, exit_sl_idx) : telemetry_max_mfe
            float sig_entry_sl = exit_sl_idx >= 0 ? array.get(signal_entries, exit_sl_idx) : telemetry_entry_price
            float sig_risk_sl = exit_sl_idx >= 0 ? array.get(signal_risks, exit_sl_idx) : 1.0
            string sig_dir_sl = exit_sl_idx >= 0 ? array.get(signal_directions, exit_sl_idx) : telemetry_direction
            float mae_source_low_sl = exit_sl_idx >= 0 ? array.get(signal_lowest_lows, exit_sl_idx) : 0.0
            float mae_source_high_sl = exit_sl_idx >= 0 ? array.get(signal_highest_highs, exit_sl_idx) : 0.0
            // --- Use f_calcMaeR for consistent MAE calculation ---
            float true_mae_global_sl = f_calcMaeR(sig_dir_sl, sig_entry_sl, mae_source_low_sl, mae_source_high_sl, sig_risk_sl)
            string exit_sl_payload = f_buildPayload(EVENT_EXIT_STOP_LOSS, telemetry_trade_id, telemetry_direction, telemetry_entry_price, telemetry_stop_price, telemetry_be_triggered ? telemetry_entry_price : float(na), 1.0, contract_size, true_be_mfe_sl, true_no_be_mfe_sl, true_mae_global_sl, true_no_be_mfe_sl, telemetry_stop_price, "original_stop_loss_hit", 0.0, 0.0, 0.0, "FVG_CORE", "EXIT_SL", bias, syminfo.ticker, timeframe.period, time)
            // DISABLED: Duplicate alert - main system handles EXIT_SL (line 1694)
            // alert(exit_sl_payload, alert.freq_once_per_bar_close)
            telemetry_exit_sl_sent := true
            telemetry_active := false
// END TELEMETRY EXIT_SL ENGINE

// 3. BE TRIGGER WEBHOOK
// Send when BE=1 is triggered for any active signal
// CRITICAL: Only send on real-time bars to prevent historical replay spam
if barstate.isconfirmed and barstate.isrealtime and array.size(signal_be_triggered) > 0 and array.size(active_signal_ids) > 0
    // Loop through all active signals
    for sig_idx = 0 to array.size(active_signal_ids) - 1
        signal_id_for_be = array.get(active_signal_ids, sig_idx)
        be_sent_flag = array.get(be_trigger_sent_flags, sig_idx)
        
        // BULLETPROOF: Get the actual signal array index from parallel array
        int signal_array_idx = array.get(active_signal_indices, sig_idx)
        
        // Validate that signal_array_idx is within bounds
        if signal_array_idx >= 0 and signal_array_idx < array.size(signal_be_triggered)
            // MODIFIED: Send BE_TRIGGERED for ALL active signals that hit +1R
            if not be_sent_flag
                bool be_was_triggered = array.get(signal_be_triggered, signal_array_idx)
                
                if be_was_triggered
                    // Retrieve signal data from arrays
                    string sig_direction = array.get(signal_directions, signal_array_idx)
                    float sig_entry = array.get(signal_entries, signal_array_idx)
                    float sig_stop = array.get(signal_stops, signal_array_idx)
                    float sig_risk = array.get(signal_risks, signal_array_idx)
                    
                    float current_be_mfe = array.get(signal_be_mfes, signal_array_idx)
                    float current_no_be_mfe = array.get(signal_mfes, signal_array_idx)
                    // CRITICAL ENFORCEMENT: BE MFE can NEVER exceed No BE MFE
                    current_be_mfe := math.min(current_be_mfe, current_no_be_mfe)
                    
                    // Get global MAE for this signal
                    float sig_mae = array.get(signal_maes, signal_array_idx)
                    // --- Ensure MAE is never positive ---
                    sig_mae := math.min(sig_mae, 0.0)
                    
                    // Calculate target prices for BE trigger
                    float be_target_1r = sig_direction == "Bullish" ? sig_entry + sig_risk : sig_entry - sig_risk
                    float be_target_2r = sig_direction == "Bullish" ? sig_entry + (2 * sig_risk) : sig_entry - (2 * sig_risk)
                    float be_target_3r = sig_direction == "Bullish" ? sig_entry + (3 * sig_risk) : sig_entry - (3 * sig_risk)
                    
                    // Build telemetry payload for BE_TRIGGERED event
                    // mfe_R = BE MFE (capped at +1R since BE triggered), mae_R = No-BE MFE (continues tracking)
                    string be_trigger_payload = f_buildPayload(EVENT_BE_TRIGGERED, signal_id_for_be, sig_direction, sig_entry, sig_stop, sig_entry, 1.0, contract_size, current_be_mfe, current_no_be_mfe, sig_mae, float(na), float(na), "", be_target_1r, be_target_2r, be_target_3r, "FVG_CORE", "BE_PROTECTED", bias, syminfo.ticker, timeframe.period, signal_candle_time)
                    
                    // REMOVED: BE trigger webhook (using export system instead)
                    // alert(be_trigger_payload, alert.freq_once_per_bar_close)
                    array.set(be_trigger_sent_flags, sig_idx, true)

// 4. DUAL EXIT WEBHOOKS
// Send EXIT_BE when BE stop is hit (for BE=1 strategy)
// Send EXIT_SL when original stop is hit (for No BE strategy)
// CRITICAL: Both events are sent separately for proper dual-status tracking
if barstate.isconfirmed and barstate.isrealtime and array.size(signal_be_stopped) > 0 and array.size(signal_no_be_stopped) > 0 and array.size(active_signal_ids) > 0
    // BULLETPROOF: Loop BACKWARDS to prevent array out of bounds when removing elements
    for sig_idx = array.size(active_signal_ids) - 1 to 0
        signal_id_for_completion = array.get(active_signal_ids, sig_idx)
        bool be_exit_sent = array.get(be_exit_sent_flags, sig_idx)
        bool sl_exit_sent = array.get(sl_exit_sent_flags, sig_idx)
        
        // BULLETPROOF: Get the actual signal array index from parallel array
        int signal_array_idx = array.get(active_signal_indices, sig_idx)
        
        // Validate that signal_array_idx is within bounds
        if signal_array_idx >= 0 and signal_array_idx < array.size(signal_be_stopped)
            bool be_stopped = array.get(signal_be_stopped, signal_array_idx)
            bool no_be_stopped = array.get(signal_no_be_stopped, signal_array_idx)
            int entry_bar = array.get(signal_entry_bar_index, signal_array_idx)
            int bars_since_entry = bar_index - entry_bar
            
            // Only process if trade has been active for at least 1 bar
            if bars_since_entry >= 1
                // Retrieve signal data from arrays (needed for both exit types)
                string sig_direction = array.get(signal_directions, signal_array_idx)
                float sig_entry = array.get(signal_entries, signal_array_idx)
                float sig_stop = array.get(signal_stops, signal_array_idx)
                float sig_risk = array.get(signal_risks, signal_array_idx)
                bool sig_be_triggered = array.get(signal_be_triggered, signal_array_idx)
                float final_be_mfe = array.get(signal_be_mfes, signal_array_idx)
                float final_no_be_mfe = array.get(signal_mfes, signal_array_idx)
                final_be_mfe := math.min(final_be_mfe, final_no_be_mfe)
                
                // Get global MAE for this signal
                float sig_mae = array.get(signal_maes, signal_array_idx)
                // --- Ensure MAE is never positive ---
                sig_mae := math.min(sig_mae, 0.0)
                
                // Calculate target prices
                float exit_target_1r = sig_direction == "Bullish" ? sig_entry + sig_risk : sig_entry - sig_risk
                float exit_target_2r = sig_direction == "Bullish" ? sig_entry + (2 * sig_risk) : sig_entry - (2 * sig_risk)
                float exit_target_3r = sig_direction == "Bullish" ? sig_entry + (3 * sig_risk) : sig_entry - (3 * sig_risk)
                
                // SEND EXIT_BE when BE stop is hit (BE=1 strategy completed)
                // CRITICAL: Only send EXIT_BE if BE was actually triggered (reached +1R)
                // mfe_R = BE MFE (final), mae_R = No-BE MFE (final), final_mfe_R = BE MFE (relevant for this exit type)
                if be_stopped and sig_be_triggered and not be_exit_sent
                    // REMOVED: EXIT_BE webhook (using export system instead)
                    // string be_payload = f_buildPayload(EVENT_EXIT_BREAK_EVEN, signal_id_for_completion, sig_direction, sig_entry, sig_stop, sig_entry, 1.0, contract_size, final_be_mfe, final_no_be_mfe, sig_mae, final_be_mfe, sig_entry, "be_stop_loss_hit", exit_target_1r, exit_target_2r, exit_target_3r, "FVG_CORE", "EXIT_BE", bias, syminfo.ticker, timeframe.period, signal_candle_time)
                    // alert(be_payload, alert.freq_once_per_bar_close)
                    array.set(be_exit_sent_flags, sig_idx, true)
                
                // SEND EXIT_SL when original stop is hit (No BE strategy completed)
                // mfe_R = BE MFE (final), mae_R = No-BE MFE (final), final_mfe_R = No-BE MFE (relevant for this exit type)
                if no_be_stopped and not sl_exit_sent
                    // REMOVED: EXIT_SL webhook (using export system instead)
                    // string sl_payload = f_buildPayload(EVENT_EXIT_STOP_LOSS, signal_id_for_completion, sig_direction, sig_entry, sig_stop, sig_be_triggered ? sig_entry : float(na), 1.0, contract_size, final_be_mfe, final_no_be_mfe, sig_mae, final_no_be_mfe, sig_stop, "original_stop_loss_hit", exit_target_1r, exit_target_2r, exit_target_3r, "FVG_CORE", "EXIT_SL", bias, syminfo.ticker, timeframe.period, signal_candle_time)
                    // alert(sl_payload, alert.freq_once_per_bar_close)
                    array.set(sl_exit_sent_flags, sig_idx, true)
                
                // Only remove from tracking when BOTH exits have been sent (or No BE hit which ends everything)
                // If no_be_stopped, the trade is fully complete for both strategies
                if no_be_stopped and array.get(sl_exit_sent_flags, sig_idx)
                    array.remove(active_signal_ids, sig_idx)
                    array.remove(active_signal_indices, sig_idx)
                    array.remove(be_trigger_sent_flags, sig_idx)
                    array.remove(completion_sent_flags, sig_idx)
                    array.remove(be_exit_sent_flags, sig_idx)
                    array.remove(sl_exit_sent_flags, sig_idx)

// ============================================================================
// TELEMETRY ENGINE ‚Äî SAFETY RESET ON FIRST BAR
// ============================================================================
// When the script (re)loads on a chart, we do NOT want to resume a half-
// initialized telemetry state from a prior run. Visual MFE/labels maintain
// their own state, but telemetry should start fresh and only track trades
// that occur after this session begins.
// ============================================================================
if barstate.isfirst
    telemetry_active := false
    telemetry_trade_id := ""
    telemetry_entry_time := na
    telemetry_entry_price := na
    telemetry_stop_price := na
    telemetry_max_mfe := 0.0
    telemetry_mae_global := 0.0
    telemetry_be_triggered := false
    telemetry_entry_sent := false
    telemetry_be_sent := false
    telemetry_exit_be_sent := false
    telemetry_exit_sl_sent := false
    telemetry_initialized_this_session := false
// ============================================================================
// END TELEMETRY SAFETY RESET
// ============================================================================


// ============================================================================
// INDICATOR DATA EXPORT - One-Time Bulk Export for Inspection
// ============================================================================

// ============================================================================
// EXPORT V2 - BULLETPROOF SYSTEM
// ============================================================================
// Larger batches (50 signals), built-in delays (5 bars), exact Signal List Table logic

int EXPORT_V2_BATCH_SIZE = 15  // Optimized for 4096 char limit with all fields

// Export state
var int export_batch_number = 0
var int export_signals_sent = 0
var bool export_complete = false
var int export_last_bar = 0
var int export_last_day = 0  // Track day to auto-reset daily

// Auto-reset export daily (zero manual involvement)
int current_day = dayofmonth(time, "America/New_York")
if current_day != export_last_day and export_complete
    export_batch_number := 0
    export_signals_sent := 0
    export_complete := false
    export_last_bar := 0
    export_last_day := current_day

// EXPORT V2 LOGIC - Runs on barstate.islast when arrays are fully populated
if ENABLE_EXPORT and not export_complete and barstate.islast
    int bars_since_last = bar_index - export_last_bar
    
    // Wait EXPORT_DELAY_BARS between batches (default 5 bars = 5 minutes)
    if bars_since_last >= EXPORT_DELAY_BARS or export_batch_number == 0
        int start_idx = export_batch_number * EXPORT_V2_BATCH_SIZE
        int end_idx = math.min(start_idx + EXPORT_V2_BATCH_SIZE, array.size(signal_entries))
        
        if start_idx < array.size(signal_entries)
            string batch_signals = ""
            int signals_in_batch = 0
            
            // Loop through batch range
            for i = start_idx to end_idx - 1
                // Get times: triangle time (canonical) and confirmation time (metadata)
                int confirm_time = array.get(signal_entry_times, i)
                int tri_time = i < array.size(signal_triangle_times) ? array.get(signal_triangle_times, i) : confirm_time
                
                // Get signal data (EXACT same as Signal List Table)
                float sig_entry = array.get(signal_entries, i)
                float sig_stop = array.get(signal_stops, i)
                
                // SKIP signals with na entry or stop
                if na(sig_entry) or na(sig_stop)
                    continue
                
                string sig_dir = array.get(signal_directions, i)
                float sig_be_mfe = array.get(signal_be_mfes, i)
                float sig_no_be_mfe = array.get(signal_mfes, i)
                float sig_mae = array.get(signal_maes, i)
                bool sig_completed = array.get(signal_no_be_stopped, i)
                
                // Build trade_id from TRIANGLE TIME (canonical)
                string trade_id = str.tostring(year(tri_time, "America/New_York")) + 
                                 str.tostring(month(tri_time, "America/New_York"), "00") +
                                 str.tostring(dayofmonth(tri_time, "America/New_York"), "00") + "_" +
                                 str.tostring(hour(tri_time, "America/New_York"), "00") +
                                 str.tostring(minute(tri_time, "America/New_York"), "00") +
                                 str.tostring(second(tri_time, "America/New_York"), "00") + "000_" +
                                 (sig_dir == "Bullish" ? "BULLISH" : "BEARISH")
                
                // Build date string from TRIANGLE TIME
                string date_str = str.tostring(year(tri_time, "America/New_York")) + '-' +
                                 str.tostring(month(tri_time, "America/New_York"), "00") + '-' +
                                 str.tostring(dayofmonth(tri_time, "America/New_York"), "00")
                
                // Calculate session from TRIANGLE TIME
                int h = hour(tri_time, "America/New_York")
                int m = minute(tri_time, "America/New_York")
                string session = "AFTER_HOURS"
                if h >= 20 and h <= 23
                    session := "ASIA"
                else if h >= 0 and h <= 5
                    session := "LONDON"
                else if h == 6 or (h == 8 and m <= 29)
                    session := "NY PRE"
                else if (h == 8 and m >= 30) or (h >= 9 and h <= 11)
                    session := "NY AM"
                else if h == 12
                    session := "NY LUNCH"
                else if h >= 13 and h <= 15
                    session := "NY PM"
                
                // Calculate age from TRIANGLE TIME
                int age_ms = time - tri_time
                int age_days = int(age_ms / 86400000)
                int age_hours = int((age_ms % 86400000) / 3600000)
                int age_mins = int((age_ms % 3600000) / 60000)
                string age = ""
                if age_days > 0
                    age := str.tostring(age_days) + "d " + str.tostring(age_hours) + "h"
                else if age_hours > 0
                    age := str.tostring(age_hours) + "h " + str.tostring(age_mins) + "m"
                else
                    age := str.tostring(age_mins) + "m"
                
                // Build JSON with ALL fields (triangle_time and confirmation_time as metadata)
                string part1 = '{"trade_id":"' + trade_id + '","triangle_time":' + str.tostring(tri_time) + ',"confirmation_time":' + str.tostring(confirm_time) + ',"date":"' + date_str + '","direction":"' + sig_dir + '"'
                string part2 = ',"session":"' + session + '","age":"' + age + '"'
                string part3 = ',"entry":' + str.tostring(sig_entry) + ',"stop":' + str.tostring(sig_stop)
                string part4 = ',"be_mfe":' + str.tostring(sig_be_mfe) + ',"no_be_mfe":' + str.tostring(sig_no_be_mfe)
                string part5 = ',"mae":' + str.tostring(sig_mae) + ',"completed":' + str.tostring(sig_completed) + '}'
                string signal_json = part1 + part2 + part3 + part4 + part5
                
                // Check payload size before adding
                string test_add = signals_in_batch > 0 ? batch_signals + "," + signal_json : signal_json
                if str.length(test_add) < 3800  // Leave room for wrapper
                    // Add to batch
                    if signals_in_batch > 0
                        batch_signals := batch_signals + ","
                    
                    batch_signals := batch_signals + signal_json
                    signals_in_batch := signals_in_batch + 1
                else
                    // Batch full, stop adding
                    break
            
            // Send batch if we have signals
            if signals_in_batch > 0
                string export_payload = '{"event_type":"INDICATOR_EXPORT_V2"' +
                                       ',"batch_number":' + str.tostring(export_batch_number) +
                                       ',"batch_size":' + str.tostring(signals_in_batch) +
                                       ',"total_signals":' + str.tostring(array.size(signal_entries)) +
                                       ',"signals":[' + batch_signals + ']}'
                
                alert(export_payload, alert.freq_once_per_bar_close)
                
                export_batch_number := export_batch_number + 1
                export_signals_sent := export_signals_sent + signals_in_batch
                export_last_bar := bar_index
            
            // Check if complete
            if end_idx >= array.size(signal_entries)
                export_complete := true
        else
            export_complete := true

// ============================================================================
// ALL SIGNALS EXPORT V2 - Export every triangle (pending, confirmed, cancelled)
// ============================================================================

int ALL_SIGNALS_BATCH_SIZE = 10  // Smaller due to many fields (Entry/Stop/Risk/HTF)
var int all_export_batch = 0
var int all_export_sent = 0
var bool all_export_complete = false
var int all_export_last_bar = 0
var int all_export_last_day = 0

// Auto-reset All Signals export daily
int current_day_all = dayofmonth(time, "America/New_York")
if current_day_all != all_export_last_day and all_export_complete
    all_export_batch := 0
    all_export_sent := 0
    all_export_complete := false
    all_export_last_bar := 0
    all_export_last_day := current_day_all

// Allow All Signals export independently for backfill
if ENABLE_ALL_SIGNALS_EXPORT and not all_export_complete and barstate.islast
    int bars_since = bar_index - all_export_last_bar
    
    if bars_since >= EXPORT_DELAY_BARS or all_export_batch == 0
        int start_idx = all_export_batch * ALL_SIGNALS_BATCH_SIZE
        int end_idx = math.min(start_idx + ALL_SIGNALS_BATCH_SIZE, array.size(all_signal_times))
        
        if start_idx < array.size(all_signal_times)
            string batch_signals = ""
            int signals_in_batch = 0
            
            for i = start_idx to end_idx - 1
                int sig_time = array.get(all_signal_times, i)
                string sig_dir = array.get(all_signal_directions, i)
                string sig_status = array.get(all_signal_status, i)
                int confirm_time = array.get(all_signal_confirmation_times, i)
                int bars_to_confirm = array.get(all_signal_bars_to_confirm, i)
                
                // Cross-reference for Entry/Stop/Risk (only for CONFIRMED)
                string entry_val = "null"
                string stop_val = "null"
                string risk_val = "null"
                
                if sig_status == "CONFIRMED"
                    int confirmed_idx = array.get(all_signal_confirmed_index, i)
                    if confirmed_idx >= 0 and confirmed_idx < array.size(signal_entries)
                        float e = array.get(signal_entries, confirmed_idx)
                        float s = array.get(signal_stops, confirmed_idx)
                        if not na(e) and not na(s)
                            entry_val := str.tostring(e)
                            stop_val := str.tostring(s)
                            risk_val := str.tostring(math.abs(e - s))
                    else
                        // Fallback: time-window cross-reference
                        for j = 0 to array.size(signal_entry_times) - 1
                            int entry_time = array.get(signal_entry_times, j)
                            string entry_dir = array.get(signal_directions, j)
                            if math.abs(entry_time - sig_time) < 600000 and entry_dir == sig_dir
                                float e = array.get(signal_entries, j)
                                float s = array.get(signal_stops, j)
                                if not na(e) and not na(s)
                                    entry_val := str.tostring(e)
                                    stop_val := str.tostring(s)
                                    risk_val := str.tostring(math.abs(e - s))
                                break
                
                // HTF bias (stored at signal time)
                string stored_daily = array.get(all_signal_daily_bias, i)
                string stored_h4 = array.get(all_signal_h4_bias, i)
                string stored_h1 = array.get(all_signal_h1_bias, i)
                string stored_m15 = array.get(all_signal_m15_bias, i)
                string stored_m5 = array.get(all_signal_m5_bias, i)
                string stored_m1 = array.get(all_signal_m1_bias, i)
                
                string d_bias = stored_daily == "Bullish" ? "BULL" : stored_daily == "Bearish" ? "BEAR" : "NEUT"
                string h4_bias_str = stored_h4 == "Bullish" ? "BULL" : stored_h4 == "Bearish" ? "BEAR" : "NEUT"
                string h1_bias_str = stored_h1 == "Bullish" ? "BULL" : stored_h1 == "Bearish" ? "BEAR" : "NEUT"
                string m15_bias_str = stored_m15 == "Bullish" ? "BULL" : stored_m15 == "Bearish" ? "BEAR" : "NEUT"
                string m5_bias_str = stored_m5 == "Bullish" ? "BULL" : stored_m5 == "Bearish" ? "BEAR" : "NEUT"
                string m1_bias_str = stored_m1 == "Bullish" ? "BULL" : stored_m1 == "Bearish" ? "BEAR" : "NEUT"
                
                // Build trade_id
                string trade_id = str.tostring(year(sig_time, "America/New_York")) + 
                                 str.tostring(month(sig_time, "America/New_York"), "00") +
                                 str.tostring(dayofmonth(sig_time, "America/New_York"), "00") + "_" +
                                 str.tostring(hour(sig_time, "America/New_York"), "00") +
                                 str.tostring(minute(sig_time, "America/New_York"), "00") +
                                 str.tostring(second(sig_time, "America/New_York"), "00") + "000_" +
                                 (sig_dir == "Bullish" ? "BULLISH" : "BEARISH")
                
                // Build JSON with all fields
                string signal_json = '{"trade_id":"' + trade_id + '","direction":"' + sig_dir + '","status":"' + sig_status + '","signal_time":' + str.tostring(sig_time) + ',"confirmation_time":' + str.tostring(confirm_time) + ',"bars_to_confirm":' + str.tostring(bars_to_confirm) + ',"entry":' + entry_val + ',"stop":' + stop_val + ',"risk":' + risk_val + ',"htf_daily":"' + d_bias + '","htf_4h":"' + h4_bias_str + '","htf_1h":"' + h1_bias_str + '","htf_15m":"' + m15_bias_str + '","htf_5m":"' + m5_bias_str + '","htf_1m":"' + m1_bias_str + '"}'
                
                // Check payload size before adding
                string test_add = signals_in_batch > 0 ? batch_signals + "," + signal_json : signal_json
                if str.length(test_add) < 3800
                    if signals_in_batch > 0
                        batch_signals := batch_signals + ","
                    
                    batch_signals := batch_signals + signal_json
                    signals_in_batch := signals_in_batch + 1
                else
                    break
            
            if signals_in_batch > 0
                string all_signals_payload = '{"event_type":"ALL_SIGNALS_EXPORT"' + ',"batch_number":' + str.tostring(all_export_batch) + ',"batch_size":' + str.tostring(signals_in_batch) + ',"total_signals":' + str.tostring(array.size(all_signal_times)) + ',"signals":[' + batch_signals + ']}'
                
                alert(all_signals_payload, alert.freq_once_per_bar_close)
                
                all_export_batch := all_export_batch + 1
                all_export_sent := all_export_sent + signals_in_batch
                all_export_last_bar := bar_index
            
            if end_idx >= array.size(all_signal_times)
                all_export_complete := true
        else
            all_export_complete := true

// ============================================================================
// SIGNAL LIST TABLE - View all signals directly on chart
// ============================================================================

// Signal list inputs are now at the top of the file

if SHOW_SIGNAL_LIST and barstate.islast
    string list_pos = SIGNAL_LIST_POSITION == "top_left" ? position.top_left :
                     SIGNAL_LIST_POSITION == "top_center" ? position.top_center :
                     SIGNAL_LIST_POSITION == "top_right" ? position.top_right :
                     SIGNAL_LIST_POSITION == "middle_left" ? position.middle_left :
                     SIGNAL_LIST_POSITION == "middle_center" ? position.middle_center :
                     SIGNAL_LIST_POSITION == "bottom_left" ? position.bottom_left :
                     SIGNAL_LIST_POSITION == "bottom_center" ? position.bottom_center :
                     SIGNAL_LIST_POSITION == "bottom_right" ? position.bottom_right : position.middle_right
    
    var table signal_list_table = table.new(list_pos, 11, 22, border_width=1)
    
    // Header
    table.cell(signal_list_table, 0, 0, "SIGNAL LIST", text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
    table.merge_cells(signal_list_table, 0, 0, 5, 0)
    
    // Column headers
    table.cell(signal_list_table, 0, 1, "Date", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 1, 1, "Time", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 2, 1, "Age", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 3, 1, "Session", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 4, 1, "Dir", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 5, 1, "Entry", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 6, 1, "Stop", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 7, 1, "BE MFE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 8, 1, "No-BE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 9, 1, "MAE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(signal_list_table, 10, 1, "Status", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    
    // Filter and show signals
    int row = 2
    int signals_shown = 0
    int signals_skipped = 0
    
    for i = 0 to array.size(signal_entries) - 1
        if row >= 22 or signals_shown >= SIGNAL_LIST_COUNT  // Table limit or page limit
            break
        
        // Check filter
        bool sig_is_completed = array.get(signal_no_be_stopped, i)
        bool show_signal = SIGNAL_LIST_FILTER == "ALL" or 
                          (SIGNAL_LIST_FILTER == "ACTIVE" and not sig_is_completed) or
                          (SIGNAL_LIST_FILTER == "COMPLETED" and sig_is_completed)
        
        if not show_signal
            continue
        
        // Skip signals before start index
        if signals_skipped < SIGNAL_LIST_START
            signals_skipped := signals_skipped + 1
            continue
        
        int sig_time = array.get(signal_entry_times, i)
        
        // Date format: 16-Nov-25
        int d = dayofmonth(sig_time, "America/New_York")
        int m = month(sig_time, "America/New_York")
        int y = year(sig_time, "America/New_York") - 2000
        string month_name = m == 1 ? "Jan" : m == 2 ? "Feb" : m == 3 ? "Mar" : m == 4 ? "Apr" : 
                           m == 5 ? "May" : m == 6 ? "Jun" : m == 7 ? "Jul" : m == 8 ? "Aug" :
                           m == 9 ? "Sep" : m == 10 ? "Oct" : m == 11 ? "Nov" : "Dec"
        string sig_date = str.tostring(d) + "-" + month_name + "-" + str.tostring(y)
        
        // Time: HH:MM
        string sig_time_str = str.tostring(hour(sig_time, "America/New_York"), "00") + ":" +
                             str.tostring(minute(sig_time, "America/New_York"), "00")
        
        // Age calculation
        int age_ms = time - sig_time
        int age_days = int(age_ms / 86400000)
        int age_hours = int((age_ms % 86400000) / 3600000)
        int age_mins = int((age_ms % 3600000) / 60000)
        string age_str = ""
        if age_days > 0
            age_str := str.tostring(age_days) + "d " + str.tostring(age_hours) + "h"
        else if age_hours > 0
            age_str := str.tostring(age_hours) + "h " + str.tostring(age_mins) + "m"
        else
            age_str := str.tostring(age_mins) + "m"
        
        // Session
        int h = hour(sig_time, "America/New_York")
        int min = minute(sig_time, "America/New_York")
        string sig_session = "AH"
        if h >= 20 and h <= 23
            sig_session := "ASIA"
        else if h >= 0 and h <= 5
            sig_session := "LON"
        else if h == 6 or (h == 8 and min <= 29)
            sig_session := "PRE"
        else if (h == 8 and min >= 30) or (h >= 9 and h <= 11)
            sig_session := "AM"
        else if h == 12
            sig_session := "LUN"
        else if h >= 13 and h <= 15
            sig_session := "PM"
        
        string sig_dir = array.get(signal_directions, i)
        float sig_entry = array.get(signal_entries, i)
        float sig_stop = array.get(signal_stops, i)
        float sig_be_mfe = array.get(signal_be_mfes, i)
        float sig_no_be_mfe = array.get(signal_mfes, i)
        float sig_mae = array.get(signal_maes, i)
        bool sig_no_be_done = array.get(signal_no_be_stopped, i)
        bool sig_be_stopped = array.get(signal_be_stopped, i)
        
        color dir_color = sig_dir == "Bullish" ? color.green : color.red
        color session_color = sig_session == "AM" or sig_session == "PM" ? color.green :
                             sig_session == "LON" ? color.blue :
                             sig_session == "ASIA" ? color.purple : color.gray
        
        // Status: COMPLETE (both stopped), BE-EXIT (BE stopped, No-BE active), ACTIVE (both active)
        string status_text = sig_no_be_done ? "COMPLETED" : sig_be_stopped ? "BE-X" : "LIVE"
        color status_color = sig_no_be_done ? color.blue : sig_be_stopped ? color.purple : color.green
        
        table.cell(signal_list_table, 0, row, sig_date, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 1, row, sig_time_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 2, row, age_str, text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 3, row, sig_session, text_color=color.white, bgcolor=color.new(session_color, 60), text_size=size.small)
        table.cell(signal_list_table, 4, row, sig_dir == "Bullish" ? "üîµ" : "üî¥", text_color=dir_color, bgcolor=color.new(color.gray, 70), text_size=size.normal)
        table.cell(signal_list_table, 5, row, str.tostring(sig_entry, "#.##"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 6, row, str.tostring(sig_stop, "#.##"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 7, row, str.tostring(sig_be_mfe, "#.##") + "R", text_color=sig_be_mfe >= 1 ? color.green : color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 8, row, str.tostring(sig_no_be_mfe, "#.##") + "R", text_color=sig_no_be_mfe >= 1 ? color.green : color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 9, row, str.tostring(sig_mae, "#.##") + "R", text_color=sig_mae < -1.0 ? color.red : color.orange, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(signal_list_table, 10, row, status_text, text_color=color.white, bgcolor=color.new(status_color, 50), text_size=size.small)
        
        row := row + 1
        signals_shown := signals_shown + 1
    
    // Navigation info (only if within table bounds)
    if row < 22
        string filter_text = SIGNAL_LIST_FILTER == "ALL" ? "All" : SIGNAL_LIST_FILTER == "ACTIVE" ? "Active" : "Completed"
        string nav_text = filter_text + " | Page " + str.tostring(SIGNAL_LIST_START / SIGNAL_LIST_COUNT + 1) + 
                         " | Showing " + str.tostring(signals_shown) + " signals"
        table.cell(signal_list_table, 0, row, nav_text, text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.merge_cells(signal_list_table, 0, row, 10, row)


// ============================================================================
// MFE RECALCULATION FROM HISTORICAL BARS
// ============================================================================

// Recalculate MFE for all signals by scanning chart history
// This fixes understated MFE values from the stop detection bug
if RECALCULATE_MFE and barstate.islast
    // For each signal, find its highest high / lowest low from historical bars
    for sig_idx = 0 to array.size(signal_entries) - 1
        int sig_entry_time = array.get(signal_entry_times, sig_idx)
        float sig_entry = array.get(signal_entries, sig_idx)
        float sig_stop = array.get(signal_stops, sig_idx)
        string sig_dir = array.get(signal_directions, sig_idx)
        bool sig_stopped = array.get(signal_no_be_stopped, sig_idx)
        
        // Find the highest high / lowest low from entry time to stop time (or current)
        float max_favorable = sig_entry
        
        // Scan through all bars from entry to now
        for bar_offset = 0 to 5000  // Scan up to 5000 bars back
            int bar_time = time[bar_offset]
            
            // Stop if we've gone before the entry time
            if bar_time < sig_entry_time
                break
            
            // Update max favorable
            if sig_dir == "Bullish"
                if high[bar_offset] > max_favorable
                    max_favorable := high[bar_offset]
            else
                if low[bar_offset] < max_favorable
                    max_favorable := low[bar_offset]
        
        // Calculate correct MFE
        float sig_risk = sig_entry - sig_stop
        if sig_risk != 0
            float correct_mfe = sig_dir == "Bullish" ? 
                               (max_favorable - sig_entry) / math.abs(sig_risk) :
                               (sig_entry - max_favorable) / math.abs(sig_risk)
            
            // Update the array with correct MFE
            array.set(signal_mfes, sig_idx, correct_mfe)
            
            // Update BE MFE (capped at 1.0 if BE was triggered)
            bool be_triggered = array.get(signal_be_triggered, sig_idx)
            float correct_be_mfe = be_triggered and correct_mfe > 1.0 ? 1.0 : correct_mfe
            array.set(signal_be_mfes, sig_idx, correct_be_mfe)


// ============================================================================
// ALL SIGNALS TABLE - Every Triangle (Pending, Confirmed, Cancelled)
// ============================================================================

if SHOW_ALL_SIGNALS and barstate.islast
    // Font size setting
    string font_size_val = ALL_SIGNALS_FONT_SIZE == "Tiny" ? size.tiny : ALL_SIGNALS_FONT_SIZE == "Small" ? size.small : size.normal
    
    string all_pos = position.middle_left
    if ALL_SIGNALS_POSITION == "top_left"
        all_pos := position.top_left
    else if ALL_SIGNALS_POSITION == "top_right"
        all_pos := position.top_right
    else if ALL_SIGNALS_POSITION == "bottom_left"
        all_pos := position.bottom_left
    else if ALL_SIGNALS_POSITION == "bottom_right"
        all_pos := position.bottom_right
    else if ALL_SIGNALS_POSITION == "middle_center"
        all_pos := position.middle_center
    
    var table all_signals_table = table.new(all_pos, 18, 52, border_width=1)
    
    // Header
    table.cell(all_signals_table, 0, 0, "ALL SIGNALS (Every Triangle)", text_color=color.white, bgcolor=color.new(color.purple, 20), text_size=size.normal)
    table.merge_cells(all_signals_table, 0, 0, 17, 0)
    
    // Column headers
    table.cell(all_signals_table, 0, 1, "Date", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 1, 1, "Time", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 2, 1, "Dir", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 3, 1, "Session", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 4, 1, "Status", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 5, 1, "Entry", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 6, 1, "Stop", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 7, 1, "Risk", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 8, 1, "BE MFE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 9, 1, "No-BE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 10, 1, "MAE", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 11, 1, "Bars", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 12, 1, "D", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 13, 1, "4H", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 14, 1, "1H", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 15, 1, "15M", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 16, 1, "5M", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    table.cell(all_signals_table, 17, 1, "1M", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.tiny)
    
    // Filter and show signals
    int row = 2
    int signals_shown = 0
    int signals_checked = 0
    
    // For LATEST_40 filter, start from most recent
    int start_loop = ALL_SIGNALS_FILTER == "LATEST_40" ? math.max(0, array.size(all_signal_times) - 40) : 0
    int end_loop = array.size(all_signal_times) - 1
    
    for i = start_loop to end_loop
        if row >= 52 or signals_shown >= ALL_SIGNALS_COUNT
            break
        
        // Get signal status
        string sig_status = array.get(all_signal_status, i)
        int sig_time = array.get(all_signal_times, i)
        string sig_dir = array.get(all_signal_directions, i)
        
        // Cross-reference to check if active and BE status (for ACTIVE filters)
        bool is_active = false
        bool is_be_triggered = false
        
        if sig_status == "CONFIRMED" and array.size(signal_entry_times) > 0
            for j = 0 to array.size(signal_entry_times) - 1
                int entry_time = array.get(signal_entry_times, j)
                string entry_dir = array.get(signal_directions, j)
                if math.abs(entry_time - sig_time) < 600000 and entry_dir == sig_dir
                    bool no_be_stopped = array.get(signal_no_be_stopped, j)
                    is_active := not no_be_stopped
                    is_be_triggered := array.get(signal_be_triggered, j)
                    break
        
        // Apply filter
        bool show_signal = false
        if ALL_SIGNALS_FILTER == "LATEST_40"
            show_signal := true  // Show all in range
        else if ALL_SIGNALS_FILTER == "ACTIVE_BE"
            show_signal := is_active and is_be_triggered  // Active with BE+1R
        else if ALL_SIGNALS_FILTER == "ACTIVE_ALL"
            show_signal := is_active  // All active signals
        else if ALL_SIGNALS_FILTER == "ALL"
            show_signal := true
        else if ALL_SIGNALS_FILTER == "PENDING"
            show_signal := sig_status == "PENDING"
        else if ALL_SIGNALS_FILTER == "CONFIRMED"
            show_signal := sig_status == "CONFIRMED"
        else if ALL_SIGNALS_FILTER == "CANCELLED"
            show_signal := sig_status == "CANCELLED"
        else if ALL_SIGNALS_FILTER == "COMPLETED"
            show_signal := sig_status == "CONFIRMED" and not is_active
        
        if not show_signal
            continue
        
        // Skip before start index (for pagination)
        if signals_shown < ALL_SIGNALS_START
            signals_shown := signals_shown + 1
            continue
        
        // Get additional signal data (sig_time and sig_dir already retrieved above for filter)
        int confirm_time = array.get(all_signal_confirmation_times, i)
        int bars_to_confirm = array.get(all_signal_bars_to_confirm, i)
        
        // Format date
        int d = dayofmonth(sig_time, "America/New_York")
        int m = month(sig_time, "America/New_York")
        int y = year(sig_time, "America/New_York") - 2000
        string month_name = m == 1 ? "Jan" : m == 2 ? "Feb" : m == 3 ? "Mar" : m == 4 ? "Apr" : 
                           m == 5 ? "May" : m == 6 ? "Jun" : m == 7 ? "Jul" : m == 8 ? "Aug" :
                           m == 9 ? "Sep" : m == 10 ? "Oct" : m == 11 ? "Nov" : "Dec"
        string sig_date = str.tostring(d) + "-" + month_name + "-" + str.tostring(y)
        
        // Format time
        string sig_time_str = str.tostring(hour(sig_time, "America/New_York"), "00") + ":" +
                             str.tostring(minute(sig_time, "America/New_York"), "00")
        
        // Confirmation time
        string confirm_str = "--"
        if confirm_time > 0
            confirm_str := str.tostring(hour(confirm_time, "America/New_York"), "00") + ":" +
                          str.tostring(minute(confirm_time, "America/New_York"), "00")
        
        // Session (separate, not combined)
        int h = hour(sig_time, "America/New_York")
        int min = minute(sig_time, "America/New_York")
        string sig_session = "AH"
        if h >= 20 and h <= 23
            sig_session := "ASIA"
        else if h >= 0 and h <= 5
            sig_session := "LON"
        else if h == 6 or (h == 8 and min <= 29)
            sig_session := "PRE"
        else if (h == 8 and min >= 30) or (h >= 9 and h <= 11)
            sig_session := "AM"
        else if h == 12
            sig_session := "LUN"
        else if h >= 13 and h <= 15
            sig_session := "PM"
        
        // Colors
        color dir_color = sig_dir == "Bullish" ? color.green : color.red
        
        // Cross-reference with Confirmed Signals to get Entry/Stop/Risk/MFE/MAE
        string entry_str = "--"
        string stop_str = "--"
        string risk_str = "--"
        string be_mfe_str = "--"
        string no_be_mfe_str = "--"
        string mae_str = "--"
        string status_display = sig_status
        color status_color = color.orange
        
        if sig_status == "CONFIRMED" and array.size(signal_entry_times) > 0
            for j = 0 to array.size(signal_entry_times) - 1
                int entry_time = array.get(signal_entry_times, j)
                string entry_dir = array.get(signal_directions, j)
                // Match within 10 minutes (600000 ms) and same direction
                if math.abs(entry_time - sig_time) < 600000 and entry_dir == sig_dir
                    float entry_val = array.get(signal_entries, j)
                    float stop_val = array.get(signal_stops, j)
                    if not na(entry_val) and not na(stop_val)
                        entry_str := str.tostring(entry_val, "#.##")
                        stop_str := str.tostring(stop_val, "#.##")
                        risk_str := str.tostring(math.abs(entry_val - stop_val), "#.##")
                        
                        // Get MFE/MAE data
                        float be_mfe_val = array.get(signal_be_mfes, j)
                        float no_be_mfe_val = array.get(signal_mfes, j)
                        float mae_val = array.get(signal_maes, j)
                        bool no_be_stopped = array.get(signal_no_be_stopped, j)
                        bool be_stopped = array.get(signal_be_stopped, j)
                        bool be_triggered = array.get(signal_be_triggered, j)
                        
                        be_mfe_str := str.tostring(be_mfe_val, "#.##") + "R"
                        no_be_mfe_str := str.tostring(no_be_mfe_val, "#.##") + "R"
                        mae_str := str.tostring(mae_val, "#.##") + "R"
                        
                        // Status: COMPLETED, ACTIVE (BE+1R), ACTIVE
                        if no_be_stopped
                            status_display := "COMPLETED"
                            status_color := color.blue
                        else if be_triggered
                            status_display := "ACTIVE (BE+1R)"
                            status_color := color.green
                        else
                            status_display := "ACTIVE"
                            status_color := color.green
                    break
        else if sig_status == "CANCELLED"
            status_color := color.red
        else if sig_status == "PENDING"
            status_color := color.orange
        
        // HTF bias indicators (stored at signal time, not current)
        string stored_daily = array.get(all_signal_daily_bias, i)
        string stored_h4 = array.get(all_signal_h4_bias, i)
        string stored_h1 = array.get(all_signal_h1_bias, i)
        string stored_m15 = array.get(all_signal_m15_bias, i)
        string stored_m5 = array.get(all_signal_m5_bias, i)
        string stored_m1 = array.get(all_signal_m1_bias, i)
        
        string d_indicator = stored_daily == "Bullish" ? "üîµ" : stored_daily == "Bearish" ? "üî¥" : "‚ö™"
        string h4_indicator = stored_h4 == "Bullish" ? "üîµ" : stored_h4 == "Bearish" ? "üî¥" : "‚ö™"
        string h1_indicator = stored_h1 == "Bullish" ? "üîµ" : stored_h1 == "Bearish" ? "üî¥" : "‚ö™"
        string m15_indicator = stored_m15 == "Bullish" ? "üîµ" : stored_m15 == "Bearish" ? "üî¥" : "‚ö™"
        string m5_indicator = stored_m5 == "Bullish" ? "üîµ" : stored_m5 == "Bearish" ? "üî¥" : "‚ö™"
        string m1_indicator = stored_m1 == "Bullish" ? "üîµ" : stored_m1 == "Bearish" ? "üî¥" : "‚ö™"
        
        // Display
        table.cell(all_signals_table, 0, row, sig_date, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 1, row, sig_time_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 2, row, sig_dir == "Bullish" ? "üîµ" : "üî¥", text_color=dir_color, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 3, row, sig_session, text_color=color.white, bgcolor=color.new(color.blue, 60), text_size=font_size_val)
        table.cell(all_signals_table, 4, row, status_display, text_color=color.white, bgcolor=color.new(status_color, 50), text_size=font_size_val)
        table.cell(all_signals_table, 5, row, entry_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 6, row, stop_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 7, row, risk_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 8, row, be_mfe_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 9, row, no_be_mfe_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 10, row, mae_str, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 11, row, bars_to_confirm > 0 ? str.tostring(bars_to_confirm) : "--", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=font_size_val)
        table.cell(all_signals_table, 12, row, d_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 13, row, h4_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 14, row, h1_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 15, row, m15_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 16, row, m5_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(all_signals_table, 17, row, m1_indicator, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        
        row := row + 1
        signals_shown := signals_shown + 1
    
    // Navigation
    if row < 52
        string filter_text = ALL_SIGNALS_FILTER
        string nav_text = filter_text + " | Total: " + str.tostring(array.size(all_signal_times)) + 
                         " | Showing: " + str.tostring(signals_shown)
        table.cell(all_signals_table, 0, row, nav_text, text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.merge_cells(all_signals_table, 0, row, 17, row)
