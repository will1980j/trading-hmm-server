<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            font-size: 2rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .platform-info h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .platform-info p {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .user-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-info {
            text-align: right;
        }

        .user-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .user-status {
            color: #22c55e;
            font-size: 0.8rem;
        }

        .logout-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .logout-btn:hover {
            background: rgba(239, 68, 68, 0.3);
            transform: translateY(-2px);
        }

        /* Navigation */
        .nav-container {
            background: #141b3d;
            padding: 12px 20px;
            border-bottom: 1px solid #2d3a5f;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            overflow-x: auto;
        }

        .nav-link {
            padding: 8px 12px;
            background: #1a2142;
            color: #f8fafc;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.3s;
        }

        .nav-link:hover {
            background: #3b82f6;
            transform: translateY(-2px);
        }

        /* Dashboard Specific Styles Below */


        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #141b2d;
            --bg-tertiary: #1e2a47;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: rgba(148, 163, 184, 0.1);
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.16);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.25);
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }
        
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        .header h1 { font-size: 2.5rem; font-weight: 800; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: var(--spacing-sm); letter-spacing: -0.02em; }
        .header p { color: var(--text-secondary); font-size: 1rem; font-weight: 500; }
        .settings-card { background: var(--bg-secondary); border-radius: var(--radius-lg); padding: var(--spacing-xl); margin-bottom: var(--spacing-xl); border: 1px solid var(--border-color); box-shadow: var(--shadow-md); }
        .settings-header { display: flex; align-items: center; gap: var(--spacing-md); margin-bottom: var(--spacing-lg); }
        .settings-header h3 { font-size: 1.25rem; font-weight: 700; color: var(--text-primary); }
        .settings-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: var(--spacing-lg); margin-bottom: var(--spacing-lg); }
        @media (max-width: 1400px) { .settings-grid { grid-template-columns: repeat(4, 1fr); } }
        @media (max-width: 900px) { .settings-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .settings-grid { grid-template-columns: 1fr; } }
        .input-group { display: flex; flex-direction: column; gap: var(--spacing-sm); }
        .input-group label { font-size: 0.875rem; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; }
        .input-group input { padding: var(--spacing-md); border: 1px solid var(--border-color); border-radius: var(--radius-sm); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem; transition: all 0.2s; }
        .input-group input:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .checkbox-group { display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-md); background: var(--bg-tertiary); border-radius: var(--radius-sm); cursor: pointer; transition: all 0.2s; }
        .checkbox-group:hover { background: rgba(59, 130, 246, 0.1); }
        .checkbox-group input { width: 18px; height: 18px; accent-color: var(--accent-primary); cursor: pointer; }
        .checkbox-group span { font-weight: 600; color: var(--text-primary); }
        .prop-firm-logo { width: 40px; height: 40px; border-radius: 6px; object-fit: contain; background: white; padding: 1px; margin-right: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .btn-primary { background: linear-gradient(135deg, var(--accent-primary), #2563eb); border: none; padding: var(--spacing-md) var(--spacing-xl); border-radius: var(--radius-md); color: white; font-weight: 700; font-size: 1rem; cursor: pointer; transition: all 0.3s; box-shadow: var(--shadow-md); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .btn-primary:active { transform: translateY(0); }
        .results-card { background: var(--bg-secondary); border-radius: var(--radius-lg); padding: var(--spacing-xl); border: 1px solid var(--border-color); box-shadow: var(--shadow-md); }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        th, td { padding: var(--spacing-md); text-align: left; border-bottom: 1px solid var(--border-color); }
        th { background: var(--bg-tertiary); color: var(--text-secondary); font-weight: 700; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; user-select: none; position: relative; transition: all 0.2s; }
        th:first-child { border-top-left-radius: var(--radius-sm); }
        th:last-child { border-top-right-radius: var(--radius-sm); }
        th:hover { background: rgba(59, 130, 246, 0.1); color: var(--accent-primary); }
        th.sortable::after { content: ' ‚áÖ'; opacity: 0.3; font-size: 12px; }
        th.sort-asc::after { content: ' ‚Üë'; opacity: 1; color: var(--accent-primary); }
        th.sort-desc::after { content: ' ‚Üì'; opacity: 1; color: var(--accent-primary); }
        tbody tr { transition: all 0.2s; }
        tbody tr:hover { background: rgba(59, 130, 246, 0.05); }
        tbody tr:last-child td:first-child { border-bottom-left-radius: var(--radius-sm); }
        tbody tr:last-child td:last-child { border-bottom-right-radius: var(--radius-sm); }
        td { color: var(--text-primary); font-size: 0.875rem; }
        .view-btn { padding: var(--spacing-sm) var(--spacing-md); background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: var(--radius-sm); color: var(--accent-primary); cursor: pointer; font-weight: 600; font-size: 0.875rem; transition: all 0.2s; }
        .view-btn:hover { background: rgba(59, 130, 246, 0.2); transform: translateY(-1px); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2); }
        .fab { position: fixed; bottom: var(--spacing-xl); right: var(--spacing-xl); width: 56px; height: 56px; background: linear-gradient(135deg, var(--accent-primary), #2563eb); border-radius: 50%; border: none; color: white; font-size: 1.5rem; cursor: pointer; box-shadow: var(--shadow-lg); transition: all 0.3s; z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .fab:hover { transform: scale(1.1) rotate(90deg); box-shadow: 0 12px 30px rgba(59, 130, 246, 0.4); }
        .info-card { background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-top: var(--spacing-lg); }
        .info-card h3 { color: var(--accent-primary); font-size: 1rem; font-weight: 700; margin-bottom: var(--spacing-sm); }
        .info-card p { color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-xs); }
        .chart-container { background: var(--bg-tertiary); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-top: var(--spacing-xl); border: 1px solid var(--border-color); }
        .chart-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--spacing-lg); }
        .chart-header h3 { font-size: 1.125rem; font-weight: 700; color: var(--text-primary); }
        
        /* Enhanced Risk Analysis Styles */
        .risk-analysis-container { 
            padding: 16px; 
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
            max-height: 70vh; 
            overflow-y: auto; 
            position: relative;
        }
        .section-header { margin-bottom: 12px; }
        .heatmap-cell:hover { transform: scale(1.02); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .scenario-card { transition: all 0.2s ease; }
        .scenario-card:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .metric-card { transition: all 0.2s ease; }
        .metric-card:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15); }
        
        /* Prevent overlapping */
        .probability-heatmap-section,
        .risk-scenarios-section,
        .psychological-prep-section,
        .position-sizing-section,
        .monte-carlo-section,
        .enhanced-metrics-section {
            position: relative;
            z-index: 1;
            margin-bottom: 16px;
        }
        
        /* Tooltip Styles */
        #heatmapTooltip { 
            box-shadow: 0 8px 32px rgba(0,0,0,0.4); 
            backdrop-filter: blur(10px);
        }
        
        /* Animation Classes */
        .fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-in { animation: slideIn 0.6s ease-out; }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .heatmap-table { font-size: 10px; }
            .scenario-grid { grid-template-columns: 1fr; }
            .risk-analysis-container { padding: var(--spacing-sm); }
        }
    
        
        </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo-section">
            <div class="logo">üìà</div>
            <div class="platform-info">
                <h1>NASDAQ Trading Analytics</h1>
                <p>Professional Day Trading Platform</p>
            </div>
        </div>
        <div class="user-section">
            <div class="user-info">
                <div class="user-name">Trading Professional</div>
                <div class="user-status">‚óè Online</div>
            </div>
            <a href="/logout" class="logout-btn">Logout</a>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="nav-container">
        <a href="/ml-dashboard" class="nav-link">ü§ñ ML</a>
        <a href="/signal-lab-dashboard" class="nav-link">üè† Dashboard</a>
        <a href="/signal-analysis-lab" class="nav-link">üß™ Signal Lab</a>
        <a href="/automated-signals" class="nav-link">üì° Automated Signals</a>
        <a href="/time-analysis" class="nav-link">‚è∞ Time</a>
        <a href="/strategy-optimizer" class="nav-link">üéØ Optimizer</a>
        <a href="/strategy-comparison" class="nav-link">üèÜ Compare</a>
        <a href="/ai-business-advisor" class="nav-link">üß† AI Advisor</a>
        <a href="/prop-portfolio" class="nav-link">üíº Prop</a>
        <a href="/trade-manager" class="nav-link">üìã Trades</a>
        <a href="/financial-summary" class="nav-link">üí∞ Finance</a>
        <a href="/reporting-hub" class="nav-link">üìä Reports</a>
    </nav>


    <!-- Navigation -->
    <!-- Navigation -->
    
    <script>
    (function() {
        const currentPath = window.location.pathname;
        const navLinks = document.querySelectorAll('nav a[data-page]');
        navLinks.forEach(link => {
            if (link.getAttribute('href') === currentPath) {
                link.style.background = '#3b82f6';
                link.style.color = 'white';
            }
        });
    })();
    </script>
    
    <div class="container">
        
                <div id="dateRangeInfo" style="font-size: 0.875rem; color: var(--text-secondary); padding: var(--spacing-sm); background: rgba(59, 130, 246, 0.05); border-radius: var(--radius-sm); display: none;">
                    <span id="dateRangeText"></span>
                </div>
            </div>
            
            <div class="settings-grid">
                <div class="input-group">
                    <label>Risk Per Trade (%)</label>
                    <input type="number" id="riskPerTrade" value="0.5" min="0.1" max="5" step="0.25">
                </div>
                <div class="input-group">
                    <label>Max Drawdown (%)</label>
                    <input type="number" id="maxDrawdown" value="10" min="5" max="20" step="1">
                </div>
                <div class="input-group">
                    <label>Broker Fee (R)</label>
                    <input type="number" id="brokerFee" value="0.125" min="0" max="1" step="0.025">
                </div>
                <div class="input-group">
                    <label>Max Daily Loss (%)</label>
                    <input type="number" id="maxDailyLoss" value="5" min="1" max="10" step="0.5">
                </div>
                <div class="input-group">
                    <label>Min Win Rate (%)</label>
                    <input type="number" id="minWinRate" value="20" min="0" max="100" step="5">
                </div>
                <div class="input-group">
                    <label>Min Expectancy (R)</label>
                    <input type="number" id="minExpectancy" value="0" min="0" max="2" step="0.05">
                </div>
                <div class="input-group">
                    <label>Min Profit Factor</label>
                    <input type="number" id="minProfitFactor" value="0" min="0" max="5" step="0.1">
                </div>
            </div>
            <label class="checkbox-group">
                <input type="checkbox" id="onlyPropViable" checked>
                <span>Only show prop firm viable strategies</span>
            </label>
            
            <!-- Prop Firm Selector Section -->
            <div style="background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-top: var(--spacing-lg);">
                <div style="display: flex; align-items: center; gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
                    <span style="font-size: 1.25rem;">üíº</span>
                    <h4 style="font-size: 1rem; font-weight: 700; color: var(--accent-primary);">Prop Firm Rules (Select to Apply Specific Firm Requirements)</h4>
                </div>
                <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: var(--spacing-md);">Select a prop firm to filter strategies that meet their specific evaluation and funded account rules</p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
                    <label class="checkbox-group">
                        <input type="checkbox" id="propMyfundedfutures" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/My Funded Futures.png" class="prop-firm-logo" alt="MFF">
                        <span>My Funded Futures ‚≠ê</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propTopstep" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/topstep.png" class="prop-firm-logo" alt="Topstep">
                        <span>Topstep</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propApex" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/apex trader funding.png" class="prop-firm-logo" alt="Apex">
                        <span>Apex Trader</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propAlphafutures" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/Alpha Futures.png" class="prop-firm-logo" alt="Alpha">
                        <span>Alpha Futures ‚≠ê</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propToponefutures" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/top one futures.png" class="prop-firm-logo" alt="Top One">
                        <span>Top One Futures ‚≠ê</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propTradeify" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/tradeify.png" class="prop-firm-logo" alt="Tradeify">
                        <span>Tradeify ‚≠ê</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propFundednext" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/funded next futures.png" class="prop-firm-logo" alt="FundedNext">
                        <span>FundedNext</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propE8futures" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/e8 futures.png" class="prop-firm-logo" alt="E8">
                        <span>E8 Futures</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propBlueguardian" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/blue guardian futures.png" class="prop-firm-logo" alt="Blue Guardian">
                        <span>Blue Guardian</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propAquafutures" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/aquafutures.png" class="prop-firm-logo" alt="Aqua">
                        <span>AquaFutures</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propFundingticks" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/funding ticks.png" class="prop-firm-logo" alt="FundingTicks">
                        <span>FundingTicks</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propTakeprofittrader" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/taek profit trader.png" class="prop-firm-logo" alt="TPT">
                        <span>Take Profit Trader</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propTradeday" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/tradeday.png" class="prop-firm-logo" alt="TradeDay">
                        <span>TradeDay</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="propTradingpit" onchange="updatePropFirmRules()">
                        <img src="/.kiro/static/logos/the trading pit futures.png" class="prop-firm-logo" alt="Trading Pit">
                        <span>The Trading Pit</span>
                    </label>
                </div>
                <div id="propFirmInfo" style="margin-top: var(--spacing-md); padding: var(--spacing-md); background: rgba(59, 130, 246, 0.05); border-radius: var(--radius-sm); display: none;">
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                        <strong style="color: var(--accent-primary);">Active Rules:</strong>
                        <div id="propFirmRulesDisplay" style="margin-top: var(--spacing-sm);"></div>
                    </div>
                </div>
            </div>
            
            <!-- Best Of All Time Section -->
            <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-top: var(--spacing-lg);">
                <div style="display: flex; align-items: center; gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
                    <span style="font-size: 1.25rem;">üèÜ</span>
                    <h4 style="font-size: 1rem; font-weight: 700; color: var(--accent-secondary);">Best Of All Time (Overrides Filters Above)</h4>
                </div>
                <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: var(--spacing-md);">Select criteria to find strategies with the best combination of metrics across all historical data</p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestLowestDD">
                        <span>Lowest Max DD</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestExpectedPercent">
                        <span>Highest Expected %</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestExpectedR">
                        <span>Highest Expected R</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestWinRate">
                        <span>Highest Win Rate</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestProfitFactor">
                        <span>Highest Profit Factor</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestExpectancy">
                        <span>Highest Expectancy</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" id="bestSmoothestCurve">
                        <span>Smoothest Equity Curve</span>
                    </label>
                </div>
            </div>
            <div style="text-align: center; margin-top: var(--spacing-lg); display: flex; gap: var(--spacing-md); justify-content: center; flex-wrap: wrap;">
                <button class="btn-primary" onclick="runComparison()">üîÑ Run Comparison</button>
                <button class="btn-primary" onclick="runPropFirmOptimizer()" style="background: linear-gradient(135deg, #10b981, #059669); border-color: #10b981;">üéØ Optimize for Selected Firms</button>
            </div>
        </div>
        
        <button class="fab" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="Scroll to top">‚Üë</button>
        
        <div id="results"></div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let signals = [];
        let allSignals = [];
        
        // Prop Firm Rules Database (based on comprehensive futures prop firm research)
        // Source: Futures Prop Firm Risk Metrics Analysis
        const propFirmRules = {
            myfundedfutures: {
                name: "My Funded Futures",
                website: "myfundedfutures.com",
                maxDailyLoss: 0,  // No daily loss limits
                maxDrawdown: 8,   // End-of-day trailing DD
                minWinRate: 0,
                rating: 4.5,
                maxAccount: 450000,
                description: "No daily limits, 8% EOD trailing DD, 80/20 split, $450K max"
            },
            topstep: {
                name: "Topstep",
                website: "topstep.com",
                maxDailyLoss: 0,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.0,
                maxAccount: 150000,
                description: "No daily limits (TopstepX), 6% EOD DD, $150K max"
            },
            apex: {
                name: "Apex Trader Funding",
                website: "apextraderfunding.com",
                maxDailyLoss: 0,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 3.8,
                maxAccount: 6000000,
                description: "No daily DD, 6% trailing, 90/10 split, $6M total capital"
            },
            alphafutures: {
                name: "Alpha Futures",
                website: "alphafutures.io",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.9,
                maxAccount: 450000,
                description: "UK-based, 4.9/5 rating, $450K max, premium service"
            },
            toponefutures: {
                name: "Top One Futures",
                website: "toponefutures.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.8,
                maxAccount: 1500000,
                description: "4.8/5 rating, $1.5M max accounts, excellent reputation"
            },
            tradeify: {
                name: "Tradeify",
                website: "tradeify.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.8,
                maxAccount: 750000,
                description: "4.8/5 rating, $750K max, trader-friendly policies"
            },
            fundednext: {
                name: "FundedNext Futures",
                website: "fundednext.com",
                maxDailyLoss: 2.4,
                maxDrawdown: 5,
                minWinRate: 0,
                rating: 4.0,
                maxAccount: 200000,
                description: "2.4% daily loss, strict rules, includes fees in calculations"
            },
            e8futures: {
                name: "E8 Futures",
                website: "e8funding.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.0,
                maxAccount: 500000,
                consistency: 35,
                description: "35% best day rule, $500K max, 1-4 phase evaluation"
            },
            blueguardian: {
                name: "Blue Guardian",
                website: "blueguardian.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.3,
                maxAccount: 300000,
                description: "Guardian Shield protection, 4.3/5 rating, automated safety"
            },
            aquafutures: {
                name: "AquaFutures",
                website: "aquafunded.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.1,
                maxAccount: 300000,
                description: "4.1/5 rating, $300K max, extended trading hours"
            },
            fundingticks: {
                name: "FundingTicks",
                website: "fundingticks.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 4.0,
                maxAccount: 300000,
                description: "UAE-based, $300K max, international platform"
            },
            takeprofittrader: {
                name: "Take Profit Trader",
                website: "takeprofittrader.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 3.5,
                maxAccount: 250000,
                description: "Emerging firm, instant funding options available"
            },
            tradeday: {
                name: "TradeDay",
                website: "tradeday.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 3.5,
                maxAccount: 250000,
                description: "No evaluation required, direct funded accounts"
            },
            tradingpit: {
                name: "The Trading Pit",
                website: "thetradingpit.com",
                maxDailyLoss: 3,
                maxDrawdown: 6,
                minWinRate: 0,
                rating: 3.5,
                maxAccount: 200000,
                description: "Emerging platform, competitive terms"
            }
        };
        
        function updatePropFirmRules() {
            const selectedFirms = [];
            let strictestDailyLoss = 100;
            let strictestDrawdown = 100;
            let hasNoDailyLimit = false;
            
            // Check which firms are selected
            Object.keys(propFirmRules).forEach(firmKey => {
                // Convert firmKey to match checkbox ID (capitalize first letter only)
                const checkboxId = `prop${firmKey.charAt(0).toUpperCase()}${firmKey.slice(1)}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    const rules = propFirmRules[firmKey];
                    selectedFirms.push(rules.name);
                    
                    // Handle firms with no daily loss limits (0 means no limit)
                    if (rules.maxDailyLoss === 0) {
                        hasNoDailyLimit = true;
                    } else {
                        strictestDailyLoss = Math.min(strictestDailyLoss, rules.maxDailyLoss);
                    }
                    
                    strictestDrawdown = Math.min(strictestDrawdown, rules.maxDrawdown);
                }
            });
            
            const infoDiv = document.getElementById('propFirmInfo');
            const rulesDisplay = document.getElementById('propFirmRulesDisplay');
            
            if (selectedFirms.length > 0) {
                // If all selected firms have no daily limit, use a reasonable default
                if (hasNoDailyLimit && strictestDailyLoss === 100) {
                    strictestDailyLoss = 10; // Default to 10% if only no-limit firms selected
                }
                
                // Update the filter inputs to match strictest rules
                document.getElementById('maxDailyLoss').value = strictestDailyLoss;
                document.getElementById('maxDrawdown').value = strictestDrawdown;
                
                // Show info
                infoDiv.style.display = 'block';
                const dailyLossText = hasNoDailyLimit && strictestDailyLoss === 10 ? 
                    'No daily limits (using 10% default for filtering)' : 
                    `${strictestDailyLoss}% (strictest rule applied)`;
                    
                rulesDisplay.innerHTML = `
                    <div style="margin-bottom: 4px;"><strong>Selected Firms:</strong> ${selectedFirms.join(', ')}</div>
                    <div style="margin-bottom: 4px;">üìâ <strong>Max Daily Loss:</strong> ${dailyLossText}</div>
                    <div>üìä <strong>Max Drawdown:</strong> ${strictestDrawdown}% (strictest rule applied)</div>
                    <div style="margin-top: 8px; font-size: 0.8rem; opacity: 0.8;">Filters above have been automatically updated to match these requirements</div>
                `;
            } else {
                infoDiv.style.display = 'none';
            }
        }
        
        function toggleDateInputs() {
            const timePeriodType = document.getElementById('timePeriodType').value;
            const singleDateGroup = document.getElementById('singleDateGroup');
            const startDateGroup = document.getElementById('startDateGroup');
            const endDateGroup = document.getElementById('endDateGroup');
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            
            singleDateGroup.style.display = 'none';
            startDateGroup.style.display = 'none';
            endDateGroup.style.display = 'none';
            dateRangeInfo.style.display = 'none';
            
            if (timePeriodType === 'single') {
                singleDateGroup.style.display = 'block';
            } else if (timePeriodType === 'range') {
                startDateGroup.style.display = 'block';
                endDateGroup.style.display = 'block';
            }
            
            updateDateRangeInfo();
        }
        
        function updateDateRangeInfo() {
            const timePeriodType = document.getElementById('timePeriodType').value;
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeText = document.getElementById('dateRangeText');
            
            if (timePeriodType === 'all') {
                dateRangeInfo.style.display = 'block';
                dateRangeText.textContent = `üìä Analyzing all ${allSignals.length} historical signals`;
            } else if (timePeriodType === 'last7') {
                const date = new Date();
                date.setDate(date.getDate() - 7);
                dateRangeInfo.style.display = 'block';
                dateRangeText.textContent = `üìä Analyzing signals from last 7 days (since ${date.toLocaleDateString()})`;
            } else if (timePeriodType === 'last30') {
                const date = new Date();
                date.setDate(date.getDate() - 30);
                dateRangeInfo.style.display = 'block';
                dateRangeText.textContent = `üìä Analyzing signals from last 30 days (since ${date.toLocaleDateString()})`;
            } else if (timePeriodType === 'last90') {
                const date = new Date();
                date.setDate(date.getDate() - 90);
                dateRangeInfo.style.display = 'block';
                dateRangeText.textContent = `üìä Analyzing signals from last 90 days (since ${date.toLocaleDateString()})`;
            }
        }
        
        function filterSignalsByDate() {
            const timePeriodType = document.getElementById('timePeriodType').value;
            
            if (timePeriodType === 'all') {
                signals = [...allSignals];
                return true;
            }
            
            const now = new Date();
            let startDate, endDate;
            
            if (timePeriodType === 'single') {
                const singleDateValue = document.getElementById('singleDate').value;
                if (!singleDateValue) {
                    alert('Please select a date');
                    return false;
                }
                startDate = new Date(singleDateValue);
                endDate = new Date(singleDateValue);
                endDate.setHours(23, 59, 59, 999);
            } else if (timePeriodType === 'range') {
                const startDateValue = document.getElementById('startDate').value;
                const endDateValue = document.getElementById('endDate').value;
                if (!startDateValue || !endDateValue) {
                    alert('Please select both start and end dates');
                    return false;
                }
                startDate = new Date(startDateValue);
                endDate = new Date(endDateValue);
                endDate.setHours(23, 59, 59, 999);
                
                if (startDate > endDate) {
                    alert('Start date must be before end date');
                    return false;
                }
            } else if (timePeriodType === 'last7') {
                startDate = new Date();
                startDate.setDate(startDate.getDate() - 7);
                endDate = now;
            } else if (timePeriodType === 'last30') {
                startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);
                endDate = now;
            } else if (timePeriodType === 'last90') {
                startDate = new Date();
                startDate.setDate(startDate.getDate() - 90);
                endDate = now;
            }
            
            signals = allSignals.filter(s => {
                const signalDate = new Date(s.date);
                return signalDate >= startDate && signalDate <= endDate;
            });
            
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeText = document.getElementById('dateRangeText');
            dateRangeInfo.style.display = 'block';
            dateRangeText.textContent = `üìä Analyzing ${signals.length} signals from ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`;
            
            return true;
        }
        
        async function loadSignals() {
            const response = await fetch('https://web-production-cd33.up.railway.app/api/signal-lab-trades?analysis_only=true');
            const data = await response.json();
            const trades = Array.isArray(data) ? data : data.trades || [];
            allSignals = trades.filter(t => { const d = new Date(t.date); return d.getDay() !== 0 && d.getDay() !== 6; })
                .map(t => ({ date: t.date, time: t.time, session: t.session, mfeNone: parseFloat(t.mfe_none || t.mfe) || 0, mfe1: parseFloat(t.mfe1) || 0 }));
            signals = [...allSignals];
            updateDateRangeInfo();
        }
        
        function calculateTradeResult(signal, beStrategy, rTarget, feeR = 0) {
            const mfe = beStrategy === 'be1' ? signal.mfe1 : signal.mfeNone;
            if (!mfe || mfe === 0) return -1 - feeR;
            if (beStrategy === 'none') return mfe < 0 ? (-1 - feeR) : (mfe >= rTarget ? (rTarget - feeR) : (-1 - feeR));
            if (mfe < 1) return -1 - feeR;
            if (mfe >= 1 && mfe < rTarget) return 0 - feeR;
            if (mfe >= rTarget) return rTarget - feeR;
            return -1 - feeR;
        }
        
        function calculateStats(results) {
            const wins = results.filter(r => r > 0).length;
            const losses = results.filter(r => r < 0).length;
            const breakevens = results.filter(r => r === 0).length;
            const total = results.length;
            const winRate = total > 0 ? (wins / total) * 100 : 0;
            const breakevenRate = total > 0 ? (breakevens / total) * 100 : 0;
            const totalR = results.reduce((sum, r) => sum + r, 0);
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const avgTrade = total > 0 ? totalR / total : 0;
            const avgWinR = winResults.length > 0 ? winResults.reduce((a,b) => a + b, 0) / winResults.length : 0;
            const avgLossR = lossResults.length > 0 ? Math.abs(lossResults.reduce((a,b) => a + b, 0) / lossResults.length) : 1;
            const winPercent = total > 0 ? wins / total : 0;
            const lossPercent = total > 0 ? losses / total : 0;
            const expectancy = ((avgWinR * winPercent) - (avgLossR * lossPercent)) / 1.0;
            const expectedTotalReturn = expectancy * total;
            let maxConsecLosses = 0, currentConsecLosses = 0, maxDrawdown = 0, currentDrawdown = 0, peak = 0, runningTotal = 0;
            results.forEach(result => {
                runningTotal += result;
                if (runningTotal > peak) { peak = runningTotal; currentDrawdown = 0; }
                else { currentDrawdown = peak - runningTotal; maxDrawdown = Math.max(maxDrawdown, currentDrawdown); }
                if (result < 0) { currentConsecLosses++; maxConsecLosses = Math.max(maxConsecLosses, currentConsecLosses); }
                else if (result > 0) currentConsecLosses = 0;
            });
            return { expectancy, avgTrade, winRate, breakevenRate, totalR, maxConsecLosses, maxDrawdown, total, expectedTotalReturn };
        }
        
        function calculateRSquared(equityCurve) {
            const n = equityCurve.length;
            if (n < 2) return 0;
            
            // Linear regression
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += equityCurve[i];
                sumXY += i * equityCurve[i];
                sumX2 += i * i;
                sumY2 += equityCurve[i] * equityCurve[i];
            }
            
            const numerator = (n * sumXY - sumX * sumY);
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            if (denominator === 0) return 0;
            
            const r = numerator / denominator;
            return r * r; // R-squared
        }
        
        function calculateEquityCurveSmoothness(tradeResults) {
            // Build cumulative equity curve
            let equity = 0;
            const equityCurve = [];
            let peak = 0;
            let maxDrawdown = 0;
            let drawdownStart = null;
            let maxDrawdownDuration = 0;
            
            // Streak tracking
            let currentStreak = 0;
            let lastWasWin = null;
            let maxWinStreak = 0;
            let maxLossStreak = 0;
            
            tradeResults.forEach((result, i) => {
                equity += result;
                equityCurve.push(equity);
                
                // Track drawdown and duration
                if (equity > peak) {
                    peak = equity;
                    if (drawdownStart !== null) {
                        const currentDrawdownDuration = i - drawdownStart;
                        if (currentDrawdownDuration > maxDrawdownDuration) {
                            maxDrawdownDuration = currentDrawdownDuration;
                        }
                        drawdownStart = null;
                    }
                } else {
                    if (drawdownStart === null) drawdownStart = i;
                    const drawdown = peak - equity;
                    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
                }
                
                // Track win/loss streaks
                const isWin = result > 0;
                if (lastWasWin === null || lastWasWin === isWin) {
                    currentStreak++;
                } else {
                    if (lastWasWin) {
                        maxWinStreak = Math.max(maxWinStreak, currentStreak);
                    } else {
                        maxLossStreak = Math.max(maxLossStreak, currentStreak);
                    }
                    currentStreak = 1;
                }
                lastWasWin = isWin;
            });
            
            // Final streak check
            if (lastWasWin) {
                maxWinStreak = Math.max(maxWinStreak, currentStreak);
            } else {
                maxLossStreak = Math.max(maxLossStreak, currentStreak);
            }
            
            // R-Squared (linearity of equity curve)
            const rSquared = calculateRSquared(equityCurve);
            
            // Recovery Factor
            const recoveryFactor = maxDrawdown > 0 ? equity / maxDrawdown : 999;
            
            // Streak Balance (lower loss streaks = better)
            const streakScore = maxLossStreak > 0 ? Math.min(maxWinStreak / maxLossStreak, 3) / 3 : 1;
            
            // Drawdown Duration Score (shorter = better)
            const avgTradesPerDay = tradeResults.length / 30; // Assume 30 days
            const durationScore = Math.max(0, 1 - (maxDrawdownDuration / (avgTradesPerDay * 5))); // 5 days max acceptable
            
            // Composite Smoothness Score (0-100) - SCALPING FOCUSED
            const smoothnessScore = (
                (rSquared * 50) +                              // 50% weight on linearity (most important)
                (Math.min(recoveryFactor / 5, 1) * 25) +      // 25% weight on recovery
                (streakScore * 15) +                           // 15% weight on streak balance
                (durationScore * 10)                           // 10% weight on quick recovery
            );
            
            return {
                smoothnessScore: Math.round(smoothnessScore),
                rSquared: rSquared.toFixed(3),
                recoveryFactor: recoveryFactor.toFixed(2),
                maxConsecutiveLosses: maxLossStreak,
                maxDrawdownDuration: maxDrawdownDuration,
                maxDrawdown: maxDrawdown.toFixed(2)
            };
        }
        
        async function runPropFirmOptimizer() {
            // Get selected prop firms
            const selectedFirms = [];
            Object.keys(propFirmRules).forEach(firmKey => {
                const checkboxId = `prop${firmKey.charAt(0).toUpperCase()}${firmKey.slice(1)}`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox && checkbox.checked) {
                    selectedFirms.push({key: firmKey, rules: propFirmRules[firmKey]});
                }
            });
            
            if (selectedFirms.length === 0) {
                alert('‚ö†Ô∏è Please select at least one prop firm to optimize for!');
                return;
            }
            
            // Find the strictest rules across all selected firms (ONLY risk metrics that cause violations)
            const strictestRules = {
                maxDailyLoss: Math.min(...selectedFirms.map(f => f.rules.maxDailyLoss || 100)),
                maxDrawdown: Math.min(...selectedFirms.map(f => f.rules.maxDrawdown || 100))
            };
            
            // Check if any firms have trailing drawdown (EOD drawdown that can lock in profits)
            const hasTrailingDD = selectedFirms.some(f => f.rules.description && f.rules.description.includes('trailing'));
            
            // Set the filters to match strictest rules (NO WIN RATE - not a violation metric)
            document.getElementById('maxDailyLoss').value = strictestRules.maxDailyLoss;
            document.getElementById('maxDrawdown').value = strictestRules.maxDrawdown;
            document.getElementById('minWinRate').value = 0; // Remove win rate requirement
            document.getElementById('onlyPropViable').checked = true;
            
            // Show optimization message
            document.getElementById('results').innerHTML = `
                <div style="text-align: center; padding: 60px;">
                    <div style="font-size: 3rem; margin-bottom: var(--spacing-md);">üéØ</div>
                    <h3 style="color: var(--accent-secondary); margin-bottom: var(--spacing-md);">Optimizing for ${selectedFirms.length} Prop Firm${selectedFirms.length > 1 ? 's' : ''}</h3>
                    <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                        ${selectedFirms.map(f => f.rules.name).join(', ')}
                    </p>
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: var(--radius-md); padding: var(--spacing-lg); max-width: 600px; margin: 0 auto; text-align: left;">
                        <h4 style="margin: 0 0 var(--spacing-md) 0; color: var(--accent-primary);">Risk Limits (Violation Metrics Only):</h4>
                        <ul style="margin: 0; padding-left: 1.5rem; color: var(--text-primary); line-height: 1.8;">
                            <li><strong>Max Daily Loss:</strong> ${strictestRules.maxDailyLoss}% ${strictestRules.maxDailyLoss === 0 ? '(No daily limit)' : ''}</li>
                            <li><strong>Max Drawdown:</strong> ${strictestRules.maxDrawdown}% ${hasTrailingDD ? '(Trailing/EOD)' : ''}</li>
                            ${hasTrailingDD ? '<li><strong>‚ö†Ô∏è Trailing Drawdown:</strong> Protects profits but can lock losses</li>' : ''}
                        </ul>
                        <p style="margin: var(--spacing-sm) 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">
                            <em>Note: Win rate is NOT a violation metric and has been excluded from optimization</em>
                        </p>
                    </div>
                    <p style="color: var(--text-secondary); margin-top: var(--spacing-lg);">üîÑ Analyzing strategies...</p>
                </div>
            `;
            
            // Run the comparison with optimized settings
            await runComparison();
            
            // Add optimization summary to results
            setTimeout(() => {
                const resultsDiv = document.getElementById('results');
                const optimizationBanner = document.createElement('div');
                optimizationBanner.style.cssText = 'background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-bottom: var(--spacing-xl);';
                optimizationBanner.innerHTML = `
                    <div style="display: flex; align-items: center; gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                        <div style="font-size: 2rem;">üéØ</div>
                        <div>
                            <h3 style="margin: 0; color: var(--accent-secondary); font-size: 1.25rem;">Prop Firm Optimized Results</h3>
                            <p style="margin: 0.25rem 0 0 0; color: var(--text-secondary);">Strategies optimized for: ${selectedFirms.map(f => f.rules.name).join(', ')}</p>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--spacing-md); margin-top: var(--spacing-md);">
                        <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); border: 1px solid var(--border-color);">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Max Daily Loss Limit</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: ${strictestRules.maxDailyLoss === 0 ? '#10b981' : 'var(--accent-secondary)'}; margin-top: 0.25rem;">
                                ${strictestRules.maxDailyLoss === 0 ? 'No Limit ‚úì' : '‚â§ ' + strictestRules.maxDailyLoss + '%'}
                            </div>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); border: 1px solid var(--border-color);">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Max Drawdown ${hasTrailingDD ? '(Trailing)' : ''}</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary); margin-top: 0.25rem;">‚â§ ${strictestRules.maxDrawdown}%</div>
                            ${hasTrailingDD ? '<div style="font-size: 0.7rem; color: #f59e0b; margin-top: 0.25rem;">‚ö†Ô∏è Can lock in losses</div>' : ''}
                        </div>
                    </div>
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: var(--radius-sm); padding: var(--spacing-md); margin-top: var(--spacing-md);">
                        <p style="margin: 0; color: var(--text-primary); font-size: 0.875rem; line-height: 1.6;">
                            üí° <strong>Optimization Focus:</strong> Strategies filtered by VIOLATION METRICS only (daily loss & drawdown limits). Win rate excluded as it's not a rule violation.
                            ${hasTrailingDD ? '<br><br>‚ö†Ô∏è <strong>Trailing Drawdown Alert:</strong> Some firms use EOD trailing drawdown which locks in your high-water mark. Strategies with consistent positive expectancy are critical.' : ''}
                        </p>
                    </div>
                `;
                resultsDiv.insertBefore(optimizationBanner, resultsDiv.firstChild);
                
                // Automatically request GPT-4 analysis of top strategy
                if (allStrategies.length > 0) {
                    requestGPT4Analysis(allStrategies[0], selectedFirms, strictestRules);
                }
            }, 100);
        }
        
        async function requestGPT4Analysis(topStrategy, selectedFirms, strictestRules) {
            try {
                // Show loading indicator
                const resultsDiv = document.getElementById('results');
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'gpt4-analysis-loading';
                loadingDiv.style.cssText = 'background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-top: 20px;';
                loadingDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 2rem;">ü§ñ</div>
                        <div>
                            <h3 style="margin: 0; color: #8b5cf6;">GPT-4 is analyzing your strategy...</h3>
                            <p style="margin: 4px 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">This may take a few seconds</p>
                        </div>
                    </div>
                `;
                resultsDiv.insertBefore(loadingDiv, resultsDiv.children[1]);
                
                // Prepare strategy data
                const strategyData = {
                    sessions: topStrategy.sessions.join(' + '),
                    timeFilter: {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[topStrategy.timeFilter],
                    beStrategy: topStrategy.beStrategy === 'none' ? 'No Break Even' : 'Break Even at 1R',
                    rTarget: topStrategy.rTarget,
                    riskPerTrade: topStrategy.riskPerTrade,
                    expectancy: topStrategy.stats.expectancy.toFixed(3),
                    winRate: topStrategy.stats.winRate.toFixed(1),
                    expectedReturn: topStrategy.expectedReturnPercent.toFixed(2),
                    maxDailyLoss: topStrategy.maxDailyLossPercent.toFixed(1),
                    maxDrawdown: topStrategy.maxDrawdownPercent.toFixed(1),
                    totalTrades: topStrategy.stats.total,
                    profitFactor: topStrategy.profitFactor ? topStrategy.profitFactor.toFixed(2) : 'N/A'
                };
                
                const propFirmRules = {
                    firms: selectedFirms.map(f => f.rules.name),
                    maxDailyLoss: strictestRules.maxDailyLoss,
                    maxDrawdown: strictestRules.maxDrawdown,
                    hasTrailingDD: selectedFirms.some(f => f.rules.description && f.rules.description.includes('trailing'))
                };
                
                // Call GPT-4 API
                const response = await fetch('/api/gpt4-validate-strategy', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        strategy: strategyData,
                        propFirmRules: propFirmRules,
                        alternatives: allStrategies.slice(1, 4).map(s => ({
                            sessions: s.sessions.join('+'),
                            expectancy: s.stats.expectancy.toFixed(3),
                            expectedReturn: s.expectedReturnPercent.toFixed(2)
                        }))
                    })
                });
                
                const result = await response.json();
                
                // Remove loading indicator
                loadingDiv.remove();
                
                // Display GPT-4 analysis
                if (result.success) {
                    const analysisDiv = document.createElement('div');
                    analysisDiv.style.cssText = 'background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.1)); border: 2px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-top: 20px;';
                    analysisDiv.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <div style="font-size: 2rem;">ü§ñ</div>
                            <div>
                                <h3 style="margin: 0; color: #8b5cf6; font-size: 1.25rem;">GPT-4 Strategy Analysis</h3>
                                <p style="margin: 4px 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">Independent AI validation of strategy selection</p>
                            </div>
                        </div>
                        <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 16px; line-height: 1.8; color: var(--text-primary); white-space: pre-wrap;">${result.analysis}</div>
                        <p style="margin: 12px 0 0 0; color: var(--text-secondary); font-size: 0.75rem; font-style: italic;">
                            Powered by OpenAI GPT-4 ‚Ä¢ Analysis generated at ${new Date(result.timestamp).toLocaleTimeString()}
                        </p>
                    `;
                    resultsDiv.insertBefore(analysisDiv, resultsDiv.children[1]);
                } else {
                    console.error('GPT-4 analysis failed:', result.error);
                }
                
            } catch (error) {
                console.error('Error requesting GPT-4 analysis:', error);
                // Remove loading indicator if it exists
                const loadingDiv = document.getElementById('gpt4-analysis-loading');
                if (loadingDiv) loadingDiv.remove();
            }
        }
        
        async function runComparison() {
            if (allSignals.length === 0) await loadSignals();
            
            // Apply date filter
            if (!filterSignalsByDate()) {
                return;
            }
            
            if (signals.length === 0) {
                document.getElementById('results').innerHTML = '<div style="text-align: center; padding: 60px; color: var(--accent-warning);">‚ö†Ô∏è No signals found for the selected time period</div>';
                return;
            }
            
            document.getElementById('results').innerHTML = '<div style="text-align: center; padding: 60px;">üîÑ Analyzing strategies...</div>';
            
            // Check if Best of All Time mode is active
            const bestLowestDD = document.getElementById('bestLowestDD').checked;
            const bestExpectedPercent = document.getElementById('bestExpectedPercent').checked;
            const bestExpectedR = document.getElementById('bestExpectedR').checked;
            const bestWinRate = document.getElementById('bestWinRate').checked;
            const bestProfitFactor = document.getElementById('bestProfitFactor').checked;
            const bestExpectancy = document.getElementById('bestExpectancy').checked;
            const bestSmoothestCurve = document.getElementById('bestSmoothestCurve').checked;
            const anyBestOfSelected = bestLowestDD || bestExpectedPercent || bestExpectedR || bestWinRate || bestProfitFactor || bestExpectancy || bestSmoothestCurve;
            
            // If Best of All Time mode, use multiple risk percentages; otherwise use selected value
            const riskPerTradeValues = anyBestOfSelected 
                ? [0.15, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0] 
                : [parseFloat(document.getElementById('riskPerTrade').value)];
            
            const maxDrawdown = parseFloat(document.getElementById('maxDrawdown').value);
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const sessions = ['Asia', 'London', 'NY Pre Market', 'NY AM', 'NY Lunch', 'NY PM'];
            const beStrategies = ['none', 'be1'];
            const rTargets = [];
            for (let r = 1; r <= 20; r += 0.5) rTargets.push(r);
            const timeFilters = ['none', 'optimal', 'macro', 'both'];
            
            const totalPossible = 62 * 2 * rTargets.length * timeFilters.length * riskPerTradeValues.length;
            const strategies = [];
            
            riskPerTradeValues.forEach(riskPerTrade => {
                timeFilters.forEach(timeFilter => {
                    beStrategies.forEach(beStrategy => {
                        rTargets.forEach(rTarget => {
                            const optimalHours = {};
                            if (timeFilter === 'optimal' || timeFilter === 'both') {
                                sessions.forEach(session => {
                                    const sessionSignals = signals.filter(s => s.session === session);
                                    const hourlyPerf = {};
                                    sessionSignals.forEach(s => {
                                        if (!s.time) return;
                                        const hour = parseInt(s.time.split(':')[0]);
                                        if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                                        hourlyPerf[hour].push(s);
                                    });
                                    const hourlyStats = Object.entries(hourlyPerf)
                                        .map(([hour, sigs]) => {
                                            if (sigs.length < 3) return null;
                                            const results = sigs.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                            const stats = calculateStats(results);
                                            return { hour: parseInt(hour), expectancy: stats.expectancy };
                                        })
                                        .filter(h => h !== null)
                                        .sort((a, b) => b.expectancy - a.expectancy);
                                    if (hourlyStats.length > 0) optimalHours[session] = hourlyStats[0].hour;
                                });
                            }
                            
                            sessions.forEach(session => {
                                let sessionSignals = signals.filter(s => s.session === session);
                                if (timeFilter === 'optimal' && optimalHours[session] !== undefined) {
                                    sessionSignals = sessionSignals.filter(s => s.time && parseInt(s.time.split(':')[0]) === optimalHours[session]);
                                } else if (timeFilter === 'macro') {
                                    sessionSignals = sessionSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (minute >= 45) || (minute <= 15);
                                    });
                                } else if (timeFilter === 'both' && optimalHours[session] !== undefined) {
                                    sessionSignals = sessionSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        const optHour = optimalHours[session];
                                        // Full optimal hour + 15 min before + 15 min after = (optHour-1):45 to (optHour+1):15
                                        const inWindow = (hour === ((optHour - 1 + 24) % 24) && minute >= 45) || 
                                                        (hour === optHour) || 
                                                        (hour === ((optHour + 1) % 24) && minute <= 15);
                                        return inWindow;
                                    });
                                }
                                if (sessionSignals.length < 30) return;
                                const results = sessionSignals.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                const stats = calculateStats(results);
                                const smoothness = calculateEquityCurveSmoothness(results);
                                const expectedReturnPercent = stats.expectedTotalReturn * riskPerTrade;
                                const maxDrawdownPercent = stats.maxDrawdown * riskPerTrade;
                                if (stats.expectancy > 0 && maxDrawdownPercent <= maxDrawdown) {
                                    strategies.push({
                                        sessions: [session], beStrategy, rTarget, riskPerTrade, timeFilter, stats, smoothness, expectedReturnPercent,
                                        maxDailyLossPercent: stats.maxConsecLosses * riskPerTrade,
                                        maxDrawdownPercent
                                    });
                                }
                            });
                            
                            const n = sessions.length;
                            for (let mask = 2; mask < (1 << n); mask++) {
                                const sessionCombo = [];
                                for (let i = 0; i < n; i++) {
                                    if (mask & (1 << i)) sessionCombo.push(sessions[i]);
                                }
                                if (sessionCombo.length === 1) continue;
                                
                                let combinedSignals = signals.filter(s => sessionCombo.includes(s.session));
                                if (timeFilter === 'optimal') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        const optHour = optimalHours[s.session];
                                        return optHour !== undefined && s.time && parseInt(s.time.split(':')[0]) === optHour;
                                    });
                                } else if (timeFilter === 'macro') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (minute >= 45) || (minute <= 15);
                                    });
                                } else if (timeFilter === 'both') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        const optHour = optimalHours[s.session];
                                        if (optHour === undefined || !s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        // Full optimal hour + 15 min before + 15 min after = (optHour-1):45 to (optHour+1):15
                                        const inWindow = (hour === ((optHour - 1 + 24) % 24) && minute >= 45) || 
                                                        (hour === optHour) || 
                                                        (hour === ((optHour + 1) % 24) && minute <= 15);
                                        return inWindow;
                                    });
                                }
                                if (combinedSignals.length < 50) continue;
                                const results = combinedSignals.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                const stats = calculateStats(results);
                                const smoothness = calculateEquityCurveSmoothness(results);
                                const expectedReturnPercent = stats.expectedTotalReturn * riskPerTrade;
                                const maxDrawdownPercent = stats.maxDrawdown * riskPerTrade;
                                if (stats.expectancy > 0 && maxDrawdownPercent <= maxDrawdown) {
                                    strategies.push({
                                        sessions: sessionCombo, beStrategy, rTarget, riskPerTrade, timeFilter, stats, smoothness, expectedReturnPercent,
                                        maxDailyLossPercent: stats.maxConsecLosses * riskPerTrade,
                                        maxDrawdownPercent
                                    });
                                }
                            }
                        });
                    });
                });
            });
            
            const onlyPropViable = document.getElementById('onlyPropViable').checked;
            const maxDailyLoss = parseFloat(document.getElementById('maxDailyLoss').value);
            const minWinRate = parseFloat(document.getElementById('minWinRate').value);
            const minExpectancy = parseFloat(document.getElementById('minExpectancy').value);
            const minProfitFactor = parseFloat(document.getElementById('minProfitFactor').value);
            
            // Store signals for each strategy for profit factor calculation
            const strategySignalsMap = new Map();
            strategies.forEach((s, idx) => {
                let filteredSignals = signals.filter(sig => s.sessions.includes(sig.session));
                
                if (s.timeFilter === 'optimal' || s.timeFilter === 'both') {
                    const optimalHours = {};
                    s.sessions.forEach(session => {
                        const sessionSignals = signals.filter(sig => sig.session === session);
                        const hourlyPerf = {};
                        sessionSignals.forEach(sig => {
                            if (!sig.time) return;
                            const hour = parseInt(sig.time.split(':')[0]);
                            if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                            hourlyPerf[hour].push(sig);
                        });
                        const hourlyStats = Object.entries(hourlyPerf)
                            .map(([hour, sigs]) => {
                                if (sigs.length < 3) return null;
                                const results = sigs.map(sig => calculateTradeResult(sig, s.beStrategy, s.rTarget, feeR));
                                const stats = calculateStats(results);
                                return { hour: parseInt(hour), expectancy: stats.expectancy };
                            })
                            .filter(h => h !== null)
                            .sort((a, b) => b.expectancy - a.expectancy);
                        if (hourlyStats.length > 0) optimalHours[session] = hourlyStats[0].hour;
                    });
                    
                    if (s.timeFilter === 'optimal') {
                        filteredSignals = filteredSignals.filter(sig => {
                            const optHour = optimalHours[sig.session];
                            return optHour !== undefined && sig.time && parseInt(sig.time.split(':')[0]) === optHour;
                        });
                    } else if (s.timeFilter === 'both') {
                        filteredSignals = filteredSignals.filter(sig => {
                            const optHour = optimalHours[sig.session];
                            if (optHour === undefined || !sig.time) return false;
                            const [hour, minute] = sig.time.split(':').map(Number);
                            // Full optimal hour + 15 min before + 15 min after = (optHour-1):45 to (optHour+1):15
                            const inWindow = (hour === ((optHour - 1 + 24) % 24) && minute >= 45) || 
                                            (hour === optHour) || 
                                            (hour === ((optHour + 1) % 24) && minute <= 15);
                            return inWindow;
                        });
                    }
                } else if (s.timeFilter === 'macro') {
                    filteredSignals = filteredSignals.filter(sig => {
                        if (!sig.time) return false;
                        const [hour, minute] = sig.time.split(':').map(Number);
                        return (minute >= 45) || (minute <= 15);
                    });
                }
                
                strategySignalsMap.set(idx, filteredSignals);
            });
            
            // anyBestOfSelected already declared at top of function
            let filteredStrategies;
            
            if (anyBestOfSelected) {
                // Best Of mode - override all filters and rank by selected criteria
                // Calculate profit factor for all strategies
                const strategiesWithMetrics = strategies.map((s, idx) => {
                    const stratSignals = strategySignalsMap.get(idx);
                    const results = stratSignals.map(sig => calculateTradeResult(sig, s.beStrategy, s.rTarget, feeR));
                    const winResults = results.filter(r => r > 0);
                    const lossResults = results.filter(r => r < 0);
                    const totalWinR = winResults.reduce((a,b) => a + b, 0);
                    const totalLossR = Math.abs(lossResults.reduce((a,b) => a + b, 0));
                    const profitFactor = totalLossR > 0 ? (totalWinR / totalLossR) : (totalWinR > 0 ? 999 : 0);
                    
                    return {
                        ...s,
                        profitFactor,
                        compositeScore: 0,
                        originalIndex: idx  // Track original index for signal mapping
                    };
                });
                
                // Apply prop firm viable filtering FIRST if enabled
                const onlyPropViable = document.getElementById('onlyPropViable').checked;
                let viableStrategies = strategiesWithMetrics;
                
                if (onlyPropViable) {
                    viableStrategies = strategiesWithMetrics.filter(s => 
                        s.maxDailyLossPercent <= maxDailyLoss && 
                        s.maxDrawdownPercent <= maxDrawdown && 
                        s.stats.winRate >= minWinRate
                    );
                }
                
                // Group strategies by risk level
                const riskGroups = {};
                viableStrategies.forEach(s => {
                    const risk = s.riskPerTrade;
                    if (!riskGroups[risk]) riskGroups[risk] = [];
                    riskGroups[risk].push(s);
                });
                
                // Calculate composite score WITHIN each risk group
                Object.keys(riskGroups).forEach(risk => {
                    const groupStrategies = riskGroups[risk];
                    
                    groupStrategies.forEach(s => {
                        let score = 0;
                        let criteriaCount = 0;
                        
                        if (bestLowestDD) {
                            // Lower is better - invert the score (compare within risk group)
                            const maxDD = Math.max(...groupStrategies.map(st => st.maxDrawdownPercent));
                            const minDD = Math.min(...groupStrategies.map(st => st.maxDrawdownPercent));
                            score += maxDD > minDD ? (maxDD - s.maxDrawdownPercent) / (maxDD - minDD) : 1;
                            criteriaCount++;
                        }
                        if (bestExpectedPercent) {
                            const maxExp = Math.max(...groupStrategies.map(st => st.expectedReturnPercent));
                            const minExp = Math.min(...groupStrategies.map(st => st.expectedReturnPercent));
                            score += maxExp > minExp ? (s.expectedReturnPercent - minExp) / (maxExp - minExp) : 1;
                            criteriaCount++;
                        }
                        if (bestExpectedR) {
                            const maxExpR = Math.max(...groupStrategies.map(st => st.stats.expectedTotalReturn));
                            const minExpR = Math.min(...groupStrategies.map(st => st.stats.expectedTotalReturn));
                            score += maxExpR > minExpR ? (s.stats.expectedTotalReturn - minExpR) / (maxExpR - minExpR) : 1;
                            criteriaCount++;
                        }
                        if (bestWinRate) {
                            const maxWR = Math.max(...groupStrategies.map(st => st.stats.winRate));
                            const minWR = Math.min(...groupStrategies.map(st => st.stats.winRate));
                            score += maxWR > minWR ? (s.stats.winRate - minWR) / (maxWR - minWR) : 1;
                            criteriaCount++;
                        }
                        if (bestProfitFactor) {
                            const maxPF = Math.max(...groupStrategies.map(st => st.profitFactor));
                            const minPF = Math.min(...groupStrategies.map(st => st.profitFactor));
                            score += maxPF > minPF ? (s.profitFactor - minPF) / (maxPF - minPF) : 1;
                            criteriaCount++;
                        }
                        if (bestExpectancy) {
                            const maxExpcy = Math.max(...groupStrategies.map(st => st.stats.expectancy));
                            const minExpcy = Math.min(...groupStrategies.map(st => st.stats.expectancy));
                            score += maxExpcy > minExpcy ? (s.stats.expectancy - minExpcy) / (maxExpcy - minExpcy) : 1;
                            criteriaCount++;
                        }
                        if (bestSmoothestCurve) {
                            const maxSmooth = Math.max(...groupStrategies.map(st => st.smoothness ? st.smoothness.smoothnessScore : 0));
                            const minSmooth = Math.min(...groupStrategies.map(st => st.smoothness ? st.smoothness.smoothnessScore : 0));
                            score += maxSmooth > minSmooth ? ((s.smoothness ? s.smoothness.smoothnessScore : 0) - minSmooth) / (maxSmooth - minSmooth) : 1;
                            criteriaCount++;
                        }
                        
                        s.compositeScore = criteriaCount > 0 ? score / criteriaCount : 0;
                    });
                    
                    // Sort within each risk group and take top 5
                    riskGroups[risk] = groupStrategies.sort((a, b) => b.compositeScore - a.compositeScore).slice(0, 5);
                });
                
                // Flatten back to single array (top 5 from each risk level)
                filteredStrategies = [];
                Object.keys(riskGroups).sort((a, b) => parseFloat(a) - parseFloat(b)).forEach(risk => {
                    filteredStrategies.push(...riskGroups[risk]);
                });
                
            } else {
                // Normal filtering mode
                filteredStrategies = strategies.filter((s, idx) => {
                    const stratSignals = strategySignalsMap.get(idx);
                    const results = stratSignals.map(sig => calculateTradeResult(sig, s.beStrategy, s.rTarget, feeR));
                    const winResults = results.filter(r => r > 0);
                    const lossResults = results.filter(r => r < 0);
                    const totalWinR = winResults.reduce((a,b) => a + b, 0);
                    const totalLossR = Math.abs(lossResults.reduce((a,b) => a + b, 0));
                    const profitFactor = totalLossR > 0 ? (totalWinR / totalLossR) : (totalWinR > 0 ? 999 : 0);
                    
                    if (s.stats.expectancy < minExpectancy) return false;
                    if (profitFactor < minProfitFactor) return false;
                    
                    if (onlyPropViable) {
                        return s.maxDailyLossPercent <= maxDailyLoss && s.maxDrawdownPercent <= maxDrawdown && s.stats.winRate >= minWinRate;
                    }
                    return true;
                });
            }
            
            // Map filtered strategies to their original indices
            const filteredIndices = [];
            strategies.forEach((s, idx) => {
                if (filteredStrategies.includes(s)) {
                    filteredIndices.push(idx);
                }
            });
            
            // Sort based on mode
            if (anyBestOfSelected) {
                // Already sorted by composite score - show ALL strategies (grouped by risk level)
                allStrategies = filteredStrategies;
            } else {
                filteredStrategies.sort((a, b) => b.expectedReturnPercent - a.expectedReturnPercent);
                allStrategies = filteredStrategies.slice(0, 20);  // Limit to top 20 in normal mode
            }
            allStrategySignals = allStrategies.map(s => {
                // Use originalIndex if available (Best Of mode), otherwise find in original array
                const originalIdx = s.originalIndex !== undefined ? s.originalIndex : strategies.indexOf(s);
                return strategySignalsMap.get(originalIdx);
            });
            displayComparison(allStrategies, totalPossible, filteredStrategies.length);
        }
        
        function generateStrategyRow(s, displayIndex, dataIndex, beText, maxDailyLoss, maxDrawdown, minWinRate) {
            const rowClass = displayIndex === 0 ? 'style="background: rgba(0,255,136,0.1);"' : '';
            const sessionsText = s.sessions.join('+');
            const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[s.timeFilter];
            const propViable = s.maxDailyLossPercent <= maxDailyLoss && s.maxDrawdownPercent <= maxDrawdown && s.stats.winRate >= minWinRate;
            const propIcon = propViable ? '‚úÖ' : '‚ùå';
            const expectancyColor = s.stats.expectancy > 0.2 ? `rgba(0,255,136,${Math.min(s.stats.expectancy * 2, 1) * 0.3})` : 'transparent';
            const winRateColor = s.stats.winRate > 50 ? `rgba(0,255,136,${(s.stats.winRate - 50) / 50 * 0.3})` : 'transparent';
            const ddColor = `rgba(255,71,87,${Math.min(s.maxDrawdownPercent / 10, 1) * 0.3})`;
            
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const results = allStrategySignals[dataIndex].map(sig => calculateTradeResult(sig, s.beStrategy, s.rTarget, feeR));
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const totalWinR = winResults.reduce((a,b) => a + b, 0);
            const totalLossR = Math.abs(lossResults.reduce((a,b) => a + b, 0));
            const profitFactor = totalLossR > 0 ? (totalWinR / totalLossR) : (totalWinR > 0 ? 999 : 0);
            const pfColor = profitFactor >= 2 ? `rgba(0,255,136,${Math.min((profitFactor - 1) / 3, 1) * 0.3})` : 'transparent';
            
            return `<tr ${rowClass} data-index="${dataIndex}">
                <td>${displayIndex === 0 ? 'üèÜ' : displayIndex + 1}</td>
                <td>${sessionsText}</td>
                <td>${timeFilterText}</td>
                <td>${beText[s.beStrategy]}</td>
                <td>${s.rTarget}R</td>
                <td style="background: ${expectancyColor}; font-weight: 600;">${s.stats.expectancy.toFixed(3)}</td>
                <td style="background: ${pfColor}; font-weight: 600;">${profitFactor === 999 ? '‚àû' : profitFactor.toFixed(2)}</td>
                <td>${s.stats.avgTrade.toFixed(3)}R</td>
                <td style="background: ${winRateColor}; font-weight: 600;">${s.stats.winRate.toFixed(1)}%</td>
                <td>${s.stats.breakevenRate.toFixed(1)}%</td>
                <td>${s.stats.total}</td>
                <td style="color: #00ff88; font-weight: 700;">${s.stats.expectedTotalReturn > 0 ? '+' : ''}${s.stats.expectedTotalReturn.toFixed(1)}R</td>
                <td style="color: #00ff88; font-weight: 700;">${s.expectedReturnPercent > 0 ? '+' : ''}${s.expectedReturnPercent.toFixed(2)}%</td>
                <td style="background: ${(maxDailyLoss > 0 && s.maxDailyLossPercent > maxDailyLoss) ? '#ff4444' : '#22c55e'}; color: white; font-weight: 600;">${s.maxDailyLossPercent.toFixed(1)}%</td>
                <td style="background: ${ddColor}; font-weight: 600;">${s.maxDrawdownPercent.toFixed(1)}%</td>
                <td style="font-weight: 600; color: ${s.smoothness && s.smoothness.smoothnessScore >= 75 ? '#00ff88' : s.smoothness && s.smoothness.smoothnessScore >= 60 ? '#f59e0b' : '#ff4444'};" title="R¬≤: ${s.smoothness ? s.smoothness.rSquared : 'N/A'} | Recovery: ${s.smoothness ? s.smoothness.recoveryFactor : 'N/A'} | Max Loss Streak: ${s.smoothness ? s.smoothness.maxConsecutiveLosses : 'N/A'}">${s.smoothness ? s.smoothness.smoothnessScore : 'N/A'}</td>
                <td style="text-align: center; font-size: 18px;">${propIcon}</td>
                <td><button onclick="showStrategyDetails(${dataIndex})" class="view-btn">üìä View</button></td>
            </tr>`;
        }
        
        function displayComparison(strategies, totalPossible, profitableCount) {
            if (!strategies || strategies.length === 0) {
                document.getElementById('results').innerHTML = '<div class="results-card" style="text-align: center; padding: 60px; color: var(--accent-warning);">No strategies found matching criteria</div>';
                return;
            }
            
            // Check if Best of All Time mode is active
            const bestLowestDD = document.getElementById('bestLowestDD').checked;
            const bestExpectedPercent = document.getElementById('bestExpectedPercent').checked;
            const bestExpectedR = document.getElementById('bestExpectedR').checked;
            const bestWinRate = document.getElementById('bestWinRate').checked;
            const bestProfitFactor = document.getElementById('bestProfitFactor').checked;
            const bestExpectancy = document.getElementById('bestExpectancy').checked;
            const bestSmoothestCurve = document.getElementById('bestSmoothestCurve').checked;
            const anyBestOfSelected = bestLowestDD || bestExpectedPercent || bestExpectedR || bestWinRate || bestProfitFactor || bestExpectancy || bestSmoothestCurve;
            
            const beText = { 'none': 'No BE', 'be1': 'BE=1R' };
            const maxDailyLoss = parseFloat(document.getElementById('maxDailyLoss')?.value || 5);
            
            let html = '';
            
            // If Best of All Time mode, group by risk percentage
            if (anyBestOfSelected) {
                // Group strategies by risk percentage
                const riskGroups = {};
                strategies.forEach((s, i) => {
                    const risk = s.riskPerTrade;
                    if (!riskGroups[risk]) riskGroups[risk] = [];
                    riskGroups[risk].push({...s, originalIndex: i});
                });
                
                // Sort risk levels
                const sortedRisks = Object.keys(riskGroups).map(Number).sort((a, b) => a - b);
                
                // Display each risk group
                sortedRisks.forEach(risk => {
                    const groupStrategies = riskGroups[risk]; // Show ALL strategies at this risk level
                    
                    html += `<div style="margin-bottom: var(--spacing-xl);">`;
                    html += `<div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1)); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: var(--radius-md); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">`;
                    html += `<h3 style="margin: 0; color: var(--accent-secondary); font-size: 1.25rem;">üí∞ Risk Per Trade: ${risk}%</h3>`;
                    html += `<p style="margin: 0.5rem 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">${groupStrategies.length} strategies at this risk level</p>`;
                    html += `</div>`;
                    
                    html += '<table class="risk-group-table"><thead><tr><th>Rank</th><th>Sessions</th><th>Time Filter</th><th>BE</th><th>R-Target</th><th class="sortable" data-sort="expectancy">Expectancy</th><th class="sortable" data-sort="profitFactor">Profit Factor</th><th class="sortable" data-sort="avgTrade">Avg Trade</th><th class="sortable" data-sort="winRate">Win Rate</th><th class="sortable" data-sort="breakevenRate">BE Rate</th><th class="sortable" data-sort="trades">Trades</th><th class="sortable" data-sort="expectedR">Expected R</th><th class="sortable" data-sort="expectedPercent">Expected %</th><th class="sortable" data-sort="maxDailyLoss">Max Daily Loss</th><th class="sortable" data-sort="maxDD">Max DD</th><th class="sortable" data-sort="smoothness">Smoothness</th><th>Prop Viable</th><th>Details</th></tr></thead><tbody>';
                    
                    const minWinRate = parseFloat(document.getElementById('minWinRate')?.value || 20);
                    const maxDrawdown = parseFloat(document.getElementById('maxDrawdown')?.value || 10);
                    
                    groupStrategies.forEach((s, i) => {
                        html += generateStrategyRow(s, i, s.originalIndex, beText, maxDailyLoss, maxDrawdown, minWinRate);
                    });
                    
                    html += '</tbody></table></div>';
                });
                
            } else {
                // Normal display mode
                const minWinRate = parseFloat(document.getElementById('minWinRate')?.value || 20);
                const maxDrawdown = parseFloat(document.getElementById('maxDrawdown')?.value || 10);
                
                html += '<table id="strategyTable"><thead><tr><th>Rank</th><th>Sessions</th><th>Time Filter</th><th>BE</th><th>R-Target</th><th class="sortable" data-sort="expectancy">Expectancy</th><th class="sortable" data-sort="profitFactor">Profit Factor</th><th class="sortable" data-sort="avgTrade">Avg Trade</th><th class="sortable" data-sort="winRate">Win Rate</th><th class="sortable" data-sort="breakevenRate">BE Rate</th><th class="sortable" data-sort="trades">Trades</th><th class="sortable" data-sort="expectedR">Expected R</th><th class="sortable" data-sort="expectedPercent">Expected %</th><th class="sortable" data-sort="maxDailyLoss">Max Daily Loss</th><th class="sortable" data-sort="maxDD">Max DD</th><th class="sortable" data-sort="smoothness">Smoothness</th><th>Prop Viable</th><th>Details</th></tr></thead><tbody>';
                
                strategies.forEach((s, i) => {
                    html += generateStrategyRow(s, i, i, beText, maxDailyLoss, maxDrawdown, minWinRate);
                });
                
                html += '</tbody></table>';
            }
            
            html += '<div class="info-card">';
            html += '<h3>üìä Strategy Universe</h3>';
            html += `<p><strong>Total Possible:</strong> ${totalPossible.toLocaleString()}</p>`;
            html += `<p><strong>Profitable:</strong> ${profitableCount} (${((profitableCount/totalPossible)*100).toFixed(2)}%)</p>`;
            html += '</div>';
            html += '<div class="info-card" style="background: rgba(16, 185, 129, 0.05); border-color: rgba(16, 185, 129, 0.2);">';
            html += '<h3 style="color: var(--accent-secondary);">üèÜ Winner Analysis</h3>';
            const winner = strategies[0];
            const winnerSessions = winner.sessions.join(' + ');
            const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[winner.timeFilter];
            html += `<p><strong>Best Strategy:</strong> ${winnerSessions} | ${timeFilterText} | ${beText[winner.beStrategy]} | ${winner.rTarget}R</p>`;
            html += `<p><strong>Expected Total Return:</strong> ${winner.stats.expectedTotalReturn.toFixed(1)}R (${winner.expectedReturnPercent.toFixed(2)}%)</p>`;
            html += `<p><strong>Why it wins:</strong> Expectancy (${winner.stats.expectancy.toFixed(3)}R) √ó Trade Count (${winner.stats.total}) √ó Risk (${winner.riskPerTrade}%) = Highest expected account growth</p>`;
            html += '</div>';
            
            html += '<div class="chart-container">';
            html += '<div class="chart-header"><h3>üìä Strategy Performance Map</h3></div>';
            html += '<div id="scatterPlot" style="width: 100%; height: 600px;"></div>';
            html += '</div>';
            
            document.getElementById('results').innerHTML = `<div class="results-card">${html}</div>`;
            
            initTableSort();
            renderScatterPlot(strategies);
        }
        
        function renderScatterPlot(strategies) {
            const container = d3.select('#scatterPlot');
            container.selectAll('*').remove();
            
            const width = container.node().offsetWidth;
            const height = 600;
            const margin = {top: 60, right: 120, bottom: 80, left: 80};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            const svg = container.append('svg').attr('width', width).attr('height', height);
            
            const xExtent = d3.extent(strategies, d => d.stats.expectancy);
            const yExtent = d3.extent(strategies, d => d.maxDrawdownPercent);
            const xScale = d3.scaleLinear().domain([Math.min(xExtent[0] - 0.05, -0.1), xExtent[1] + 0.05]).range([0, innerWidth]);
            const yScale = d3.scaleLinear().domain([0, yExtent[1] + 1]).range([innerHeight, 0]);
            const sizeScale = d3.scaleSqrt().domain([0, d3.max(strategies, d => Math.abs(d.expectedReturnPercent))]).range([8, 40]);
            
            const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
            
            svg.append('text').attr('x', width / 2).attr('y', 30).attr('text-anchor', 'middle').style('fill', 'var(--text-primary)').style('font-size', '18px').style('font-weight', '700').text('Risk-Reward Analysis: Expectancy vs Maximum Drawdown');
            
            const medianExp = d3.median(strategies, d => d.stats.expectancy);
            const medianDD = d3.median(strategies, d => d.maxDrawdownPercent);
            
            g.append('rect').attr('x', 0).attr('y', 0).attr('width', xScale(medianExp)).attr('height', yScale(medianDD)).attr('fill', 'rgba(239,68,68,0.03)');
            g.append('rect').attr('x', xScale(medianExp)).attr('y', 0).attr('width', innerWidth - xScale(medianExp)).attr('height', yScale(medianDD)).attr('fill', 'rgba(16,185,129,0.08)');
            g.append('rect').attr('x', 0).attr('y', yScale(medianDD)).attr('width', xScale(medianExp)).attr('height', innerHeight - yScale(medianDD)).attr('fill', 'rgba(239,68,68,0.06)');
            g.append('rect').attr('x', xScale(medianExp)).attr('y', yScale(medianDD)).attr('width', innerWidth - xScale(medianExp)).attr('height', innerHeight - yScale(medianDD)).attr('fill', 'rgba(16,185,129,0.03)');
            
            g.append('text').attr('x', xScale(medianExp) + (innerWidth - xScale(medianExp)) / 2).attr('y', yScale(medianDD) / 2 - 10).attr('text-anchor', 'middle').style('fill', 'var(--accent-secondary)').style('font-size', '13px').style('font-weight', '700').style('opacity', 0.6).text('High Reward');
            g.append('text').attr('x', xScale(medianExp) + (innerWidth - xScale(medianExp)) / 2).attr('y', yScale(medianDD) / 2 + 10).attr('text-anchor', 'middle').style('fill', 'var(--accent-secondary)').style('font-size', '13px').style('font-weight', '700').style('opacity', 0.6).text('Low Risk');
            g.append('text').attr('x', xScale(medianExp) / 2).attr('y', yScale(medianDD) / 2).attr('text-anchor', 'middle').style('fill', '#ef4444').style('font-size', '12px').style('font-weight', '600').style('opacity', 0.5).text('Low Reward / Low Risk');
            g.append('text').attr('x', xScale(medianExp) / 2).attr('y', innerHeight - (innerHeight - yScale(medianDD)) / 2).attr('text-anchor', 'middle').style('fill', '#ef4444').style('font-size', '12px').style('font-weight', '600').style('opacity', 0.5).text('Low Reward / High Risk');
            g.append('text').attr('x', xScale(medianExp) + (innerWidth - xScale(medianExp)) / 2).attr('y', innerHeight - (innerHeight - yScale(medianDD)) / 2).attr('text-anchor', 'middle').style('fill', 'var(--text-secondary)').style('font-size', '12px').style('font-weight', '600').style('opacity', 0.5).text('High Reward / High Risk');
            
            g.append('line').attr('x1', xScale(0)).attr('x2', xScale(0)).attr('y1', 0).attr('y2', innerHeight).attr('stroke', '#ef4444').attr('stroke-width', 2).attr('stroke-dasharray', '5,5').attr('opacity', 0.4);
            
            const xAxisGrid = d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat('');
            const yAxisGrid = d3.axisLeft(yScale).tickSize(-innerWidth).tickFormat('');
            g.append('g').attr('class', 'grid').attr('transform', `translate(0,${innerHeight})`).call(xAxisGrid).style('stroke', 'var(--border-color)').style('stroke-opacity', 0.3);
            g.append('g').attr('class', 'grid').call(yAxisGrid).style('stroke', 'var(--border-color)').style('stroke-opacity', 0.3);
            
            g.append('g').attr('transform', `translate(0,${innerHeight})`).call(d3.axisBottom(xScale).tickFormat(d => d.toFixed(2))).style('color', 'var(--text-primary)').style('font-size', '12px');
            g.append('g').call(d3.axisLeft(yScale).tickFormat(d => d.toFixed(1) + '%')).style('color', 'var(--text-primary)').style('font-size', '12px');
            
            g.append('text').attr('x', innerWidth / 2).attr('y', innerHeight + 55).attr('text-anchor', 'middle').style('fill', 'var(--text-primary)').style('font-size', '14px').style('font-weight', '600').text('Expectancy (R Multiplier)');
            g.append('text').attr('transform', 'rotate(-90)').attr('x', -innerHeight / 2).attr('y', -55).attr('text-anchor', 'middle').style('fill', 'var(--text-primary)').style('font-size', '14px').style('font-weight', '600').text('Maximum Drawdown (%)');
            
            const tooltip = d3.select('body').append('div').style('position', 'absolute').style('background', 'var(--bg-secondary)').style('color', 'var(--text-primary)').style('padding', '12px').style('border-radius', 'var(--radius-sm)').style('border', '1px solid var(--border-color)').style('pointer-events', 'none').style('opacity', 0).style('z-index', '10000').style('box-shadow', 'var(--shadow-md)').style('font-size', '12px');
            
            const bubbles = g.selectAll('.bubble').data(strategies).enter().append('circle').attr('class', 'bubble').attr('data-index', (d, i) => i).attr('cx', d => xScale(d.stats.expectancy)).attr('cy', d => yScale(d.maxDrawdownPercent)).attr('r', d => sizeScale(Math.abs(d.expectedReturnPercent))).attr('fill', 'var(--accent-primary)').attr('opacity', 0.6).attr('stroke', 'var(--text-primary)').attr('stroke-width', 1.5).style('cursor', 'pointer').transition().duration(600).ease(d3.easeCubicOut).attr('opacity', 0.7);
            
            g.selectAll('.bubble').on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('opacity', 1).attr('stroke-width', 3).attr('r', sizeScale(Math.abs(d.expectedReturnPercent)) * 1.2);
                const sessionsText = d.sessions.join(' + ');
                tooltip.transition().duration(150).style('opacity', 1);
                tooltip.html(`<div style="font-weight: 600; margin-bottom: 6px; color: var(--accent-primary);">${sessionsText}</div><div><strong>Expectancy:</strong> ${d.stats.expectancy.toFixed(3)}</div><div><strong>Max DD:</strong> ${d.maxDrawdownPercent.toFixed(1)}%</div><div><strong>Expected Return:</strong> <span style="color: var(--accent-secondary);">${d.expectedReturnPercent.toFixed(2)}%</span></div><div style="margin-top: 4px; font-size: 11px; color: var(--text-secondary);">Click to view details</div>`).style('left', (event.pageX + 15) + 'px').style('top', (event.pageY - 10) + 'px');
            }).on('mouseout', function(event, d) {
                d3.select(this).transition().duration(200).attr('opacity', 0.7).attr('stroke-width', 1.5).attr('r', sizeScale(Math.abs(d.expectedReturnPercent)));
                tooltip.transition().duration(150).style('opacity', 0);
            }).on('click', function(event, d) {
                const index = strategies.indexOf(d);
                const tableRow = document.querySelector(`#strategyTable tbody tr[data-index="${index}"]`);
                if (tableRow) {
                    tableRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    tableRow.style.background = 'rgba(59, 130, 246, 0.2)';
                    setTimeout(() => { tableRow.style.background = ''; }, 2000);
                }
            });
            
            const legend = svg.append('g').attr('transform', `translate(${width - 100}, ${margin.top + 20})`);
            legend.append('text').attr('x', 0).attr('y', 0).style('fill', 'var(--text-primary)').style('font-size', '13px').style('font-weight', '700').text('Bubble Size');
            const sizes = [5, 15, 30];
            sizes.forEach((size, i) => {
                const r = sizeScale(size);
                legend.append('circle').attr('cx', 30).attr('cy', 30 + i * 35).attr('r', r).attr('fill', 'var(--accent-primary)').attr('opacity', 0.7).attr('stroke', 'var(--text-primary)').attr('stroke-width', 1);
                legend.append('text').attr('x', 55).attr('y', 35 + i * 35).style('fill', 'var(--text-secondary)').style('font-size', '11px').text(`${size}%`);
            });
            legend.append('text').attr('x', 0).attr('y', 140).style('fill', 'var(--text-secondary)').style('font-size', '10px').text('Expected');
            legend.append('text').attr('x', 0).attr('y', 152).style('fill', 'var(--text-secondary)').style('font-size', '10px').text('Return %');
        }
        
        let allStrategies = [];
        let allStrategySignals = [];
        let currentSort = { column: null, direction: 'asc' };
        
        function initTableSort() {
            const headers = document.querySelectorAll('#strategyTable th.sortable');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const sortKey = header.dataset.sort;
                    if (currentSort.column === sortKey) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = sortKey;
                        currentSort.direction = 'desc';
                    }
                    sortTable(sortKey, currentSort.direction);
                    updateSortIndicators(header);
                });
            });
        }
        
        function sortTable(key, direction) {
            const tbody = document.querySelector('#strategyTable tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                const indexA = parseInt(a.dataset.index);
                const indexB = parseInt(b.dataset.index);
                const stratA = allStrategies[indexA];
                const stratB = allStrategies[indexB];
                
                let valA, valB;
                switch(key) {
                    case 'expectancy': valA = stratA.stats.expectancy; valB = stratB.stats.expectancy; break;
                    case 'profitFactor': {
                        const feeR = parseFloat(document.getElementById('brokerFee').value);
                        const resultsA = allStrategySignals[indexA].map(s => calculateTradeResult(s, stratA.beStrategy, stratA.rTarget, feeR));
                        const resultsB = allStrategySignals[indexB].map(s => calculateTradeResult(s, stratB.beStrategy, stratB.rTarget, feeR));
                        const winA = resultsA.filter(r => r > 0).reduce((a,b) => a + b, 0);
                        const lossA = Math.abs(resultsA.filter(r => r < 0).reduce((a,b) => a + b, 0));
                        const winB = resultsB.filter(r => r > 0).reduce((a,b) => a + b, 0);
                        const lossB = Math.abs(resultsB.filter(r => r < 0).reduce((a,b) => a + b, 0));
                        valA = lossA > 0 ? (winA / lossA) : (winA > 0 ? 999 : 0);
                        valB = lossB > 0 ? (winB / lossB) : (winB > 0 ? 999 : 0);
                        break;
                    }
                    case 'avgTrade': valA = stratA.stats.avgTrade; valB = stratB.stats.avgTrade; break;
                    case 'winRate': valA = stratA.stats.winRate; valB = stratB.stats.winRate; break;
                    case 'breakevenRate': valA = stratA.stats.breakevenRate; valB = stratB.stats.breakevenRate; break;
                    case 'trades': valA = stratA.stats.total; valB = stratB.stats.total; break;
                    case 'expectedR': valA = stratA.stats.expectedTotalReturn; valB = stratB.stats.expectedTotalReturn; break;
                    case 'expectedPercent': valA = stratA.expectedReturnPercent; valB = stratB.expectedReturnPercent; break;
                    case 'maxDD': valA = stratA.maxDrawdownPercent; valB = stratB.maxDrawdownPercent; break;
                }
                
                return direction === 'asc' ? valA - valB : valB - valA;
            });
            
            rows.forEach(row => tbody.appendChild(row));
        }
        
        function updateSortIndicators(activeHeader) {
            document.querySelectorAll('#strategyTable th.sortable').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });
            activeHeader.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
        }
        
        let currentModalStrategyIndex = 0;
        
        function showStrategyDetails(index) {
            currentModalStrategyIndex = index;
            const strategy = allStrategies[index];
            const signals = allStrategySignals[index];
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; overflow-y: auto; padding: 40px;';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            
            const content = document.createElement('div');
            content.style.cssText = 'max-width: 1400px; margin: 0 auto; background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); border-radius: 20px; padding: 40px; position: relative;';
            
            const sessionsText = strategy.sessions.join(' + ');
            const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[strategy.timeFilter];
            const beText = strategy.beStrategy === 'none' ? 'No BE' : 'BE=1R';
            
            // Calculate actual trading hours for this strategy
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            let timeFilterExplanation = '';
            let hourDetails = '';
            
            if (strategy.timeFilter === 'none') {
                timeFilterExplanation = '‚è∞ <strong>All Times:</strong> Trading all signals within session hours (no time filtering)';
            } else if (strategy.timeFilter === 'optimal' || strategy.timeFilter === 'both') {
                // Calculate optimal hours for each session
                const optimalHours = {};
                strategy.sessions.forEach(session => {
                    const sessionSignals = signals.filter(s => s.session === session);
                    const hourlyPerf = {};
                    sessionSignals.forEach(s => {
                        if (!s.time) return;
                        const hour = parseInt(s.time.split(':')[0]);
                        if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                        hourlyPerf[hour].push(s);
                    });
                    const hourlyStats = Object.entries(hourlyPerf)
                        .map(([hour, sigs]) => {
                            if (sigs.length < 3) return null;
                            const results = sigs.map(s => calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
                            const stats = calculateStats(results);
                            return { hour: parseInt(hour), expectancy: stats.expectancy, trades: sigs.length };
                        })
                        .filter(h => h !== null)
                        .sort((a, b) => b.expectancy - a.expectancy);
                    if (hourlyStats.length > 0) {
                        optimalHours[session] = hourlyStats[0];
                    }
                });
                
                if (strategy.timeFilter === 'optimal') {
                    timeFilterExplanation = '‚è∞ <strong>Optimal Hour Only:</strong> Trading only during the best-performing hour for each session';
                    hourDetails = '<div style="margin-top: 0.5rem; padding-left: 1.5rem;">';
                    Object.entries(optimalHours).forEach(([session, data]) => {
                        hourDetails += `<div style="color: var(--text-secondary); font-size: 0.875rem;">‚Ä¢ <strong>${session}:</strong> ${data.hour}:00-${data.hour}:59 (${data.trades} trades, ${data.expectancy.toFixed(3)}R expectancy)</div>`;
                    });
                    hourDetails += '</div>';
                } else {
                    timeFilterExplanation = '‚è∞ <strong>Optimal + Macro:</strong> Full optimal hour plus 15 minutes on each side (90 min continuous window)';
                    hourDetails = '<div style="margin-top: 0.5rem; padding-left: 1.5rem;">';
                    Object.entries(optimalHours).forEach(([session, data]) => {
                        const prevHour = (data.hour - 1 + 24) % 24;
                        const nextHour = (data.hour + 1) % 24;
                        hourDetails += `<div style="color: var(--text-secondary); font-size: 0.875rem;">‚Ä¢ <strong>${session}:</strong> ${prevHour}:45-${nextHour}:15 (${data.trades} trades, ${data.expectancy.toFixed(3)}R expectancy)</div>`;
                    });
                    hourDetails += '</div>';
                }
            } else if (strategy.timeFilter === 'macro') {
                timeFilterExplanation = '‚è∞ <strong>Macro Times:</strong> Trading only during :45-:15 minute windows (e.g., 9:45-10:15)';
                hourDetails = '<div style="margin-top: 0.5rem; padding-left: 1.5rem; color: var(--text-secondary); font-size: 0.875rem;">Trades signals that occur at minutes :45-:59 or :00-:15 of any hour</div>';
            }
            
            content.innerHTML = `
                <button onclick="this.closest('div[style*=fixed]').remove()" style="position: absolute; top: 20px; right: 20px; background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.3); padding: var(--spacing-sm) var(--spacing-md); border-radius: var(--radius-sm); color: #ef4444; cursor: pointer; font-weight: 600;">‚úï Close</button>
                <h2 style="color: var(--accent-primary); margin-bottom: var(--spacing-md); font-size: 1.5rem; font-weight: 700;">${sessionsText} | ${timeFilterText} | ${beText} | ${strategy.rTarget}R</h2>
                
                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.15)); border: 2px solid rgba(16, 185, 129, 0.4); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-bottom: var(--spacing-lg);">
                    <h3 style="color: #10b981; margin: 0 0 var(--spacing-md) 0; font-size: 1.1rem; font-weight: 700;">üìÖ YOUR TRADING WINDOWS</h3>
                    <div style="color: var(--text-primary); font-size: 0.95rem; line-height: 1.6;">${timeFilterExplanation}${hourDetails}</div>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: var(--spacing-md); margin-bottom: var(--spacing-xl);">
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Expectancy</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: var(--accent-secondary); margin-top: var(--spacing-xs);">${strategy.stats.expectancy.toFixed(3)}R</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Win Rate</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: var(--accent-secondary); margin-top: var(--spacing-xs);">${strategy.stats.winRate.toFixed(1)}%</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Expected Return</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: var(--accent-secondary); margin-top: var(--spacing-xs);">${strategy.expectedReturnPercent > 0 ? '+' : ''}${strategy.expectedReturnPercent.toFixed(2)}%</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Max DD</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: #ef4444; margin-top: var(--spacing-xs);">${strategy.maxDrawdownPercent.toFixed(1)}%</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Trades</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: var(--accent-primary); margin-top: var(--spacing-xs);">${strategy.stats.total}</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); text-align: center; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Smoothness</div>
                        <div style="font-size: 1.75rem; font-weight: 700; color: ${strategy.smoothness && strategy.smoothness.smoothnessScore >= 75 ? '#00ff88' : strategy.smoothness && strategy.smoothness.smoothnessScore >= 60 ? '#f59e0b' : '#ef4444'}; margin-top: var(--spacing-xs);">${strategy.smoothness ? strategy.smoothness.smoothnessScore : 'N/A'}</div>
                    </div>
                </div>
                ${strategy.smoothness ? `<div style="background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: var(--radius-md); padding: var(--spacing-lg); margin-bottom: var(--spacing-lg);">
                    <h3 style="color: var(--accent-primary); margin: 0 0 var(--spacing-md) 0; font-size: 1.1rem; font-weight: 700;">üìä Equity Curve Quality (Scalping-Focused)</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
                        <div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">R-Squared (Linearity)</div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary);">${strategy.smoothness.rSquared}</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary);">0.95+ = very smooth</div>
                        </div>
                        <div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Recovery Factor</div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary);">${strategy.smoothness.recoveryFactor}</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary);">Total R / Max DD</div>
                        </div>
                        <div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Max Consecutive Losses</div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary);">${strategy.smoothness.maxConsecutiveLosses}</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary);">Lower = better psychology</div>
                        </div>
                        <div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">Max Drawdown Duration</div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary);">${strategy.smoothness.maxDrawdownDuration} trades</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary);">Shorter = faster recovery</div>
                        </div>
                    </div>
                    <div style="margin-top: var(--spacing-md); padding: var(--spacing-md); background: rgba(59, 130, 246, 0.05); border-radius: var(--radius-sm);">
                        <div style="font-size: 0.875rem; color: var(--text-secondary); line-height: 1.6;">
                            <strong style="color: var(--accent-primary);">Smoothness Score Breakdown:</strong><br>
                            ‚Ä¢ 90-100: Exceptionally smooth (institutional quality)<br>
                            ‚Ä¢ 75-89: Very smooth (prop firm ready)<br>
                            ‚Ä¢ 60-74: Acceptable (tradeable but bumpy)<br>
                            ‚Ä¢ Below 60: Rough ride (psychological challenge)
                        </div>
                    </div>
                </div>` : ''}
                <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-lg); border-bottom: 2px solid var(--border-color);">
                    <button class="modal-tab active" data-tab="propeval" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">üéØ Prop Firm Eval</button>
                    <button class="modal-tab" data-tab="equity" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">üìà Equity</button>
                    <button class="modal-tab" data-tab="calendar" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">üìÖ Calendar</button>
                    <button class="modal-tab" data-tab="trades" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">üìã Trades</button>
                    <button class="modal-tab" data-tab="risk" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">‚ö†Ô∏è Risk</button>
                    <button class="modal-tab" data-tab="performance" style="padding: var(--spacing-md) var(--spacing-lg); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent;">üìä Performance</button>
                </div>
                <div class="tab-content" data-content="propeval" style="display: block;">
                    <div id="modalPropEval" style="width: 100%;"></div>
                </div>
                <div class="tab-content" data-content="equity" style="display: none;">
                    <div id="modalEquity" style="width: 100%; height: 450px; background: var(--bg-tertiary); border-radius: var(--radius-md); border: 1px solid var(--border-color); overflow: hidden;"></div>
                </div>
                <div class="tab-content" data-content="calendar" style="display: none;">
                    <div id="modalCalendar" style="width: 100%;"></div>
                </div>
                <div class="tab-content" data-content="trades" style="display: none;">
                    <div id="modalTrades" style="max-height: 600px; overflow-y: auto;"></div>
                </div>
                <div class="tab-content" data-content="risk" style="display: none;">
                    <div id="modalRisk" style="width: 100%;"></div>
                </div>
                <div class="tab-content" data-content="performance" style="display: none;">
                    <div id="modalPerformance" style="width: 100%;"></div>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const tabs = modal.querySelectorAll('.modal-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => { t.classList.remove('active'); t.style.color = 'var(--text-secondary)'; t.style.borderBottom = '2px solid transparent'; });
                    tab.classList.add('active');
                    tab.style.color = 'var(--accent-primary)';
                    tab.style.borderBottom = '2px solid var(--accent-primary)';
                    modal.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
                    modal.querySelector(`[data-content="${tab.dataset.tab}"]`).style.display = 'block';
                    
                    // Re-render equity chart when tab is clicked (D3 needs visible container)
                    if (tab.dataset.tab === 'equity') {
                        setTimeout(() => renderModalEquity(signals, strategy), 50);
                    }
                });
            });
            tabs[0].style.color = 'var(--accent-primary)';
            tabs[0].style.borderBottom = '2px solid var(--accent-primary)';
            
            renderModalPropEval(signals, strategy);
            renderModalEquity(signals, strategy);
            renderModalCalendar(signals, strategy);
            renderModalTrades(signals, strategy);
            renderModalRisk(signals, strategy);
            renderModalPerformance(signals, strategy);
        }
        
        function renderModalPropEval(signals, strategy) {
            const container = document.getElementById('modalPropEval');
            const selectedFirm = document.getElementById('modalPropFirmSelect')?.value || document.getElementById('propFirmSelect')?.value || 'myfundedfutures';
            const firm = propFirmRules[selectedFirm];
            
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const results = signals.map(s => calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
            
            // Calculate evaluation metrics
            const passesRules = (firm.maxDailyLoss === 0 || strategy.maxDailyLossPercent <= firm.maxDailyLoss) && 
                               strategy.maxDrawdownPercent <= firm.maxDrawdown && 
                               strategy.stats.winRate >= firm.minWinRate;
            
            // Estimate days to pass evaluation (assuming 10 trading days minimum)
            const avgTradesPerDay = strategy.stats.total / 60; // Assuming 60 trading days in dataset
            const daysToMinTrades = firm.minTrades ? Math.ceil(firm.minTrades / avgTradesPerDay) : 10;
            const estimatedDays = Math.max(daysToMinTrades, 10);
            
            // Calculate expected profit during eval
            const expectedTradesDuringEval = avgTradesPerDay * estimatedDays;
            const expectedProfitR = strategy.stats.expectancy * expectedTradesDuringEval;
            const expectedProfitPercent = expectedProfitR * strategy.riskPerTrade;
            
            // Risk analysis
            const worstStreak = strategy.stats.maxConsecLosses;
            const worstStreakLoss = worstStreak * strategy.riskPerTrade;
            const safetyMargin = firm.maxDailyLoss - strategy.maxDailyLossPercent;
            
            // Generate firm selector options
            const firmOptions = Object.entries(propFirmRules).map(([key, f]) => 
                `<option value="${key}" ${key === selectedFirm ? 'selected' : ''}>${f.name}</option>`
            ).join('');
            
            let html = `
                <div style="display: grid; gap: var(--spacing-lg);">
                    <!-- Firm Selector -->
                    <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--spacing-md);">
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 600;">Select Prop Firm:</label>
                        <select id="modalPropFirmSelect" onchange="renderModalPropEval(allStrategySignals[currentModalStrategyIndex], allStrategies[currentModalStrategyIndex])" style="width: 100%; padding: var(--spacing-sm); background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-sm); color: var(--text-primary); font-size: 1rem;">
                            ${firmOptions}
                        </select>
                    </div>
                    <!-- Evaluation Status -->
                    <div style="background: ${passesRules ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)'}; border: 2px solid ${passesRules ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)'}; border-radius: var(--radius-md); padding: var(--spacing-lg);">
                        <div style="display: flex; align-items: center; gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                            <div style="font-size: 3rem;">${passesRules ? '‚úÖ' : '‚ùå'}</div>
                            <div>
                                <h3 style="margin: 0; color: ${passesRules ? 'var(--accent-secondary)' : '#ef4444'}; font-size: 1.25rem;">${passesRules ? 'EVALUATION READY' : 'NEEDS OPTIMIZATION'}</h3>
                                <p style="margin: 0.25rem 0 0 0; color: var(--text-secondary);">For ${firm.name} (${firm.maxAccount ? '$' + firm.maxAccount.toLocaleString() + ' max' : 'Unlimited'})</p>
                            </div>
                        </div>
                        ${!passesRules ? `
                            <div style="background: rgba(239, 68, 68, 0.1); padding: var(--spacing-md); border-radius: var(--radius-sm); margin-top: var(--spacing-md);">
                                <strong style="color: #ef4444;">‚ö†Ô∏è Rule Violations:</strong>
                                <ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem; color: var(--text-secondary);">
                                    ${(firm.maxDailyLoss > 0 && strategy.maxDailyLossPercent > firm.maxDailyLoss) ? `<li>Max Daily Loss: ${strategy.maxDailyLossPercent.toFixed(1)}% exceeds ${firm.maxDailyLoss}% limit</li>` : ''}
                                    ${strategy.maxDrawdownPercent > firm.maxDrawdown ? `<li>Max Drawdown: ${strategy.maxDrawdownPercent.toFixed(1)}% exceeds ${firm.maxDrawdown}% limit</li>` : ''}
                                    ${strategy.stats.winRate < firm.minWinRate ? `<li>Win Rate: ${strategy.stats.winRate.toFixed(1)}% below ${firm.minWinRate}% minimum</li>` : ''}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    
                    <!-- Evaluation Timeline -->
                    <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--spacing-lg);">
                        <h4 style="margin: 0 0 var(--spacing-md) 0; color: var(--accent-primary);">üìÖ Estimated Evaluation Timeline</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
                            <div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Estimated Days</div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary); margin-top: 0.25rem;">${estimatedDays} days</div>
                            </div>
                            <div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Expected Trades</div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary); margin-top: 0.25rem;">${Math.round(expectedTradesDuringEval)} trades</div>
                            </div>
                            <div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Expected Profit</div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary); margin-top: 0.25rem;">+${expectedProfitPercent.toFixed(2)}%</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Risk Management Insights -->
                    <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--spacing-lg);">
                        <h4 style="margin: 0 0 var(--spacing-md) 0; color: var(--accent-primary);">‚ö†Ô∏è Risk Management Insights</h4>
                        <div style="display: grid; gap: var(--spacing-md);">
                            <div style="background: ${(firm.maxDailyLoss > 0 && worstStreakLoss > firm.maxDailyLoss) ? 'rgba(239, 68, 68, 0.1)' : 'rgba(16, 185, 129, 0.1)'}; padding: var(--spacing-md); border-radius: var(--radius-sm);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Worst Losing Streak</div>
                                <div style="color: var(--text-secondary);">${worstStreak} consecutive losses = ${worstStreakLoss.toFixed(2)}% loss</div>
                                ${firm.maxDailyLoss === 0 ? 
                                    `<div style="color: var(--accent-secondary); margin-top: 0.5rem;">‚úÖ No daily loss limit - unlimited risk tolerance</div>` :
                                    (worstStreakLoss > firm.maxDailyLoss ? 
                                        `<div style="color: #ef4444; margin-top: 0.5rem;">‚ö†Ô∏è This exceeds daily loss limit! Consider reducing risk per trade to ${(firm.maxDailyLoss / worstStreak).toFixed(2)}%</div>` :
                                        `<div style="color: var(--accent-secondary); margin-top: 0.5rem;">‚úÖ Within daily loss limits</div>`)
                                }
                            </div>
                            <div style="background: ${safetyMargin < 1 ? 'rgba(239, 68, 68, 0.1)' : 'rgba(16, 185, 129, 0.1)'}; padding: var(--spacing-md); border-radius: var(--radius-sm);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Safety Margin</div>
                                <div style="color: var(--text-secondary);">${safetyMargin.toFixed(2)}% buffer before hitting daily loss limit</div>
                                ${safetyMargin < 1 ? 
                                    `<div style="color: #ef4444; margin-top: 0.5rem;">‚ö†Ô∏è Very tight margin! One bad day could breach limits</div>` :
                                    safetyMargin < 2 ?
                                    `<div style="color: #f59e0b; margin-top: 0.5rem;">‚ö†Ô∏è Moderate margin. Trade carefully on losing days</div>` :
                                    `<div style="color: var(--accent-secondary); margin-top: 0.5rem;">‚úÖ Comfortable safety buffer</div>`
                                }
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actionable Recommendations -->
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: var(--radius-md); padding: var(--spacing-lg);">
                        <h4 style="margin: 0 0 var(--spacing-md) 0; color: var(--accent-primary);">üí° Recommendations for Success</h4>
                        <ul style="margin: 0; padding-left: 1.5rem; color: var(--text-primary); line-height: 1.8;">
                            ${strategy.stats.winRate < 50 ? 
                                `<li><strong>Improve Win Rate:</strong> Current ${strategy.stats.winRate.toFixed(1)}% is below 50%. Focus on better entry timing or tighter filters</li>` : 
                                `<li><strong>Win Rate Strength:</strong> ${strategy.stats.winRate.toFixed(1)}% win rate is solid. Maintain discipline</li>`
                            }
                            ${strategy.riskPerTrade > 1 ? 
                                `<li><strong>Reduce Position Size:</strong> ${strategy.riskPerTrade}% risk per trade is aggressive. Consider 0.5-1% for evaluation safety</li>` :
                                `<li><strong>Position Sizing:</strong> ${strategy.riskPerTrade}% risk per trade is conservative and appropriate for evaluations</li>`
                            }
                            ${avgTradesPerDay < 2 ? 
                                `<li><strong>Increase Trade Frequency:</strong> Only ${avgTradesPerDay.toFixed(1)} trades/day. May take ${estimatedDays}+ days to complete evaluation</li>` :
                                avgTradesPerDay > 10 ?
                                `<li><strong>High Frequency:</strong> ${avgTradesPerDay.toFixed(1)} trades/day. Ensure quality over quantity to avoid overtrading</li>` :
                                `<li><strong>Trade Frequency:</strong> ${avgTradesPerDay.toFixed(1)} trades/day is reasonable for steady evaluation progress</li>`
                            }
                            ${strategy.stats.expectancy < 0.2 ? 
                                `<li><strong>Improve Edge:</strong> ${strategy.stats.expectancy.toFixed(3)}R expectancy is low. Refine strategy or wait for better setups</li>` :
                                `<li><strong>Strong Edge:</strong> ${strategy.stats.expectancy.toFixed(3)}R expectancy provides good profit potential</li>`
                            }
                            <li><strong>Consistency is Key:</strong> Stick to your rules. Most evaluation failures come from discipline breaks, not strategy flaws</li>
                            <li><strong>Track Daily P&L:</strong> Monitor daily performance closely. If approaching ${(firm.maxDailyLoss * 0.7).toFixed(1)}% loss, stop trading for the day</li>
                        </ul>
                    </div>
                    
                    <!-- Firm-Specific Notes -->
                    ${firm.description ? `
                        <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--spacing-lg);">
                            <h4 style="margin: 0 0 var(--spacing-md) 0; color: var(--accent-primary);">üìã ${firm.name} Details</h4>
                            <p style="margin: 0; color: var(--text-secondary); line-height: 1.6;">${firm.description}</p>
                            ${firm.website ? `<p style="margin: 0.5rem 0 0 0;"><a href="https://${firm.website}" target="_blank" style="color: var(--accent-secondary);">Visit ${firm.website} ‚Üí</a></p>` : ''}
                        </div>
                    ` : ''}
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function renderModalEquity(signals, strategy) {
            const container = document.getElementById('modalEquity');
            
            // Clear previous chart
            d3.select(container).selectAll('*').remove();
            
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const results = signals.map(s => calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
            let cumulative = 0;
            const equityData = results.map((r, i) => ({ index: i + 1, equity: cumulative += r }));
            
            const width = container.offsetWidth;
            const height = 400;
            const margin = {top: 20, right: 30, bottom: 40, left: 60};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            const svg = d3.select(container).append('svg')
                .attr('width', '100%')
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');
            const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleLinear().domain([0, equityData.length]).range([0, innerWidth]);
            const yScale = d3.scaleLinear().domain([d3.min(equityData, d => d.equity) - 2, d3.max(equityData, d => d.equity) + 2]).range([innerHeight, 0]);
            
            const line = d3.line().x(d => xScale(d.index)).y(d => yScale(d.equity)).curve(d3.curveMonotoneX);
            const area = d3.area().x(d => xScale(d.index)).y0(innerHeight).y1(d => yScale(d.equity)).curve(d3.curveMonotoneX);
            
            const gradient = svg.append('defs').append('linearGradient').attr('id', 'modalGradient').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
            gradient.append('stop').attr('offset', '0%').attr('stop-color', '#00ff88').attr('stop-opacity', 0.8);
            gradient.append('stop').attr('offset', '100%').attr('stop-color', '#00ff88').attr('stop-opacity', 0.1);
            
            g.append('path').datum(equityData).attr('fill', 'url(#modalGradient)').attr('d', area).style('opacity', 0.3);
            g.append('path').datum(equityData).attr('fill', 'none').attr('stroke', '#00ff88').attr('stroke-width', 3).attr('d', line);
            g.append('g').attr('transform', `translate(0,${innerHeight})`).call(d3.axisBottom(xScale).ticks(10)).style('color', '#fff');
            g.append('g').call(d3.axisLeft(yScale).tickFormat(d => d + 'R')).style('color', '#fff');
        }
        
        function renderModalCalendar(signals, strategy) {
            const container = document.getElementById('modalCalendar');
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const dailyResults = {};
            
            signals.forEach(s => {
                if (!dailyResults[s.date]) dailyResults[s.date] = [];
                dailyResults[s.date].push(calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
            });
            
            const dailyTotals = {};
            Object.entries(dailyResults).forEach(([date, results]) => {
                dailyTotals[date] = { total: results.reduce((sum, r) => sum + r, 0), count: results.length };
            });
            
            const dates = Object.keys(dailyTotals).sort();
            if (dates.length === 0) return;
            
            const startDate = new Date(dates[0]);
            const endDate = new Date(dates[dates.length - 1]);
            const startMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
            const endMonth = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
            
            let html = '';
            let currentDate = new Date(startMonth);
            
            while (currentDate <= endMonth) {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const monthName = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });
                
                html += `<div style="margin-bottom: 30px;"><h4 style="color: #00ff88; margin-bottom: 15px;">${monthName}</h4>`;
                html += '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; margin-bottom: 10px;">';
                ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(day => {
                    html += `<div style="text-align: center; font-weight: 600; font-size: 12px; color: rgba(255,255,255,0.6);">${day}</div>`;
                });
                html += '</div><div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px;">';
                
                const firstDay = new Date(year, month, 1).getDay();
                for (let i = 0; i < firstDay; i++) html += '<div></div>';
                
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const dayData = dailyTotals[dateStr];
                    const dayOfWeek = new Date(year, month, day).getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    
                    if (dayData) {
                        const intensity = Math.min(Math.abs(dayData.total) / 5, 1);
                        const bgColor = dayData.total > 0 ? `rgba(0, 255, 136, ${0.3 + intensity * 0.7})` : `rgba(255, 71, 87, ${0.3 + intensity * 0.7})`;
                        html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 10px; text-align: center; border: 2px solid rgba(255,255,255,0.1);">`;
                        html += `<div style="font-size: 11px; opacity: 0.8; margin-bottom: 4px;">${day}</div>`;
                        html += `<div style="font-weight: 700; font-size: 16px; margin-bottom: 2px;">${dayData.total > 0 ? '+' : ''}${dayData.total.toFixed(1)}R</div>`;
                        html += `<div style="font-size: 10px; opacity: 0.7;">${dayData.count} trades</div></div>`;
                    } else {
                        const bgColor = isWeekend ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.05)';
                        html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.05);">`;
                        html += `<div style="font-size: 11px; opacity: 0.4;">${day}</div></div>`;
                    }
                }
                
                html += '</div></div>';
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            
            container.innerHTML = html;
        }
        
        function renderModalTrades(signals, strategy) {
            const container = document.getElementById('modalTrades');
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const tradesWithResults = signals.map(s => ({ ...s, result: calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR) }));
            
            let html = '<table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: rgba(0,255,136,0.1);">';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">Date</th>';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">Time</th>';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">Session</th>';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">MFE</th>';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">Result</th>';
            html += '<th style="padding: 12px; text-align: left; color: #00ff88;">Status</th></tr></thead><tbody>';
            
            tradesWithResults.forEach(trade => {
                const mfe = strategy.beStrategy === 'be1' ? trade.mfe1 : trade.mfeNone;
                const statusColor = trade.result > 0 ? '#00ff88' : (trade.result === 0 ? '#ffa502' : '#ff4757');
                const statusText = trade.result > 0 ? 'WIN' : (trade.result === 0 ? 'BE' : 'LOSS');
                html += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05);">`;
                html += `<td style="padding: 12px;">${trade.date}</td>`;
                html += `<td style="padding: 12px;">${trade.time || 'N/A'}</td>`;
                html += `<td style="padding: 12px;">${trade.session}</td>`;
                html += `<td style="padding: 12px;">${mfe.toFixed(2)}R</td>`;
                html += `<td style="padding: 12px; color: ${statusColor}; font-weight: 700;">${trade.result > 0 ? '+' : ''}${trade.result.toFixed(2)}R</td>`;
                html += `<td style="padding: 12px; color: ${statusColor}; font-weight: 600;">${statusText}</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        function renderModalRisk(signals, strategy) {
            const container = document.getElementById('modalRisk');
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const results = signals.map(s => calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
            
            // Calculate strategy statistics
            const wins = results.filter(r => r > 0).length;
            const total = results.length;
            const winRate = total > 0 ? wins / total : 0;
            
            // Create enhanced risk analysis HTML with proper layout
            let html = `
                <div class="risk-analysis-container" style="display: flex; flex-direction: column; gap: 16px; padding: 16px; max-height: 70vh; overflow-y: auto;">
                    <!-- Consecutive Loss Probability Heatmap -->
                    <div class="probability-heatmap-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üî• Consecutive Loss Probability Matrix
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">Mathematical Certainty</span>
                            </h4>
                        </div>
                        <div class="heatmap-container" style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; border: 1px solid var(--border-color); position: relative; z-index: 1;">
                            <div id="lossHeatmap" style="width: 100%; position: relative; z-index: 1;"></div>
                            <div class="strategy-indicator" style="margin-top: 8px; padding: 6px; background: rgba(0,255,136,0.1); border-radius: 4px; border: 1px solid rgba(0,255,136,0.3);">
                                <div style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <div style="width: 6px; height: 6px; background: #00ff88; border-radius: 50%; box-shadow: 0 0 4px rgba(0,255,136,0.5);"></div>
                                    <span style="font-weight: 600;">Your Strategy: ${(winRate * 100).toFixed(1)}% Win Rate</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Risk Scenario Analysis -->
                    <div class="risk-scenarios-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üé≤ Risk Scenario Analysis
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">What to Expect</span>
                            </h4>
                        </div>
                        <div class="scenario-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px;">
                            <div id="conservativeScenario" class="scenario-card"></div>
                            <div id="realisticScenario" class="scenario-card"></div>
                            <div id="stressScenario" class="scenario-card"></div>
                        </div>
                    </div>

                    <!-- Psychological Preparation Dashboard -->
                    <div class="psychological-prep-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üß† Psychological Preparation
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">Mental Readiness</span>
                            </h4>
                        </div>
                        <div id="psychologicalGauge" style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; border: 1px solid var(--border-color);">
                            <div class="readiness-indicators" id="readinessIndicators"></div>
                        </div>
                    </div>

                    <!-- Position Sizing Intelligence -->
                    <div class="position-sizing-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üí∞ Intelligent Position Sizing
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">Optimal Risk Management</span>
                            </h4>
                        </div>
                        <div class="sizing-container" style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; border: 1px solid var(--border-color);">
                            <div class="sizing-calculator" id="positionSizingCalculator"></div>
                        </div>
                    </div>

                    <!-- Monte Carlo Simulation -->
                    <div class="monte-carlo-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üé≤ Monte Carlo Simulation
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">1,000 Possible Futures</span>
                            </h4>
                        </div>
                        <div class="monte-carlo-container" style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; border: 1px solid var(--border-color);">
                            
                            <!-- Options Panel -->
                            <div style="background: rgba(59, 130, 246, 0.05); border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid rgba(59, 130, 246, 0.2);">
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                                    <div>
                                        <label style="font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; display: block;">Simulations</label>
                                        <select id="mcNumSims" style="width: 100%; padding: 5px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                                            <option value="100">100</option>
                                            <option value="500">500</option>
                                            <option value="1000" selected>1,000</option>
                                            <option value="5000">5,000</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label style="font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; display: block;">Trades</label>
                                        <select id="mcNumTrades" style="width: 100%; padding: 5px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                                            <option value="actual">Actual</option>
                                            <option value="100">100</option>
                                            <option value="250" selected>250</option>
                                            <option value="500">500</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label style="font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; display: block;">Capital ($)</label>
                                        <input type="number" id="mcCapital" value="100000" min="1000" step="1000" style="width: 100%; padding: 5px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                                    </div>
                                    <div>
                                        <label style="font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; display: block;">Risk (%)</label>
                                        <input type="number" id="mcRisk" value="1" min="0.1" max="5" step="0.1" style="width: 100%; padding: 5px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px;">
                                    </div>
                                    <div>
                                        <label style="font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; display: block;">Display</label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; padding-top: 2px;">
                                            <input type="checkbox" id="mcShowBands" checked style="accent-color: var(--accent-primary);">
                                            <span style="font-size: 10px; color: var(--text-primary);">Percentiles</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <button id="runMonteCarloBtn" class="btn-primary" style="padding: 10px 20px; font-size: 13px; display: flex; align-items: center; gap: 6px;">
                                    <span>üöÄ</span>
                                    <span>Run Simulation</span>
                                </button>
                                <div id="simulationProgress" style="flex: 1; height: 6px; background: var(--bg-primary); border-radius: 3px; overflow: hidden; display: none;">
                                    <div id="progressBar" style="height: 100%; background: linear-gradient(90deg, #00ff88, #00d4aa); width: 0%; transition: width 0.1s;"></div>
                                </div>
                                <div id="progressText" style="font-size: 11px; color: var(--text-secondary); display: none;">Ready</div>
                            </div>
                            <div id="monteCarloResults" style="display: none;">
                                <div style="background: var(--bg-primary); border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--border-color);">
                                    <div id="mcEquityCurveChart" style="width: 100%; height: 350px;"></div>
                                </div>
                                <div id="mcStatistics"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Risk Metrics -->
                    <div class="enhanced-metrics-section" style="position: relative; z-index: 1;">
                        <div class="section-header" style="margin-bottom: 12px;">
                            <h4 style="color: var(--accent-primary); margin: 0; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                                üìä Advanced Risk Metrics
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: normal;">Scalping Analysis</span>
                            </h4>
                        </div>
                        <div id="enhancedMetrics" style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; border: 1px solid var(--border-color);"></div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Initialize all visualizations
            setTimeout(() => {
                createConsecutiveLossHeatmap(strategy, winRate);
                createRiskScenarios(strategy, winRate, results);
                createPsychologicalPrep(strategy, winRate);
                createPositionSizingCalculator(strategy, winRate);
                setupMonteCarloSimulation(strategy, winRate, results);
                createEnhancedMetrics(strategy, results);
            }, 100);
        }

        // ===== VISUAL RISK ANALYSIS FUNCTIONS =====
        
        function createConsecutiveLossHeatmap(strategy, winRate) {
            const container = document.getElementById('lossHeatmap');
            if (!container) return;
            
            // Dynamic win rates - automatically include the current strategy's win rate
            let baseWinRates = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95];
            
            // Add the current strategy's win rate if it's not already in the array
            if (!baseWinRates.some(wr => Math.abs(wr - winRate) < 0.01)) {
                baseWinRates.push(winRate);
                baseWinRates.sort((a, b) => a - b);
            }
            
            const winRates = baseWinRates;
            const lossStreaks = [2, 3, 4, 5, 6, 7, 8];
            
            let html = `
                <div style="overflow-x: auto; border-radius: 8px; border: 1px solid var(--border-color); max-width: 100%;">
                    <table style="width: 100%; border-collapse: separate; border-spacing: 1px; font-size: 11px; background: var(--bg-primary);">
                        <thead>
                            <tr style="background: var(--bg-secondary);">
                                <th style="padding: 6px 4px; text-align: center; color: var(--text-secondary); font-weight: 600; font-size: 10px; min-width: 45px;">WIN%</th>
                                ${lossStreaks.map(streak => `<th style="padding: 6px 4px; text-align: center; color: var(--text-secondary); font-weight: 600; font-size: 10px; min-width: 50px;">${streak}L</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            winRates.forEach((wr) => {
                const isStrategyRow = Math.abs(wr - winRate) < 0.01;
                
                html += `<tr>`;
                
                // Win rate column
                html += `<td style="
                    padding: 6px 4px; 
                    text-align: center; 
                    font-weight: 600; 
                    font-size: 11px;
                    color: ${isStrategyRow ? '#00ff88' : 'var(--text-primary)'}; 
                    background: ${isStrategyRow ? 'rgba(0,255,136,0.15)' : 'var(--bg-secondary)'}; 
                    ${isStrategyRow ? 'border: 1px solid #00ff88;' : ''}
                ">${(wr * 100).toFixed(0)}%</td>`;
                
                lossStreaks.forEach((streak) => {
                    const probability = Math.pow(1 - wr, streak);
                    const expectedFreq = Math.round(1 / probability);
                    
                    // Simplified color coding
                    let bgColor, textColor;
                    if (probability < 0.02) {
                        bgColor = '#10b981'; // Green
                        textColor = '#ffffff';
                    } else if (probability < 0.10) {
                        bgColor = '#f59e0b'; // Yellow
                        textColor = '#ffffff';
                    } else if (probability < 0.25) {
                        bgColor = '#f97316'; // Orange
                        textColor = '#ffffff';
                    } else {
                        bgColor = '#ef4444'; // Red
                        textColor = '#ffffff';
                    }
                    
                    const cellStyle = isStrategyRow ? 
                        `border: 1px solid #00ff88; box-shadow: 0 0 8px rgba(0,255,136,0.3);` : 
                        '';
                    
                    html += `
                        <td class="heatmap-cell" 
                            style="
                                padding: 6px 4px; 
                                text-align: center; 
                                background: ${bgColor}; 
                                color: ${textColor}; 
                                cursor: pointer; 
                                font-weight: 600; 
                                font-size: 11px;
                                transition: all 0.2s ease;
                                ${cellStyle}
                            "
                            onmouseover="showHeatmapTooltip(event, ${(probability * 100).toFixed(2)}, ${expectedFreq}, ${streak}, '${wr}')"
                            onmouseout="hideHeatmapTooltip()">
                            ${(probability * 100).toFixed(1)}%
                        </td>
                    `;
                });
                
                html += '</tr>';
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                <div id="heatmapTooltip" style="
                    position: fixed; 
                    background: rgba(0,0,0,0.95); 
                    color: white; 
                    padding: 10px; 
                    border-radius: 6px; 
                    font-size: 11px; 
                    pointer-events: none; 
                    opacity: 0; 
                    transition: opacity 0.2s; 
                    z-index: 10000; 
                    border: 1px solid rgba(255,255,255,0.2);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.6);
                    max-width: 180px;
                    backdrop-filter: blur(5px);
                "></div>
            `;
            
            container.innerHTML = html;
        }
        
        function showHeatmapTooltip(event, probability, frequency, streak, winRate) {
            const tooltip = document.getElementById('heatmapTooltip');
            if (!tooltip) return;
            
            const riskLevel = probability < 2 ? 'Low' : 
                             probability < 10 ? 'Moderate' : 'High';
            
            const riskColor = probability < 2 ? '#10b981' : 
                             probability < 10 ? '#f59e0b' : '#ef4444';
            
            tooltip.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px; color: #ffffff;">${streak} Consecutive Losses</div>
                <div style="display: grid; gap: 4px; font-size: 11px;">
                    <div>Win Rate: <span style="color: #00ff88;">${(parseFloat(winRate) * 100).toFixed(0)}%</span></div>
                    <div>Probability: <span style="color: ${riskColor}; font-weight: 600;">${probability}%</span></div>
                    <div>Every: <span style="color: #3b82f6;">${frequency} trades</span></div>
                    <div style="margin-top: 4px; color: ${riskColor}; font-weight: 600;">${riskLevel} Risk</div>
                </div>
            `;
            
            tooltip.style.opacity = '1';
            
            // Better positioning to avoid overlaps
            const tooltipWidth = 180;
            const tooltipHeight = 100;
            let left = event.clientX + 15;
            let top = event.clientY - 10;
            
            // Adjust if tooltip would go off screen
            if (left + tooltipWidth > window.innerWidth) {
                left = event.clientX - tooltipWidth - 15;
            }
            if (top + tooltipHeight > window.innerHeight) {
                top = event.clientY - tooltipHeight - 10;
            }
            if (left < 0) left = 10;
            if (top < 0) top = 10;
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        function selectHeatmapCell(winRate, streak) {
            // Optional: Add click functionality for cell selection
            console.log(`Selected: ${(winRate * 100).toFixed(0)}% win rate, ${streak} consecutive losses`);
        }
        
        function hideHeatmapTooltip() {
            const tooltip = document.getElementById('heatmapTooltip');
            if (tooltip) tooltip.style.opacity = '0';
        }
        
        function createRiskScenarios(strategy, winRate, results) {
            const scenarios = [
                {
                    id: 'conservativeScenario',
                    title: 'Conservative (90%)',
                    icon: 'üõ°Ô∏è',
                    confidence: 0.90,
                    color: 'rgba(16, 185, 129, 0.2)',
                    borderColor: '#10b981'
                },
                {
                    id: 'realisticScenario', 
                    title: 'Realistic (70%)',
                    icon: 'üìä',
                    confidence: 0.70,
                    color: 'rgba(59, 130, 246, 0.2)',
                    borderColor: '#3b82f6'
                },
                {
                    id: 'stressScenario',
                    title: 'Stress Test (99%)',
                    icon: 'üî•',
                    confidence: 0.99,
                    color: 'rgba(239, 68, 68, 0.2)',
                    borderColor: '#ef4444'
                }
            ];
            
            scenarios.forEach(scenario => {
                const container = document.getElementById(scenario.id);
                if (!container) return;
                
                // Calculate scenario metrics
                const maxConsecLosses = calculateMaxConsecLosses(winRate, scenario.confidence);
                const maxDrawdown = maxConsecLosses * 1; // Assuming 1R loss per trade
                const recoveryTrades = Math.ceil(maxDrawdown / (strategy.stats?.expectancy || 0.1));
                
                container.innerHTML = `
                    <div style="background: ${scenario.color}; border: 1px solid ${scenario.borderColor}; border-radius: var(--radius-sm); padding: var(--spacing-md); height: 100%;">
                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: var(--spacing-sm);">
                            <span style="font-size: 18px;">${scenario.icon}</span>
                            <div>
                                <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">${scenario.title}</div>
                                <div style="font-size: 10px; color: var(--text-secondary);">${(scenario.confidence * 100)}% Confidence</div>
                            </div>
                        </div>
                        
                        <div style="display: grid; gap: var(--spacing-sm);">
                            <div class="scenario-metric">
                                <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Max Consecutive Losses</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${scenario.borderColor};">${maxConsecLosses}</div>
                            </div>
                            
                            <div class="scenario-metric">
                                <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Max Drawdown</div>
                                <div style="font-size: 16px; font-weight: 700; color: var(--text-primary);">-${maxDrawdown.toFixed(1)}R</div>
                            </div>
                            
                            <div class="scenario-metric">
                                <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Recovery Time</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${recoveryTrades} trades</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: var(--spacing-sm); padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 10px; color: var(--text-secondary);">
                            ${scenario.confidence === 0.90 ? 'Most likely scenario' :
                              scenario.confidence === 0.70 ? 'Expected outcome' :
                              'Worst case scenario'}
                        </div>
                    </div>
                `;
            });
        }
        
        function calculateMaxConsecLosses(winRate, confidence) {
            // Calculate maximum consecutive losses for given confidence level
            // Using geometric distribution
            const lossRate = 1 - winRate;
            let streak = 1;
            
            while (Math.pow(lossRate, streak) > (1 - confidence)) {
                streak++;
            }
            
            return Math.max(2, streak - 1);
        }
        
        function createPsychologicalPrep(strategy, winRate) {
            const container = document.getElementById('readinessIndicators');
            if (!container) return;
            
            // Calculate key psychological thresholds
            const prob3Losses = Math.pow(1 - winRate, 3);
            const prob5Losses = Math.pow(1 - winRate, 5);
            const prob7Losses = Math.pow(1 - winRate, 7);
            
            const freq3 = Math.round(1 / prob3Losses);
            const freq5 = Math.round(1 / prob5Losses);
            const freq7 = Math.round(1 / prob7Losses);
            
            const indicators = [
                {
                    level: 'normal',
                    icon: 'üò§',
                    color: '#10b981',
                    title: '3 Consecutive Losses',
                    probability: prob3Losses,
                    frequency: freq3,
                    advice: 'Normal part of trading - stay disciplined'
                },
                {
                    level: 'caution',
                    icon: 'üò∞', 
                    color: '#f59e0b',
                    title: '5 Consecutive Losses',
                    probability: prob5Losses,
                    frequency: freq5,
                    advice: 'Reduce position size if this occurs'
                },
                {
                    level: 'danger',
                    icon: 'üö®',
                    color: '#ef4444',
                    title: '7+ Consecutive Losses',
                    probability: prob7Losses,
                    frequency: freq7,
                    advice: 'Stop trading and review strategy'
                }
            ];
            
            let html = '<div style="display: grid; gap: var(--spacing-md);">';
            
            indicators.forEach(indicator => {
                html += `
                    <div style="display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(${indicator.color === '#10b981' ? '16, 185, 129' : indicator.color === '#f59e0b' ? '245, 158, 11' : '239, 68, 68'}, 0.1); border-radius: 4px; border-left: 3px solid ${indicator.color};">
                        <div style="font-size: 20px;">${indicator.icon}</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 2px; font-size: 12px;">${indicator.title}</div>
                            <div style="font-size: 11px; color: ${indicator.color}; font-weight: 600; margin-bottom: 2px;">
                                ${(indicator.probability * 100).toFixed(1)}% ‚Ä¢ Every ${indicator.frequency} trades
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">${indicator.advice}</div>
                        </div>
                        <div style="text-align: center; padding: 4px;">
                            <div style="font-size: 14px; font-weight: 700; color: ${indicator.color};">${indicator.frequency}</div>
                            <div style="font-size: 8px; color: var(--text-secondary);">trades</div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function createPositionSizingCalculator(strategy, winRate) {
            const container = document.getElementById('positionSizingCalculator');
            if (!container) return;
            
            // Calculate Kelly Criterion
            const avgWin = strategy.stats?.avgWin || 2.0;
            const avgLoss = Math.abs(strategy.stats?.avgLoss || 1.0);
            const kellyPercent = ((avgWin * winRate) - (avgLoss * (1 - winRate))) / avgWin;
            const kellyOptimal = Math.max(0.1, Math.min(5.0, kellyPercent * 100));
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-lg);">
                    <!-- Position Sizing Methods -->
                    <div>
                        <h5 style="color: var(--text-primary); margin-bottom: var(--spacing-md);">Recommended Position Sizes</h5>
                        <div style="display: grid; gap: var(--spacing-md);">
                            <div style="padding: var(--spacing-md); background: rgba(59, 130, 246, 0.1); border-radius: var(--radius-sm); border: 1px solid rgba(59, 130, 246, 0.3);">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 20px;">üéØ</span>
                                    <span style="font-weight: 600; color: var(--text-primary);">Kelly Criterion</span>
                                </div>
                                <div style="font-size: 24px; font-weight: 700; color: #3b82f6; margin-bottom: 4px;">${kellyOptimal.toFixed(1)}%</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Mathematically optimal growth rate</div>
                            </div>
                            
                            <div style="padding: var(--spacing-md); background: rgba(16, 185, 129, 0.1); border-radius: var(--radius-sm); border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 20px;">üõ°Ô∏è</span>
                                    <span style="font-weight: 600; color: var(--text-primary);">Conservative</span>
                                </div>
                                <div style="font-size: 24px; font-weight: 700; color: #10b981; margin-bottom: 4px;">${(kellyOptimal * 0.5).toFixed(1)}%</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Safe approach for steady growth</div>
                            </div>
                            
                            <div style="padding: var(--spacing-md); background: rgba(245, 158, 11, 0.1); border-radius: var(--radius-sm); border: 1px solid rgba(245, 158, 11, 0.3);">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 20px;">üöÄ</span>
                                    <span style="font-weight: 600; color: var(--text-primary);">Aggressive</span>
                                </div>
                                <div style="font-size: 24px; font-weight: 700; color: #f59e0b; margin-bottom: 4px;">${(kellyOptimal * 1.5).toFixed(1)}%</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Higher risk, faster growth potential</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Interactive Calculator -->
                    <div>
                        <h5 style="color: var(--text-primary); margin-bottom: var(--spacing-md);">Position Size Calculator</h5>
                        <div style="display: grid; gap: var(--spacing-md);">
                            <div>
                                <label style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px; display: block;">Account Size ($)</label>
                                <input type="number" id="calcAccountSize" value="100000" min="1000" max="10000000" step="1000" 
                                       style="width: 100%; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);"
                                       onchange="updatePositionCalculation()">
                            </div>
                            
                            <div>
                                <label style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px; display: block;">Risk per Trade (%)</label>
                                <input type="range" id="calcRiskPercent" min="0.1" max="5" step="0.1" value="${kellyOptimal.toFixed(1)}" 
                                       style="width: 100%;" onchange="updatePositionCalculation()">
                                <div style="text-align: center; font-size: 14px; color: var(--accent-primary); font-weight: 600;" id="riskPercentDisplay">${kellyOptimal.toFixed(1)}%</div>
                            </div>
                            
                            <div style="padding: var(--spacing-md); background: var(--bg-primary); border-radius: var(--radius-sm); border: 1px solid var(--border-color);">
                                <div style="display: grid; gap: 8px;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: var(--text-secondary);">Position Size:</span>
                                        <span style="font-weight: 600; color: var(--text-primary);" id="calcPositionSize">$${(100000 * kellyOptimal / 100).toFixed(0)}</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: var(--text-secondary);">Max Loss (5 consecutive):</span>
                                        <span style="font-weight: 600; color: #ef4444;" id="calcMaxLoss">-$${(100000 * kellyOptimal / 100 * 5).toFixed(0)}</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: var(--text-secondary);">Account Impact:</span>
                                        <span style="font-weight: 600; color: #ef4444;" id="calcAccountImpact">-${(kellyOptimal * 5).toFixed(1)}%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add the update function to global scope
            window.updatePositionCalculation = function() {
                const accountSize = parseFloat(document.getElementById('calcAccountSize').value) || 100000;
                const riskPercent = parseFloat(document.getElementById('calcRiskPercent').value) || 1;
                
                document.getElementById('riskPercentDisplay').textContent = riskPercent.toFixed(1) + '%';
                
                const positionSize = accountSize * riskPercent / 100;
                const maxLoss = positionSize * 5;
                const accountImpact = (maxLoss / accountSize) * 100;
                
                document.getElementById('calcPositionSize').textContent = '$' + positionSize.toFixed(0);
                document.getElementById('calcMaxLoss').textContent = '-$' + maxLoss.toFixed(0);
                document.getElementById('calcAccountImpact').textContent = '-' + accountImpact.toFixed(1) + '%';
            };
        }
        
        function createEnhancedMetrics(strategy, results) {
            const container = document.getElementById('enhancedMetrics');
            if (!container) return;
            
            // Calculate scalping-appropriate metrics
            const wins = results.filter(r => r > 0);
            const losses = results.filter(r => r < 0);
            const breakevens = results.filter(r => r === 0);
            const avgWin = wins.length > 0 ? wins.reduce((a, b) => a + b, 0) / wins.length : 0;
            const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((a, b) => a + b, 0) / losses.length) : 1;
            const profitFactor = losses.length > 0 ? (wins.reduce((a, b) => a + b, 0) / Math.abs(losses.reduce((a, b) => a + b, 0))) : 0;
            
            const avgReturn = results.reduce((a, b) => a + b, 0) / results.length;
            const winRate = (wins.length / results.length) * 100;
            
            // Calculate consecutive streaks
            let maxWinStreak = 0, maxLossStreak = 0, currentWinStreak = 0, currentLossStreak = 0;
            results.forEach(r => {
                if (r > 0) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
                } else if (r < 0) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }
            });
            
            // Calculate recovery factor (total return / max drawdown)
            let runningTotal = 0, peak = 0, maxDD = 0;
            results.forEach(r => {
                runningTotal += r;
                if (runningTotal > peak) peak = runningTotal;
                const dd = peak - runningTotal;
                if (dd > maxDD) maxDD = dd;
            });
            const recoveryFactor = maxDD > 0 ? runningTotal / maxDD : 0;
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: var(--spacing-sm);">
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Profit Factor</div>
                        <div style="font-size: 18px; font-weight: 700; color: ${profitFactor > 1.5 ? '#10b981' : profitFactor > 1.2 ? '#f59e0b' : '#ef4444'};">${profitFactor.toFixed(2)}</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">${profitFactor > 1.5 ? 'Excellent' : profitFactor > 1.2 ? 'Good' : profitFactor > 1 ? 'Marginal' : 'Poor'}</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Win Rate</div>
                        <div style="font-size: 18px; font-weight: 700; color: ${winRate > 60 ? '#10b981' : winRate > 45 ? '#f59e0b' : '#ef4444'};">${winRate.toFixed(1)}%</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">${wins.length}W/${losses.length}L</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Risk:Reward</div>
                        <div style="font-size: 18px; font-weight: 700; color: var(--accent-primary);">1:${(avgWin / avgLoss).toFixed(1)}</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">${avgWin.toFixed(2)}R avg</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Max Loss Streak</div>
                        <div style="font-size: 18px; font-weight: 700; color: #ef4444;">${maxLossStreak}</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">Historical</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Max Win Streak</div>
                        <div style="font-size: 18px; font-weight: 700; color: #10b981;">${maxWinStreak}</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">Best Run</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Expectancy</div>
                        <div style="font-size: 18px; font-weight: 700; color: ${avgReturn > 0.1 ? '#10b981' : avgReturn > 0 ? '#f59e0b' : '#ef4444'};">${avgReturn.toFixed(3)}R</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">Per Trade</div>
                    </div>
                    
                    <div class="metric-card" style="padding: var(--spacing-sm); background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">Recovery Factor</div>
                        <div style="font-size: 18px; font-weight: 700; color: ${recoveryFactor > 3 ? '#10b981' : recoveryFactor > 1.5 ? '#f59e0b' : '#ef4444'};">${recoveryFactor.toFixed(1)}</div>
                        <div style="font-size: 8px; color: var(--text-secondary);">Return/MaxDD</div>
                    </div>
                </div>
                
                <div style="margin-top: var(--spacing-lg); padding: var(--spacing-md); background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: var(--radius-sm);">
                    <h5 style="color: #3b82f6; margin: 0 0 var(--spacing-sm) 0;">üìä Scalping Strategy Assessment</h5>
                    <div style="font-size: 14px; color: var(--text-primary); line-height: 1.5;">
                        ${profitFactor > 1.5 && avgReturn > 0.1 ? 
                            '‚úÖ <strong>Excellent Scalping Strategy:</strong> High profit factor and positive expectancy. Suitable for aggressive position sizing.' :
                          profitFactor > 1.2 && avgReturn > 0.05 ?
                            '‚úÖ <strong>Good Scalping Strategy:</strong> Solid performance metrics. Suitable for moderate position sizing.' :
                          profitFactor > 1 && avgReturn > 0 ?
                            '‚ö†Ô∏è <strong>Marginal Strategy:</strong> Barely profitable. Use conservative position sizing and monitor closely.' :
                            '‚ùå <strong>Poor Strategy:</strong> Negative expectancy. Not suitable for scalping operations.'}
                    </div>
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        <strong>Key Insight:</strong> ${maxLossStreak > 7 ? 
                            `High loss streak risk (${maxLossStreak}) - requires strong mental discipline` :
                            maxLossStreak > 4 ?
                            `Moderate loss streak risk (${maxLossStreak}) - manageable with proper position sizing` :
                            `Low loss streak risk (${maxLossStreak}) - psychologically easier to trade`}
                    </div>
                </div>
            `;
        }
        
        function setupMonteCarloSimulation(strategy, winRate, results) {
            const runBtn = document.getElementById('runMonteCarloBtn');
            if (!runBtn) return;
            
            // Set default risk from strategy
            const riskInput = document.getElementById('mcRisk');
            if (riskInput && strategy.riskPerTrade) {
                riskInput.value = strategy.riskPerTrade;
            }
            
            // Reset results when parameters change
            const resetMonteCarloResults = () => {
                const resultsContainer = document.getElementById('monteCarloResults');
                if (resultsContainer) {
                    resultsContainer.style.display = 'none';
                }
            };
            
            // Attach change listeners to all parameter controls
            const paramControls = [
                'mcNumSims',
                'mcNumTrades',
                'mcCapital',
                'mcRisk',
                'mcShowBands'
            ];
            
            paramControls.forEach(controlId => {
                const control = document.getElementById(controlId);
                if (control) {
                    control.addEventListener('change', resetMonteCarloResults);
                    control.addEventListener('input', resetMonteCarloResults);
                }
            });
            
            runBtn.addEventListener('click', () => {
                runMonteCarloAnalysis(strategy, winRate, results);
            });
        }
        
        function runMonteCarloAnalysis(strategy, winRate, results) {
            const runBtn = document.getElementById('runMonteCarloBtn');
            const progressContainer = document.getElementById('simulationProgress');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const resultsContainer = document.getElementById('monteCarloResults');
            
            // Show progress elements
            runBtn.disabled = true;
            runBtn.innerHTML = '<span>‚è≥</span><span>Running...</span>';
            progressContainer.style.display = 'block';
            progressText.style.display = 'block';
            resultsContainer.style.display = 'none';
            
            // Calculate strategy parameters
            const wins = results.filter(r => r > 0);
            const losses = results.filter(r => r < 0);
            const avgWin = wins.length > 0 ? wins.reduce((a, b) => a + b, 0) / wins.length : 2.0;
            const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((a, b) => a + b, 0) / losses.length) : 1.0;
            
            // Read options from UI
            const numSimulations = parseInt(document.getElementById('mcNumSims').value) || 1000;
            const numTradesOption = document.getElementById('mcNumTrades').value;
            const numTrades = numTradesOption === 'actual' ? results.length : parseInt(numTradesOption);
            const startingCapital = parseFloat(document.getElementById('mcCapital').value) || 100000;
            const riskPercent = parseFloat(document.getElementById('mcRisk').value) / 100 || 0.01;
            const showBands = document.getElementById('mcShowBands').checked;
            
            const simulationResults = [];
            
            let completed = 0;
            
            // Run simulations in batches to avoid blocking UI
            function runBatch() {
                const batchSize = 50;
                const endIndex = Math.min(completed + batchSize, numSimulations);
                
                for (let sim = completed; sim < endIndex; sim++) {
                    const result = runSingleSimulation(winRate, avgWin, avgLoss, numTrades, startingCapital, riskPercent, results);
                    simulationResults.push(result);
                }
                
                completed = endIndex;
                const progress = (completed / numSimulations) * 100;
                
                progressBar.style.width = progress + '%';
                progressText.textContent = `${completed}/${numSimulations} simulations complete`;
                
                if (completed < numSimulations) {
                    setTimeout(runBatch, 10); // Small delay to keep UI responsive
                } else {
                    // Simulation complete
                    displayMonteCarloResults(simulationResults, {showBands, startingCapital});
                    
                    // Reset UI
                    runBtn.disabled = false;
                    runBtn.innerHTML = '<span>üöÄ</span><span>Run Simulation</span>';
                    progressContainer.style.display = 'none';
                    progressText.style.display = 'none';
                    resultsContainer.style.display = 'block';
                }
            }
            
            // Start simulation
            setTimeout(runBatch, 100);
        }
        
        function runSingleSimulation(winRate, avgWin, avgLoss, numTrades, startingCapital, riskPercent, actualResults) {
            let equity = startingCapital || 100000;
            const equityCurve = [equity];
            let peak = equity;
            let maxDrawdown = 0;
            let consecutiveLosses = 0;
            let maxConsecutiveLosses = 0;
            
            for (let trade = 0; trade < numTrades; trade++) {
                let result;
                if (actualResults && actualResults.length > 0) {
                    result = actualResults[Math.floor(Math.random() * actualResults.length)];
                } else {
                    const isWin = Math.random() < winRate;
                    result = isWin ? avgWin : -avgLoss;
                }
                
                const positionSize = equity * (riskPercent || 0.01);
                const dollarResult = positionSize * result;
                equity += dollarResult;
                equityCurve.push(equity);
                
                if (equity > peak) {
                    peak = equity;
                    consecutiveLosses = 0;
                } else {
                    if (result < 0) {
                        consecutiveLosses++;
                        maxConsecutiveLosses = Math.max(maxConsecutiveLosses, consecutiveLosses);
                    }
                }
                
                const drawdown = ((peak - equity) / peak) * 100;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
            }
            
            return {
                finalEquity: equity,
                equityCurve: equityCurve,
                maxDrawdown: maxDrawdown,
                maxConsecutiveLosses: maxConsecutiveLosses,
                startingCapital: startingCapital || 100000
            };
        }
        
        function displayMonteCarloResults(results, options) {
            const resultsContainer = document.getElementById('monteCarloResults');
            const statsContainer = document.getElementById('mcStatistics');
            resultsContainer.style.display = 'block';
            
            // Calculate statistics
            const finalEquities = results.map(r => r.finalEquity).sort((a, b) => a - b);
            const maxDrawdowns = results.map(r => r.maxDrawdown).sort((a, b) => a - b);
            const profitable = results.filter(r => r.finalEquity > r.startingCapital).length;
            const profitablePercent = (profitable / results.length) * 100;
            
            // Render D3 equity curve
            renderEquityCurveD3(results, options);
            
            // Display enhanced statistics
            statsContainer.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
                    <div style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; border: 1px solid var(--border-color);">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Final Equity</div>
                        <div style="display: grid; gap: 4px; font-size: 11px;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Best (95%):</span>
                                <span style="color: #00ff88; font-weight: 600;">$${d3.quantile(finalEquities, 0.95).toFixed(0)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Median:</span>
                                <span style="color: var(--text-primary); font-weight: 600;">$${d3.quantile(finalEquities, 0.50).toFixed(0)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Worst (5%):</span>
                                <span style="color: #ef4444; font-weight: 600;">$${d3.quantile(finalEquities, 0.05).toFixed(0)}</span>
                            </div>
                        </div>
                    </div>
                    <div style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; border: 1px solid var(--border-color);">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Max Drawdown</div>
                        <div style="display: grid; gap: 4px; font-size: 11px;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Best (5%):</span>
                                <span style="color: #00ff88; font-weight: 600;">-${d3.quantile(maxDrawdowns, 0.05).toFixed(1)}%</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Median:</span>
                                <span style="color: var(--text-primary); font-weight: 600;">-${d3.quantile(maxDrawdowns, 0.50).toFixed(1)}%</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: var(--text-secondary);">Worst (95%):</span>
                                <span style="color: #ef4444; font-weight: 600;">-${d3.quantile(maxDrawdowns, 0.95).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                    <div style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; border: 1px solid var(--border-color);">
                        <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Success Rate</div>
                        <div style="text-align: center;">
                            <div style="font-size: 36px; font-weight: 700; color: ${profitablePercent >= 75 ? '#00ff88' : profitablePercent >= 50 ? '#f59e0b' : '#ef4444'};">
                                ${profitablePercent.toFixed(0)}%
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                ${profitable} of ${results.length} profitable
                            </div>
                        </div>
                    </div>
                </div>
                <div style="padding: 12px; background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px; font-size: 11px;">
                    <strong style="color: var(--accent-primary);">Monte Carlo Insight:</strong>
                    <span style="color: var(--text-primary);">
                        ${profitablePercent >= 80 ? `Excellent strategy - ${profitablePercent.toFixed(0)}% of simulations were profitable` :
                          profitablePercent >= 60 ? `Good strategy - ${profitablePercent.toFixed(0)}% success rate with manageable risk` :
                          profitablePercent >= 40 ? `Moderate strategy - ${profitablePercent.toFixed(0)}% success rate, consider risk management` :
                          `High risk strategy - only ${profitablePercent.toFixed(0)}% of simulations were profitable`}
                    </span>
                </div>
            `;
        }
        
        function renderEquityCurveD3(results, options) {
            const container = d3.select('#mcEquityCurveChart');
            container.selectAll('*').remove();
            
            const margin = {top: 20, right: 30, bottom: 40, left: 60};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Calculate percentiles
            const numTrades = results[0].equityCurve.length;
            const percentileData = [];
            for (let i = 0; i < numTrades; i++) {
                const values = results.map(r => r.equityCurve[i]).sort((a, b) => a - b);
                percentileData.push({
                    trade: i,
                    p5: d3.quantile(values, 0.05),
                    p25: d3.quantile(values, 0.25),
                    p50: d3.quantile(values, 0.50),
                    p75: d3.quantile(values, 0.75),
                    p95: d3.quantile(values, 0.95)
                });
            }
            
            // Scales
            const xScale = d3.scaleLinear().domain([0, numTrades - 1]).range([0, width]);
            const allValues = results.flatMap(r => r.equityCurve);
            const yScale = d3.scaleLinear()
                .domain([d3.min(allValues) * 0.95, d3.max(allValues) * 1.05])
                .range([height, 0]);
            
            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .style('color', '#94a3b8');
            
            svg.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d => '$' + (d/1000).toFixed(0) + 'K'))
                .style('color', '#94a3b8');
            
            // Percentile bands
            if (options.showBands) {
                const area95 = d3.area()
                    .x(d => xScale(d.trade))
                    .y0(d => yScale(d.p5))
                    .y1(d => yScale(d.p95))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(percentileData)
                    .attr('fill', '#3b82f6')
                    .attr('fill-opacity', 0.1)
                    .attr('d', area95);
                
                const area75 = d3.area()
                    .x(d => xScale(d.trade))
                    .y0(d => yScale(d.p25))
                    .y1(d => yScale(d.p75))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(percentileData)
                    .attr('fill', '#3b82f6')
                    .attr('fill-opacity', 0.2)
                    .attr('d', area75);
            }
            
            // Median line
            const medianLine = d3.line()
                .x(d => xScale(d.trade))
                .y(d => yScale(d.p50))
                .curve(d3.curveMonotoneX);
            
            svg.append('path')
                .datum(percentileData)
                .attr('fill', 'none')
                .attr('stroke', '#00ff88')
                .attr('stroke-width', 2)
                .attr('d', medianLine);
            
            // Starting capital line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', yScale(options.startingCapital))
                .attr('y2', yScale(options.startingCapital))
                .attr('stroke', '#f59e0b')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.5);
            
            // Labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + 35)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .style('font-size', '11px')
                .text('Trade Number');
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .style('font-size', '11px')
                .text('Account Equity ($)');
        }
        
        function calculateMaxConsecLosses(winRate, confidence) {
            // Calculate maximum consecutive losses for given confidence level
            // Using geometric distribution
            const p = 1 - winRate;
            return Math.ceil(Math.log(1 - confidence) / Math.log(p));
        }
        
        function createHistogram(canvasId, data, title, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Calculate histogram bins
            const min = Math.min(...data);
            const max = Math.max(...data);
            const numBins = 20;
            const binSize = (max - min) / numBins;
            const bins = new Array(numBins).fill(0);
            
            data.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binSize), numBins - 1);
                bins[binIndex]++;
            });
            
            const maxBinCount = Math.max(...bins);
            const barWidth = width / numBins;
            
            // Draw bars
            ctx.fillStyle = color;
            bins.forEach((count, i) => {
                const barHeight = (count / maxBinCount) * (height - 20);
                const x = i * barWidth;
                const y = height - barHeight - 10;
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            });
            
            // Draw labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(min.toFixed(1), 10, height - 2);
            ctx.fillText(max.toFixed(1), width - 10, height - 2);
        }
        
        function renderModalPerformance(signals, strategy) {
            const container = document.getElementById('modalPerformance');
            const feeR = parseFloat(document.getElementById('brokerFee').value);
            const results = signals.map(s => calculateTradeResult(s, strategy.beStrategy, strategy.rTarget, feeR));
            
            const chunkSize = Math.ceil(results.length / 5);
            const chunks = [];
            for (let i = 0; i < results.length; i += chunkSize) {
                chunks.push(results.slice(i, i + chunkSize));
            }
            
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const avgWin = winResults.length > 0 ? winResults.reduce((a,b) => a + b, 0) / winResults.length : 0;
            const avgLoss = lossResults.length > 0 ? Math.abs(lossResults.reduce((a,b) => a + b, 0) / lossResults.length) : 1;
            const profitFactor = lossResults.length > 0 ? (winResults.reduce((a,b) => a + b, 0) / Math.abs(lossResults.reduce((a,b) => a + b, 0))) : 0;
            
            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-lg);">';
            html += '<div><h4 style="color: var(--accent-primary); margin-bottom: var(--spacing-md);">Win Rate Trend</h4>';
            html += '<div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); border: 1px solid var(--border-color);">';
            chunks.forEach((chunk, i) => {
                const stats = calculateStats(chunk);
                const barWidth = stats.winRate;
                html += `<div style="margin-bottom: var(--spacing-sm);"><div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.875rem;"><span>Period ${i + 1}</span><span>${stats.winRate.toFixed(1)}%</span></div><div style="background: rgba(16,185,129,0.2); height: 8px; border-radius: 4px;"><div style="background: var(--accent-secondary); height: 100%; width: ${barWidth}%; border-radius: 4px;"></div></div></div>`;
            });
            html += '</div></div>';
            
            html += '<div><h4 style="color: var(--accent-primary); margin-bottom: var(--spacing-md);">Key Metrics</h4>';
            html += '<div style="background: var(--bg-tertiary); padding: var(--spacing-md); border-radius: var(--radius-sm); border: 1px solid var(--border-color);">';
            html += `<div style="padding: var(--spacing-sm); margin-bottom: var(--spacing-sm); background: rgba(16,185,129,0.05); border-radius: var(--radius-sm);"><div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Profit Factor</div><div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary); margin-top: 4px;">${profitFactor.toFixed(2)}</div></div>`;
            html += `<div style="padding: var(--spacing-sm); margin-bottom: var(--spacing-sm); background: rgba(59,130,246,0.05); border-radius: var(--radius-sm);"><div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Avg Win</div><div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-primary); margin-top: 4px;">${avgWin.toFixed(2)}R</div></div>`;
            html += `<div style="padding: var(--spacing-sm); background: rgba(239,68,68,0.05); border-radius: var(--radius-sm);"><div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase;">Avg Loss</div><div style="font-size: 1.5rem; font-weight: 700; color: #ef4444; margin-top: 4px;">${avgLoss.toFixed(2)}R</div></div>`;
            html += '</div></div></div>';
            
            html += `<div style="margin-top: var(--spacing-lg); padding: var(--spacing-md); background: rgba(59,130,246,0.05); border: 1px solid rgba(59,130,246,0.2); border-radius: var(--radius-sm);"><h4 style="color: var(--accent-primary); margin-bottom: var(--spacing-sm);">Performance Summary</h4><div style="font-size: 0.875rem; line-height: 1.8;"><div>Total Trades: <strong>${results.length}</strong></div><div>Wins: <strong style="color: var(--accent-secondary);">${winResults.length}</strong> | Losses: <strong style="color: #ef4444;">${lossResults.length}</strong> | BE: <strong>${results.filter(r => r === 0).length}</strong></div><div>Win/Loss Ratio: <strong>${(avgWin / avgLoss).toFixed(2)}</strong></div></div></div>`;
            
            container.innerHTML = html;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('results').innerHTML = '<div class="results-card" style="text-align: center; padding: 60px; color: var(--text-secondary);">Click "Run Comparison" to analyze strategies</div>';
        });
    </script>
</div><!-- container -->
</body>
</html>
