<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Comparison</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); color: #fff; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; padding: 30px; background: rgba(255,255,255,0.08); border-radius: 20px; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; background: linear-gradient(45deg, #00ff88, #00d4aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .comparison-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .strategy-card { background: rgba(255,255,255,0.08); border-radius: 15px; padding: 25px; border: 2px solid transparent; }
        .strategy-card.winner { border-color: #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3); }
        .metric-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .metric-label { opacity: 0.8; }
        .metric-value { font-weight: 600; color: #00ff88; }
        .btn { background: linear-gradient(45deg, #00ff88, #00d4aa); border: none; padding: 15px 30px; border-radius: 12px; color: white; font-weight: 700; cursor: pointer; margin: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); }
        th { background: rgba(0,255,136,0.1); color: #00ff88; font-weight: 600; }
    </style>
</head>
<body>
    <nav style="background: rgba(255,255,255,0.1); padding: 15px; margin-bottom: 20px; border-radius: 15px; text-align: center;">
        <a href="/strategy-optimizer" style="color: rgba(255,255,255,0.8); text-decoration: none; padding: 10px 18px; background: rgba(255,255,255,0.05); border-radius: 10px; margin: 0 5px;">üéØ Optimizer</a>
        <a href="/strategy-comparison" style="color: #00ff88; text-decoration: none; padding: 10px 18px; background: rgba(0,255,136,0.15); border-radius: 10px; margin: 0 5px;">üèÜ Compare</a>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>üèÜ Strategy Comparison</h1>
            <p>Compare strategies by Expected Total Return</p>
        </div>
        
        <div style="text-align: center; margin-bottom: 30px;">
            <button class="btn" onclick="runComparison()">üîÑ Run Comparison</button>
        </div>
        
        <div id="results"></div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let signals = [];
        
        async function loadSignals() {
            const response = await fetch('https://web-production-cd33.up.railway.app/api/signal-lab-trades?analysis_only=true');
            const data = await response.json();
            const trades = Array.isArray(data) ? data : data.trades || [];
            signals = trades.filter(t => { const d = new Date(t.date); return d.getDay() !== 0 && d.getDay() !== 6; })
                .map(t => ({ date: t.date, time: t.time, session: t.session, mfeNone: parseFloat(t.mfe_none || t.mfe) || 0, mfe1: parseFloat(t.mfe1) || 0 }));
        }
        
        function calculateTradeResult(signal, beStrategy, rTarget, feeR = 0) {
            const mfe = beStrategy === 'be1' ? signal.mfe1 : signal.mfeNone;
            if (!mfe || mfe === 0) return -1 - feeR;
            if (beStrategy === 'none') return mfe < 0 ? (-1 - feeR) : (mfe >= rTarget ? (rTarget - feeR) : (-1 - feeR));
            if (mfe < 1) return -1 - feeR;
            if (mfe >= 1 && mfe < rTarget) return 0 - feeR;
            if (mfe >= rTarget) return rTarget - feeR;
            return -1 - feeR;
        }
        
        function calculateStats(results) {
            const wins = results.filter(r => r > 0).length;
            const losses = results.filter(r => r < 0).length;
            const breakevens = results.filter(r => r === 0).length;
            const total = results.length;
            const winRate = total > 0 ? (wins / total) * 100 : 0;
            const breakevenRate = total > 0 ? (breakevens / total) * 100 : 0;
            const totalR = results.reduce((sum, r) => sum + r, 0);
            const winResults = results.filter(r => r > 0);
            const lossResults = results.filter(r => r < 0);
            const avgTrade = total > 0 ? totalR / total : 0;
            const avgWinR = winResults.length > 0 ? winResults.reduce((a,b) => a + b, 0) / winResults.length : 0;
            const avgLossR = lossResults.length > 0 ? Math.abs(lossResults.reduce((a,b) => a + b, 0) / lossResults.length) : 1;
            const winPercent = total > 0 ? wins / total : 0;
            const lossPercent = total > 0 ? losses / total : 0;
            const expectancy = ((avgWinR * winPercent) - (avgLossR * lossPercent)) / 1.0;
            const expectedTotalReturn = expectancy * total;
            let maxConsecLosses = 0, currentConsecLosses = 0, maxDrawdown = 0, currentDrawdown = 0, peak = 0, runningTotal = 0;
            results.forEach(result => {
                runningTotal += result;
                if (runningTotal > peak) { peak = runningTotal; currentDrawdown = 0; }
                else { currentDrawdown = peak - runningTotal; maxDrawdown = Math.max(maxDrawdown, currentDrawdown); }
                if (result < 0) { currentConsecLosses++; maxConsecLosses = Math.max(maxConsecLosses, currentConsecLosses); }
                else if (result > 0) currentConsecLosses = 0;
            });
            return { expectancy, avgTrade, winRate, breakevenRate, totalR, maxConsecLosses, maxDrawdown, total, expectedTotalReturn };
        }
        
        async function runComparison() {
            if (signals.length === 0) await loadSignals();
            document.getElementById('results').innerHTML = '<div style="text-align: center; padding: 60px;">üîÑ Analyzing strategies...</div>';
            
            const riskLevels = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0];
            const feeR = 0.125;
            const sessions = ['Asia', 'London', 'NY Pre Market', 'NY AM', 'NY Lunch', 'NY PM'];
            const beStrategies = ['none', 'be1'];
            const rTargets = [];
            for (let r = 1; r <= 20; r += 0.5) rTargets.push(r);
            const timeFilters = ['none', 'optimal', 'macro', 'both'];
            
            const totalPossible = 62 * 2 * rTargets.length * riskLevels.length * timeFilters.length;
            const strategies = [];
            
            riskLevels.forEach(riskPerTrade => {
                timeFilters.forEach(timeFilter => {
                    beStrategies.forEach(beStrategy => {
                        rTargets.forEach(rTarget => {
                            const optimalHours = {};
                            if (timeFilter === 'optimal' || timeFilter === 'both') {
                                sessions.forEach(session => {
                                    const sessionSignals = signals.filter(s => s.session === session);
                                    const hourlyPerf = {};
                                    sessionSignals.forEach(s => {
                                        if (!s.time) return;
                                        const hour = parseInt(s.time.split(':')[0]);
                                        if (!hourlyPerf[hour]) hourlyPerf[hour] = [];
                                        hourlyPerf[hour].push(s);
                                    });
                                    const hourlyStats = Object.entries(hourlyPerf)
                                        .map(([hour, sigs]) => {
                                            if (sigs.length < 3) return null;
                                            const results = sigs.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                            const stats = calculateStats(results);
                                            return { hour: parseInt(hour), expectancy: stats.expectancy };
                                        })
                                        .filter(h => h !== null)
                                        .sort((a, b) => b.expectancy - a.expectancy);
                                    if (hourlyStats.length > 0) optimalHours[session] = hourlyStats[0].hour;
                                });
                            }
                            
                            sessions.forEach(session => {
                                let sessionSignals = signals.filter(s => s.session === session);
                                if (timeFilter === 'optimal' && optimalHours[session] !== undefined) {
                                    sessionSignals = sessionSignals.filter(s => s.time && parseInt(s.time.split(':')[0]) === optimalHours[session]);
                                } else if (timeFilter === 'macro') {
                                    sessionSignals = sessionSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (minute >= 45) || (minute <= 15);
                                    });
                                } else if (timeFilter === 'both' && optimalHours[session] !== undefined) {
                                    sessionSignals = sessionSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (hour === optimalHours[session] && minute >= 45) || (hour === (optimalHours[session] + 1) % 24 && minute <= 15);
                                    });
                                }
                                if (sessionSignals.length < 30) return;
                                const results = sessionSignals.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                const stats = calculateStats(results);
                                const expectedReturnPercent = stats.expectedTotalReturn * riskPerTrade;
                                if (stats.expectancy > 0) {
                                    strategies.push({
                                        sessions: [session], beStrategy, rTarget, riskPerTrade, timeFilter, stats, expectedReturnPercent,
                                        maxDailyLossPercent: stats.maxConsecLosses * riskPerTrade,
                                        maxDrawdownPercent: stats.maxDrawdown * riskPerTrade
                                    });
                                }
                            });
                            
                            const n = sessions.length;
                            for (let mask = 2; mask < (1 << n); mask++) {
                                const sessionCombo = [];
                                for (let i = 0; i < n; i++) {
                                    if (mask & (1 << i)) sessionCombo.push(sessions[i]);
                                }
                                if (sessionCombo.length === 1) continue;
                                
                                let combinedSignals = signals.filter(s => sessionCombo.includes(s.session));
                                if (timeFilter === 'optimal') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        const optHour = optimalHours[s.session];
                                        return optHour !== undefined && s.time && parseInt(s.time.split(':')[0]) === optHour;
                                    });
                                } else if (timeFilter === 'macro') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        if (!s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (minute >= 45) || (minute <= 15);
                                    });
                                } else if (timeFilter === 'both') {
                                    combinedSignals = combinedSignals.filter(s => {
                                        const optHour = optimalHours[s.session];
                                        if (optHour === undefined || !s.time) return false;
                                        const [hour, minute] = s.time.split(':').map(Number);
                                        return (hour === optHour && minute >= 45) || (hour === (optHour + 1) % 24 && minute <= 15);
                                    });
                                }
                                if (combinedSignals.length < 50) continue;
                                const results = combinedSignals.map(s => calculateTradeResult(s, beStrategy, rTarget, feeR));
                                const stats = calculateStats(results);
                                const expectedReturnPercent = stats.expectedTotalReturn * riskPerTrade;
                                if (stats.expectancy > 0) {
                                    strategies.push({
                                        sessions: sessionCombo, beStrategy, rTarget, riskPerTrade, timeFilter, stats, expectedReturnPercent,
                                        maxDailyLossPercent: stats.maxConsecLosses * riskPerTrade,
                                        maxDrawdownPercent: stats.maxDrawdown * riskPerTrade
                                    });
                                }
                            }
                        });
                    });
                });
            });
            
            strategies.sort((a, b) => b.expectedReturnPercent - a.expectedReturnPercent);
            
            displayComparison(strategies.slice(0, 20), totalPossible, strategies.length);
        }
        
        function displayComparison(strategies, totalPossible, profitableCount) {
            const beText = { 'none': 'No BE', 'be1': 'BE=1R' };
            
            let html = '<table><thead><tr><th>Rank</th><th>Sessions</th><th>Risk %</th><th>Time Filter</th><th>BE</th><th>R-Target</th><th>Expectancy</th><th>Avg Trade</th><th>Win Rate</th><th>BE Rate</th><th>Trades</th><th>Expected R</th><th>Expected %</th><th>Max DD</th></tr></thead><tbody>';
            
            strategies.forEach((s, i) => {
                const rowClass = i === 0 ? 'style="background: rgba(0,255,136,0.1);"' : '';
                const sessionsText = s.sessions.join('+');
                const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[s.timeFilter];
                html += `<tr ${rowClass}>
                    <td>${i === 0 ? 'üèÜ' : i + 1}</td>
                    <td>${sessionsText}</td>
                    <td>${s.riskPerTrade}%</td>
                    <td>${timeFilterText}</td>
                    <td>${beText[s.beStrategy]}</td>
                    <td>${s.rTarget}R</td>
                    <td>${s.stats.expectancy.toFixed(3)}</td>
                    <td>${s.stats.avgTrade.toFixed(3)}R</td>
                    <td>${s.stats.winRate.toFixed(1)}%</td>
                    <td>${s.stats.breakevenRate.toFixed(1)}%</td>
                    <td>${s.stats.total}</td>
                    <td style="color: #00ff88; font-weight: 700;">${s.stats.expectedTotalReturn > 0 ? '+' : ''}${s.stats.expectedTotalReturn.toFixed(1)}R</td>
                    <td style="color: #00ff88; font-weight: 700;">${s.expectedReturnPercent > 0 ? '+' : ''}${s.expectedReturnPercent.toFixed(2)}%</td>
                    <td>${s.maxDrawdownPercent.toFixed(1)}%</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            
            html += '<div style="margin-top: 30px; padding: 20px; background: rgba(58,123,213,0.1); border-radius: 15px; border: 1px solid rgba(58,123,213,0.3);">';
            html += '<h3 style="color: #3a7bd5; margin-bottom: 15px;">üìä Strategy Universe</h3>';
            html += `<p><strong>Total Possible:</strong> ${totalPossible.toLocaleString()}</p>`;
            html += `<p><strong>Profitable:</strong> ${profitableCount} (${((profitableCount/totalPossible)*100).toFixed(2)}%)</p>`;
            html += '</div>';
            html += '<div style="margin-top: 20px; padding: 20px; background: rgba(0,255,136,0.1); border-radius: 15px; border: 1px solid rgba(0,255,136,0.3);">';
            html += '<h3 style="color: #00ff88; margin-bottom: 15px;">üèÜ Winner Analysis</h3>';
            const winner = strategies[0];
            const winnerSessions = winner.sessions.join(' + ');
            const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[winner.timeFilter];
            html += `<p><strong>Best Strategy:</strong> ${winnerSessions} | ${winner.riskPerTrade}% risk | ${timeFilterText} | ${beText[winner.beStrategy]} | ${winner.rTarget}R</p>`;
            html += `<p><strong>Expected Total Return:</strong> ${winner.stats.expectedTotalReturn.toFixed(1)}R (${winner.expectedReturnPercent.toFixed(2)}%)</p>`;
            html += `<p><strong>Why it wins:</strong> Expectancy (${winner.stats.expectancy.toFixed(3)}R) √ó Trade Count (${winner.stats.total}) √ó Risk (${winner.riskPerTrade}%) = Highest expected account growth</p>`;
            html += '</div>';
            
            html += '<div style="margin-top: 30px; padding: 25px; background: rgba(255,255,255,0.08); border-radius: 20px;">';
            html += '<h3 style="color: #00ff88; margin-bottom: 20px;">üìä Strategy Performance Map</h3>';
            html += '<div id="scatterPlot" style="width: 100%; height: 600px;"></div>';
            html += '</div>';
            
            document.getElementById('results').innerHTML = html;
            
            renderScatterPlot(strategies);
        }
        
        function renderScatterPlot(strategies) {
            const container = d3.select('#scatterPlot');
            container.selectAll('*').remove();
            
            const width = container.node().offsetWidth;
            const height = 600;
            const margin = {top: 40, right: 150, bottom: 60, left: 80};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const sessionColors = {
                'Asia': '#ffa502',
                'London': '#3742fa',
                'NY Pre Market': '#26de81',
                'NY AM': '#00ff88',
                'NY Lunch': '#ffffff',
                'NY PM': '#a55eea'
            };
            
            const xScale = d3.scaleLinear()
                .domain([d3.min(strategies, d => d.stats.expectancy) - 0.05, d3.max(strategies, d => d.stats.expectancy) + 0.05])
                .range([0, innerWidth]);
            
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(strategies, d => d.stats.total) + 50])
                .range([innerHeight, 0]);
            
            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(strategies, d => Math.abs(d.expectedReturnPercent))])
                .range([5, 40]);
            
            g.append('line')
                .attr('x1', xScale(0)).attr('x2', xScale(0))
                .attr('y1', 0).attr('y2', innerHeight)
                .attr('stroke', '#ff4757').attr('stroke-width', 2).attr('stroke-dasharray', '5,5').attr('opacity', 0.5);
            
            g.append('g')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(d3.axisBottom(xScale).tickFormat(d => d.toFixed(2) + 'R'))
                .style('color', '#fff');
            
            g.append('g')
                .call(d3.axisLeft(yScale))
                .style('color', '#fff');
            
            g.append('text')
                .attr('x', innerWidth / 2).attr('y', innerHeight + 50)
                .attr('text-anchor', 'middle').style('fill', '#fff').style('font-size', '14px')
                .text('Expectancy (R Multiplier)');
            
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -innerHeight / 2).attr('y', -60)
                .attr('text-anchor', 'middle').style('fill', '#fff').style('font-size', '14px')
                .text('Trade Count');
            
            const tooltip = d3.select('body').append('div')
                .style('position', 'absolute')
                .style('background', 'linear-gradient(135deg, rgba(0,0,0,0.95), rgba(30,60,114,0.95))')
                .style('color', '#fff').style('padding', '15px').style('border-radius', '12px')
                .style('border', '2px solid #00ff88').style('pointer-events', 'none')
                .style('opacity', 0).style('z-index', '10000')
                .style('backdrop-filter', 'blur(10px)')
                .style('box-shadow', '0 20px 40px rgba(0,0,0,0.5)');
            
            const bubbles = g.selectAll('.bubble')
                .data(strategies)
                .enter().append('g')
                .attr('class', 'bubble')
                .attr('transform', d => `translate(${xScale(d.stats.expectancy)}, ${yScale(d.stats.total)})`);
            
            bubbles.append('circle')
                .attr('r', 0)
                .attr('fill', d => sessionColors[d.sessions[0]] || '#666')
                .attr('opacity', 0.7)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .style('filter', 'url(#glow)')
                .transition().duration(1000).ease(d3.easeElasticOut)
                .attr('r', d => sizeScale(Math.abs(d.expectedReturnPercent)));
            
            bubbles.append('text')
                .attr('text-anchor', 'middle').attr('dy', 4)
                .style('fill', '#000').style('font-size', '10px').style('font-weight', '700')
                .style('pointer-events', 'none')
                .text(d => d.expectedReturnPercent > 5 ? d.expectedReturnPercent.toFixed(0) + '%' : '');
            
            bubbles.on('mouseover', function(event, d) {
                d3.select(this).select('circle')
                    .transition().duration(200)
                    .attr('r', sizeScale(Math.abs(d.expectedReturnPercent)) * 1.3)
                    .attr('opacity', 1);
                
                const beText = d.beStrategy === 'none' ? 'No BE' : 'BE=1R';
                const sessionsText = d.sessions.join(' + ');
                const timeFilterText = {'none': 'None', 'optimal': 'Optimal', 'macro': 'Macro', 'both': 'Both'}[d.timeFilter];
                tooltip.transition().duration(200).style('opacity', 1);
                tooltip.html(`
                    <div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; color: #00ff88;">${sessionsText} | ${d.riskPerTrade}% | ${timeFilterText} | ${beText} | ${d.rTarget}R</div>
                    <div style="margin-bottom: 4px;"><strong>Expectancy:</strong> ${d.stats.expectancy.toFixed(3)}R</div>
                    <div style="margin-bottom: 4px;"><strong>Trade Count:</strong> ${d.stats.total}</div>
                    <div style="margin-bottom: 4px;"><strong>Expected R:</strong> ${d.stats.expectedTotalReturn.toFixed(1)}R</div>
                    <div style="margin-bottom: 4px;"><strong>Expected Return:</strong> <span style="color: #00ff88; font-weight: 700;">${d.expectedReturnPercent.toFixed(2)}%</span></div>
                    <div style="margin-bottom: 4px;"><strong>Win Rate:</strong> ${d.stats.winRate.toFixed(1)}%</div>
                    <div style="margin-bottom: 4px;"><strong>Max DD:</strong> ${d.maxDrawdownPercent.toFixed(1)}%</div>
                `)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this).select('circle')
                    .transition().duration(300)
                    .attr('r', d => sizeScale(Math.abs(d.expectedReturnPercent)))
                    .attr('opacity', 0.7);
                tooltip.transition().duration(200).style('opacity', 0);
            });
            
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 130}, ${margin.top})`);
            
            legend.append('text')
                .attr('x', 0).attr('y', 0)
                .style('fill', '#00ff88').style('font-size', '12px').style('font-weight', '700')
                .text('Sessions');
            
            Object.entries(sessionColors).forEach(([session, color], i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(0, ${20 + i * 25})`);
                
                legendItem.append('circle')
                    .attr('cx', 8).attr('cy', 0).attr('r', 6)
                    .attr('fill', color).attr('opacity', 0.7);
                
                legendItem.append('text')
                    .attr('x', 20).attr('y', 4)
                    .style('fill', '#fff').style('font-size', '11px')
                    .text(session);
            });
            
            legend.append('text')
                .attr('x', 0).attr('y', 180)
                .style('fill', '#00ff88').style('font-size', '12px').style('font-weight', '700')
                .text('Bubble Size');
            
            legend.append('text')
                .attr('x', 0).attr('y', 200)
                .style('fill', '#fff').style('font-size', '10px')
                .text('= Expected Return %');
        }
        
        document.addEventListener('DOMContentLoaded', runComparison);
    </script>
</body>
</html>
