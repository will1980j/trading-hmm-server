//@version=5
indicator("All Patterns Complete with Markov Chain", overlay = true, max_bars_back = 5000, max_labels_count = 500)

// Check timeframe
timeframe_minutes = timeframe.in_seconds() / 60

// Inputs
data_timeframe = input.timeframe("15", "Data Timeframe", group="Data Source", tooltip="Use 15m/1H for frequent signals, 4H/1D for major signals")
show_ebp = input.bool(true, "EBP Sweep", group="Patterns")
show_inside = input.bool(true, "Inside Bar Breakout", group="Patterns")
show_engulf = input.bool(true, "Engulfing", group="Patterns")
show_gap = input.bool(true, "Gap Fill Reversal", group="Patterns")
show_hammer = input.bool(true, "Hammer/Shooting Star", group="Patterns")
show_three = input.bool(true, "Three Bar Pattern", group="Patterns")

bull_label_bg = input.color(color.green, "Bullish Label Background", group="Label Style")
bear_label_bg = input.color(color.red, "Bearish Label Background", group="Label Style")
label_text_color = input.color(color.white, "Label Text Color", group="Label Style")

// Display options
show_candle_coloring = input.bool(true, "Show Candle Coloring", group="Display")
show_success_markers = input.bool(true, "Show Success Markers", group="Display")
show_pattern_labels = input.bool(true, "Show Pattern Labels", group="Display")

// Timeframe Signal Controls
show_15m_signals = input.bool(true, "Show 15m Signals", group="Timeframe Signals")
show_30m_signals = input.bool(true, "Show 30m Signals", group="Timeframe Signals")
show_1h_signals = input.bool(true, "Show 1h Signals", group="Timeframe Signals")
show_2h_signals = input.bool(true, "Show 2h Signals", group="Timeframe Signals")
show_4h_signals = input.bool(true, "Show 4h Signals", group="Timeframe Signals")
show_6h_signals = input.bool(true, "Show 6h Signals", group="Timeframe Signals")
show_8h_signals = input.bool(true, "Show 8h Signals", group="Timeframe Signals")
show_12h_signals = input.bool(true, "Show 12h Signals", group="Timeframe Signals")
show_1d_signals = input.bool(true, "Show 1D Signals", group="Timeframe Signals")
show_higher_signals = input.bool(true, "Show Higher TF Signals", group="Timeframe Signals")

// Table options
show_combinations = input.bool(false, "Show Combinations", group="Table")
table_font_size = input.string("Small", "Table Font Size", options=["Tiny", "Small", "Normal", "Large"], group="Table")
min_success_rate = input.float(0, "Minimum Success Rate %", minval=0, maxval=100, group="Table")
min_occurrences = input.int(1, "Minimum Occurrences", minval=1, group="Table")

// Stats Table Colors
stats_bg_color = input.color(color.white, "Stats Table Background", group="Stats Table Colors")
stats_header_color = input.color(color.gray, "Stats Header Background", group="Stats Table Colors")
stats_text_color = input.color(color.black, "Stats Text Color", group="Stats Table Colors")
stats_bull_color = input.color(color.green, "Stats Bull Text Color", group="Stats Table Colors")
stats_bear_color = input.color(color.red, "Stats Bear Text Color", group="Stats Table Colors")
stats_timeframe_color = input.color(color.yellow, "Stats Timeframe Background", group="Stats Table Colors")

// Opportunity Table Colors
opp_bg_color = input.color(color.new(color.black, 20), "Opportunity Table Background", group="Opportunity Table Colors")
opp_header_color = input.color(color.new(color.blue, 30), "Opportunity Header Background", group="Opportunity Table Colors")
opp_subheader_color = input.color(color.new(color.gray, 50), "Opportunity Subheader Background", group="Opportunity Table Colors")
opp_summary_color = input.color(color.new(color.purple, 50), "Opportunity Summary Background", group="Opportunity Table Colors")
opp_text_color = input.color(color.white, "Opportunity Text Color", group="Opportunity Table Colors")
opp_success_color = input.color(color.lime, "Opportunity Success Color", group="Opportunity Table Colors")
opp_fail_color = input.color(color.orange, "Opportunity Fail Color", group="Opportunity Table Colors")
opp_pending_color = input.color(color.yellow, "Opportunity Pending Color", group="Opportunity Table Colors")
opp_profit_color = input.color(color.lime, "Opportunity Profit Color", group="Opportunity Table Colors")
opp_loss_color = input.color(color.red, "Opportunity Loss Color", group="Opportunity Table Colors")

// Table Text Sizes
stats_text_size = input.string("Small", "Stats Table Text Size", options=["Tiny", "Small", "Normal", "Large"], group="Table Text Sizes")
opp_header_size = input.string("Normal", "Opportunity Header Size", options=["Tiny", "Small", "Normal", "Large"], group="Table Text Sizes")
opp_text_size = input.string("Small", "Opportunity Text Size", options=["Tiny", "Small", "Normal", "Large"], group="Table Text Sizes")

// Markov Chain Enhancement
use_markov_enhancement = input.bool(true, "Use Markov Chain Enhancement", group="Markov Chain")
regime_sensitivity = input.float(1.0, "Regime Detection Sensitivity", minval=0.5, maxval=2.0, group="Markov Chain")
sequence_lookback = input.int(3, "Pattern Sequence Length", minval=2, maxval=5, group="Markov Chain")
show_regime_info = input.bool(true, "Show Regime Information", group="Markov Chain")
show_enhanced_probabilities = input.bool(true, "Show Enhanced Probabilities", group="Markov Chain")
avoid_transition_trades = input.bool(true, "Avoid Transition Regime Trades", group="Markov Chain")

// Pattern functions
isBullishSweep() => low < low[1] and close > open[1] and close > close[1]
isBearishSweep() => high > high[1] and close < open[1] and close < close[1]
isInsideBar() => high[1] < high[2] and low[1] > low[2]
bullishInsideBreak() => isInsideBar()[1] and high > high[2]
bearishInsideBreak() => isInsideBar()[1] and low < low[2]
bullishEngulf() => close > open and open < close[1] and close > open[1] and open[1] > close[1]
bearishEngulf() => close < open and open > close[1] and close < open[1] and open[1] < close[1]
gapUp() => low > high[1]
gapDown() => high < low[1]
bullishGapFill() => gapDown()[1] and high >= low[1] and close > open
bearishGapFill() => gapUp()[1] and low <= high[1] and close < open
bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
isHammer() => lowerWick > bodySize * 2 and upperWick < bodySize
isShootingStar() => upperWick > bodySize * 2 and lowerWick < bodySize
bullishThreeBar() => low[2] > low[1] and low[1] > low and close > close[2]
bearishThreeBar() => high[2] < high[1] and high[1] < high and close < close[2]

// Only show signals when on the selected data timeframe
data_tf_minutes = timeframe.in_seconds(data_timeframe) / 60
show_current_tf_signals = (timeframe_minutes == data_tf_minutes) and 
                         ((timeframe_minutes == 15 and show_15m_signals) or 
                          (timeframe_minutes == 30 and show_30m_signals) or 
                          (timeframe_minutes == 60 and show_1h_signals) or 
                          (timeframe_minutes == 120 and show_2h_signals) or 
                          (timeframe_minutes == 240 and show_4h_signals) or 
                          (timeframe_minutes == 360 and show_6h_signals) or 
                          (timeframe_minutes == 480 and show_8h_signals) or 
                          (timeframe_minutes == 720 and show_12h_signals) or 
                          (timeframe_minutes == 1440 and show_1d_signals) or 
                          (timeframe_minutes > 1440 and show_higher_signals))

// Get pattern data from selected timeframe for tables
ebp_bull_htf = request.security(syminfo.tickerid, data_timeframe, isBullishSweep(), lookahead=barmerge.lookahead_off)
ebp_bear_htf = request.security(syminfo.tickerid, data_timeframe, isBearishSweep(), lookahead=barmerge.lookahead_off)
inside_bull_htf = request.security(syminfo.tickerid, data_timeframe, bullishInsideBreak(), lookahead=barmerge.lookahead_off)
inside_bear_htf = request.security(syminfo.tickerid, data_timeframe, bearishInsideBreak(), lookahead=barmerge.lookahead_off)
engulf_bull_htf = request.security(syminfo.tickerid, data_timeframe, bullishEngulf(), lookahead=barmerge.lookahead_off)
engulf_bear_htf = request.security(syminfo.tickerid, data_timeframe, bearishEngulf(), lookahead=barmerge.lookahead_off)
gap_bull_htf = request.security(syminfo.tickerid, data_timeframe, bullishGapFill(), lookahead=barmerge.lookahead_off)
gap_bear_htf = request.security(syminfo.tickerid, data_timeframe, bearishGapFill(), lookahead=barmerge.lookahead_off)
hammer_bull_htf = request.security(syminfo.tickerid, data_timeframe, isHammer() and close > open, lookahead=barmerge.lookahead_off)
hammer_bear_htf = request.security(syminfo.tickerid, data_timeframe, isShootingStar() and close < open, lookahead=barmerge.lookahead_off)
three_bull_htf = request.security(syminfo.tickerid, data_timeframe, bullishThreeBar(), lookahead=barmerge.lookahead_off)
three_bear_htf = request.security(syminfo.tickerid, data_timeframe, bearishThreeBar(), lookahead=barmerge.lookahead_off)

// Individual patterns for current timeframe signals - use confirmed bars only
ebp_bull = isBullishSweep()
ebp_bear = isBearishSweep()
inside_bull = bullishInsideBreak()
inside_bear = bearishInsideBreak()
engulf_bull = bullishEngulf()
engulf_bear = bearishEngulf()
gap_bull = bullishGapFill()
gap_bear = bearishGapFill()
hammer_bull = isHammer() and close > open
hammer_bear = isShootingStar() and close < open
three_bull = bullishThreeBar()
three_bear = bearishThreeBar()

// Basic patterns from selected timeframe for tables
bull_close_above_htf = request.security(syminfo.tickerid, data_timeframe, close > high[1], lookahead=barmerge.lookahead_off)
bear_close_below_htf = request.security(syminfo.tickerid, data_timeframe, close < low[1], lookahead=barmerge.lookahead_off)
bull_sweep_htf = request.security(syminfo.tickerid, data_timeframe, low < low[1] and open >= low[1] and open <= high[1] and close > low[1], lookahead=barmerge.lookahead_off)
bear_sweep_htf = request.security(syminfo.tickerid, data_timeframe, high > high[1] and open >= low[1] and open <= high[1] and close < high[1], lookahead=barmerge.lookahead_off)

// Basic patterns for current timeframe signals - use confirmed bars only
bull_close_above = close > high[1]
bear_close_below = close < low[1]
bull_sweep = low < low[1] and open >= low[1] and open <= high[1] and close > low[1]
bear_sweep = high > high[1] and open >= low[1] and open <= high[1] and close < high[1]

// Statistics arrays - persistent storage
var array<int> signals = array.new<int>(106, 0)
var array<int> success = array.new<int>(106, 0)

// Markov Chain Variables
var array<int> pattern_sequence = array.new<int>()
var array<float> regime_history = array.new<float>()
var array<float> success_rate_history = array.new<float>()
var int current_regime = 0  // 0=Ranging, 1=Trending, 2=Transition
var float regime_confidence = 0.0
var float regime_score = 0.0
var array<float> sequence_multipliers = array.new<float>()
var array<float> regime_multipliers = array.new<float>()
var bool avoid_trading = false
var int current_pattern = -1
var float regime_stability = 0.0
var bool regime_changed = false
var color candle_color = na

// Pattern Sequence Tracking
var array<string> sequence_keys = array.new<string>()  // "0-1", "1-2", etc.
var array<int> sequence_signals = array.new<int>()     // Count of each sequence
var array<int> sequence_success = array.new<int>()     // Success count of each sequence
var string last_sequence_key = ""                     // Track last sequence for success checking

// Multi-Pattern Combination Tracking
var array<string> multi_combo_keys = array.new<string>()  // "0+1+2", "14+15", etc.
var array<int> multi_combo_signals = array.new<int>()
var array<int> multi_combo_success = array.new<int>()
var string last_multi_combo_key = ""

// Initialize Markov chain arrays if needed
if barstate.isfirst
    array.clear(pattern_sequence)
    array.clear(regime_history)
    array.clear(success_rate_history)
    array.clear(sequence_multipliers)
    array.clear(regime_multipliers)
    current_regime := 0
    regime_confidence := 0.0
    regime_score := 0.0
    avoid_trading := false
    current_pattern := -1
    regime_stability := 0.0
    regime_changed := false

// Markov Chain Enhancement Logic
if use_markov_enhancement
    // Regime Detection
    atr_ratio = ta.atr(14) / math.max(ta.atr(50), 0.0001)
    volume_ratio = volume / math.max(ta.sma(volume, 20), 1)
    rsi_momentum = math.abs(ta.rsi(close, 14) - 50) / 50
    
    regime_score := (atr_ratio * 0.4 + volume_ratio * 0.3 + rsi_momentum * 0.3) * regime_sensitivity
    
    // Regime Classification
    new_regime = regime_score > 1.2 ? 1 : regime_score < 0.8 ? 0 : 2
    regime_confidence := math.abs(regime_score - 1.0)
    
    // Detect regime changes
    regime_changed := current_regime != new_regime
    current_regime := new_regime
    
    // Store regime history
    array.push(regime_history, regime_score)
    if array.size(regime_history) > 50
        array.shift(regime_history)
    
    // Calculate regime stability using array values instead of ta.stdev
    if array.size(regime_history) > 10
        sum_sq_diff = 0.0
        mean_regime = 0.0
        for i = 0 to math.min(array.size(regime_history) - 1, 9)
            mean_regime += array.get(regime_history, array.size(regime_history) - 1 - i)
        mean_regime := mean_regime / 10
        
        for i = 0 to math.min(array.size(regime_history) - 1, 9)
            diff = array.get(regime_history, array.size(regime_history) - 1 - i) - mean_regime
            sum_sq_diff += diff * diff
        regime_stability := math.sqrt(sum_sq_diff / 10)
    else
        regime_stability := 0.0
    
    // Pattern sequence tracking - ALL 16 patterns
    current_pattern := -1
    if ebp_bull_htf
        current_pattern := 0
    else if inside_bull_htf
        current_pattern := 1
    else if engulf_bull_htf
        current_pattern := 2
    else if gap_bull_htf
        current_pattern := 3
    else if hammer_bull_htf
        current_pattern := 4
    else if three_bull_htf
        current_pattern := 5
    else if ebp_bear_htf
        current_pattern := 6
    else if inside_bear_htf
        current_pattern := 7
    else if engulf_bear_htf
        current_pattern := 8
    else if gap_bear_htf
        current_pattern := 9
    else if hammer_bear_htf
        current_pattern := 10
    else if three_bear_htf
        current_pattern := 11
    else if bull_close_above_htf
        current_pattern := 12
    else if bear_close_below_htf
        current_pattern := 13
    else if bull_sweep_htf
        current_pattern := 14
    else if bear_sweep_htf
        current_pattern := 15
    
    // Update pattern sequence
    if current_pattern >= 0
        should_add = false
        if array.size(pattern_sequence) == 0
            should_add := true
        else if array.get(pattern_sequence, array.size(pattern_sequence) - 1) != current_pattern
            should_add := true
        
        if should_add
            array.push(pattern_sequence, current_pattern)
            if array.size(pattern_sequence) > sequence_lookback
                array.shift(pattern_sequence)
    
    // Track pattern sequences
    if array.size(pattern_sequence) >= 2
        current_sequence_key = str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 2)) + "-" + str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1))
        
        // Check if this sequence exists in our tracking
        sequence_index = -1
        if array.size(sequence_keys) > 0
            for i = 0 to array.size(sequence_keys) - 1
                if array.get(sequence_keys, i) == current_sequence_key
                    sequence_index := i
                    break
        
        // If new sequence, add it
        if sequence_index == -1
            array.push(sequence_keys, current_sequence_key)
            array.push(sequence_signals, 1)
            array.push(sequence_success, 0)
            sequence_index := array.size(sequence_keys) - 1
        else
            // Increment signal count
            array.set(sequence_signals, sequence_index, array.get(sequence_signals, sequence_index) + 1)
        
        last_sequence_key := current_sequence_key
        
        // Track multi-pattern combinations
        active_now = array.new<int>()
        current_patterns_check = array.from(ebp_bull_htf, inside_bull_htf, engulf_bull_htf, gap_bull_htf, hammer_bull_htf, three_bull_htf,
                                           ebp_bear_htf, inside_bear_htf, engulf_bear_htf, gap_bear_htf, hammer_bear_htf, three_bear_htf,
                                           bull_close_above_htf, bear_close_below_htf, bull_sweep_htf, bear_sweep_htf)
        for i = 0 to 15
            if array.get(current_patterns_check, i)
                array.push(active_now, i)
        
        if array.size(active_now) > 1
            multi_key = ""
            for i = 0 to array.size(active_now) - 1
                multi_key += (i > 0 ? "+" : "") + str.tostring(array.get(active_now, i))
            
            // Check if exists
            multi_index = -1
            if array.size(multi_combo_keys) > 0
                for i = 0 to array.size(multi_combo_keys) - 1
                    if array.get(multi_combo_keys, i) == multi_key
                        multi_index := i
                        break
            
            if multi_index == -1
                array.push(multi_combo_keys, multi_key)
                array.push(multi_combo_signals, 1)
                array.push(multi_combo_success, 0)
                multi_index := array.size(multi_combo_keys) - 1
            else
                array.set(multi_combo_signals, multi_index, array.get(multi_combo_signals, multi_index) + 1)
            
            last_multi_combo_key := multi_key
    
    // Calculate sequence multipliers (keep existing logic for now)
    array.clear(sequence_multipliers)
    if array.size(pattern_sequence) >= 2
        last_two = str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 2)) + "-" + str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1))
        sequence_mult = switch last_two
            "0-1" => 1.15  // EBP -> Inside
            "0-2" => 1.10  // EBP -> Engulf
            "1-2" => 1.20  // Inside -> Engulf
            "2-0" => 0.95  // Engulf -> EBP
            "4-5" => 1.25  // Hammer -> 3Bar
            => 1.0
        array.push(sequence_multipliers, sequence_mult)
    else
        array.push(sequence_multipliers, 1.0)
    
    // Calculate regime multipliers
    array.clear(regime_multipliers)
    regime_mult = switch current_regime
        0 => 0.85  // Ranging - patterns less reliable
        1 => 1.25  // Trending - patterns more reliable
        2 => 0.70  // Transition - patterns unreliable
        => 1.0
    array.push(regime_multipliers, regime_mult)
    
    // Determine if should avoid trading
    avoid_trading := avoid_transition_trades and (current_regime == 2 or regime_stability > 0.3 or regime_changed)

// HTF combinations for table data
combo_1_htf = ebp_bull_htf and inside_bull_htf
combo_2_htf = ebp_bull_htf and engulf_bull_htf
combo_3_htf = ebp_bull_htf and gap_bull_htf
combo_4_htf = ebp_bull_htf and hammer_bull_htf
combo_5_htf = ebp_bull_htf and three_bull_htf
combo_6_htf = inside_bull_htf and engulf_bull_htf
combo_7_htf = inside_bull_htf and gap_bull_htf
combo_8_htf = inside_bull_htf and hammer_bull_htf
combo_9_htf = inside_bull_htf and three_bull_htf
combo_10_htf = engulf_bull_htf and gap_bull_htf
combo_11_htf = engulf_bull_htf and hammer_bull_htf
combo_12_htf = engulf_bull_htf and three_bull_htf
combo_13_htf = gap_bull_htf and hammer_bull_htf
combo_14_htf = gap_bull_htf and three_bull_htf
combo_15_htf = hammer_bull_htf and three_bull_htf
combo_16_htf = ebp_bear_htf and inside_bear_htf
combo_17_htf = ebp_bear_htf and engulf_bear_htf
combo_18_htf = ebp_bear_htf and gap_bear_htf
combo_19_htf = ebp_bear_htf and hammer_bear_htf
combo_20_htf = ebp_bear_htf and three_bear_htf

// Count signals and success
patterns = array.from(ebp_bull_htf, inside_bull_htf, engulf_bull_htf, gap_bull_htf, hammer_bull_htf, three_bull_htf,
                     ebp_bear_htf, inside_bear_htf, engulf_bear_htf, gap_bear_htf, hammer_bear_htf, three_bear_htf,
                     bull_close_above_htf, bear_close_below_htf, bull_sweep_htf, bear_sweep_htf,
                     combo_1_htf, combo_2_htf, combo_3_htf, combo_4_htf, combo_5_htf, combo_6_htf, combo_7_htf, combo_8_htf, combo_9_htf, combo_10_htf,
                     combo_11_htf, combo_12_htf, combo_13_htf, combo_14_htf, combo_15_htf, combo_16_htf, combo_17_htf, combo_18_htf, combo_19_htf, combo_20_htf)

// Always count signals but only when patterns change
for i = 0 to 35
    if array.get(patterns, i) and not array.get(patterns, i)[1]
        array.set(signals, i, array.get(signals, i) + 1)

// Check success on next bar
// Get HTF success data
htf_high_data = request.security(syminfo.tickerid, data_timeframe, high, lookahead=barmerge.lookahead_off)
htf_low_data = request.security(syminfo.tickerid, data_timeframe, low, lookahead=barmerge.lookahead_off)
htf_high_prev = request.security(syminfo.tickerid, data_timeframe, high[1], lookahead=barmerge.lookahead_off)
htf_low_prev = request.security(syminfo.tickerid, data_timeframe, low[1], lookahead=barmerge.lookahead_off)

patterns_prev = array.from(ebp_bull_htf[1], inside_bull_htf[1], engulf_bull_htf[1], gap_bull_htf[1], hammer_bull_htf[1], three_bull_htf[1],
                          ebp_bear_htf[1], inside_bear_htf[1], engulf_bear_htf[1], gap_bear_htf[1], hammer_bear_htf[1], three_bear_htf[1],
                          bull_close_above_htf[1], bear_close_below_htf[1], bull_sweep_htf[1], bear_sweep_htf[1],
                          combo_1_htf[1], combo_2_htf[1], combo_3_htf[1], combo_4_htf[1], combo_5_htf[1], combo_6_htf[1], combo_7_htf[1], combo_8_htf[1], combo_9_htf[1], combo_10_htf[1],
                          combo_11_htf[1], combo_12_htf[1], combo_13_htf[1], combo_14_htf[1], combo_15_htf[1], combo_16_htf[1], combo_17_htf[1], combo_18_htf[1], combo_19_htf[1], combo_20_htf[1])

// Always check success
for i = 0 to 35
    if array.get(patterns_prev, i)
        // Success conditions - all patterns need high > high[1] for bull success, low < low[1] for bear success
        success_condition = false
        
        // Bull patterns (indices 0-5, 12, 14, 16-25) - success when high > high[1]
        if i < 6 or i == 12 or i == 14 or (i >= 16 and i <= 25)
            success_condition := htf_high_data > htf_high_prev
        // Bear patterns (indices 6-11, 13, 15, 26-35) - success when low < low[1]  
        else if (i >= 6 and i <= 11) or i == 13 or i == 15 or (i >= 26 and i <= 35)
            success_condition := htf_low_data < htf_low_prev
        
        if success_condition
            array.set(success, i, array.get(success, i) + 1)
            
            // Track sequence success
            if last_sequence_key != ""
                for j = 0 to array.size(sequence_keys) - 1
                    if array.get(sequence_keys, j) == last_sequence_key
                        array.set(sequence_success, j, array.get(sequence_success, j) + 1)
                        break
            
            // Track multi-combo success
            if last_multi_combo_key != ""
                for j = 0 to array.size(multi_combo_keys) - 1
                    if array.get(multi_combo_keys, j) == last_multi_combo_key
                        array.set(multi_combo_success, j, array.get(multi_combo_success, j) + 1)
                        break

// Get Sequence Success Rate
getSequenceSuccessRate(sequence_key) =>
    if sequence_key == ""
        0.0
    else
        for i = 0 to array.size(sequence_keys) - 1
            if array.get(sequence_keys, i) == sequence_key
                signals_count = array.get(sequence_signals, i)
                success_count = array.get(sequence_success, i)
                // Cap success count to never exceed signals count
                capped_success = math.min(success_count, signals_count)
                result = signals_count > 0 ? (capped_success / signals_count) * 100 : 0.0
                // Cap final result at 100%
                math.min(result, 100.0)
        0.0

// Enhanced Probability Calculation Function
getEnhancedProbability(base_rate, pattern_index) =>
    if not use_markov_enhancement or base_rate == 0
        base_rate
    else
        // Get current sequence rate if available
        current_sequence = array.size(pattern_sequence) >= 2 ? str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 2)) + "-" + str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1)) : ""
        sequence_rate = getSequenceSuccessRate(current_sequence)
        
        // Use sequence rate if we have enough data (>5 occurrences), otherwise use enhanced base rate
        if sequence_rate > 0 and current_sequence != ""
            sequence_signals_count = 0
            for i = 0 to array.size(sequence_keys) - 1
                if array.get(sequence_keys, i) == current_sequence
                    sequence_signals_count := array.get(sequence_signals, i)
                    break
            
            if sequence_signals_count >= 5
                // Use actual sequence success rate with regime adjustment
                regime_mult = array.size(regime_multipliers) > 0 ? array.get(regime_multipliers, 0) : 1.0
                enhanced_rate = sequence_rate * math.min(math.max(regime_mult, 0.9), 1.1)
                math.min(enhanced_rate, 95.0)
        
        // Fallback to original enhancement
        sequence_mult = array.size(sequence_multipliers) > 0 ? array.get(sequence_multipliers, 0) : 1.0
        regime_mult = array.size(regime_multipliers) > 0 ? array.get(regime_multipliers, 0) : 1.0
        total_mult = math.min(math.max(sequence_mult * regime_mult, 0.8), 1.2)
        enhanced_rate = base_rate * total_mult
        math.min(enhanced_rate, 95.0)

// Pattern names
names = array.from("EBP-Bull", "Inside-Bull", "Engulf-Bull", "Gap-Bull", "Hammer-Bull", "3-Bar-Bull",
                  "EBP-Bear", "Inside-Bear", "Engulf-Bear", "Gap-Bear", "Hammer-Bear", "3-Bar-Bear",
                  "Close-Above", "Close-Below", "Bull-Sweep", "Bear-Sweep",
                  "EBP+Inside", "EBP+Engulf", "EBP+Gap", "EBP+Hammer", "EBP+3Bar", "Inside+Engulf", "Inside+Gap", "Inside+Hammer", "Inside+3Bar", "Engulf+Gap",
                  "Engulf+Hammer", "Engulf+3Bar", "Gap+Hammer", "Gap+3Bar", "Hammer+3Bar", "EBP-Bear+Inside-Bear", "EBP-Bear+Engulf-Bear", "EBP-Bear+Gap-Bear", "EBP-Bear+Hammer-Bear", "EBP-Bear+3Bar-Bear")

// Create table
var table stats_table = na
if barstate.islast
    stats_font_size = switch stats_text_size
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.small
    
    // Always show stats table
    pattern_enabled = array.from(show_ebp, show_inside, show_engulf, show_gap, show_hammer, show_three, true, true, true, true)
    enabled_count = 0
    for i = 0 to 9
        if array.get(pattern_enabled, i)
            enabled_count += 1
    
    if enabled_count > 0
        has_current_signal = show_current_tf_signals and (ebp_bull_htf or inside_bull_htf or engulf_bull_htf or gap_bull_htf or hammer_bull_htf or three_bull_htf or ebp_bear_htf or inside_bear_htf or engulf_bear_htf or gap_bear_htf or hammer_bear_htf or three_bear_htf or bull_close_above_htf or bear_close_below_htf or bull_sweep_htf or bear_sweep_htf)
        table_rows = has_current_signal ? enabled_count + 4 : enabled_count + 2
        stats_table := table.new(position.top_right, 4, table_rows, bgcolor=stats_bg_color, border_width=1)
        
        table.cell(stats_table, 0, 0, "Pattern", text_color=stats_text_color, bgcolor=stats_header_color, text_size=stats_font_size)
        table.cell(stats_table, 1, 0, "Bull %", text_color=stats_text_color, bgcolor=stats_header_color, text_size=stats_font_size)
        table.cell(stats_table, 2, 0, "Bear %", text_color=stats_text_color, bgcolor=stats_header_color, text_size=stats_font_size)
        table.cell(stats_table, 3, 0, "Total", text_color=stats_text_color, bgcolor=stats_header_color, text_size=stats_font_size)
        
        individual_names = array.from("EBP", "Inside", "Engulf", "Gap", "Hammer", "3-Bar", "Close-Above", "Close-Below", "Bull-Sweep", "Bear-Sweep")
        row = 1
        for i = 0 to 9
            if array.get(pattern_enabled, i)
                if i < 6
                    // Original patterns with bull/bear pairs
                    bull_total = array.get(signals, i)
                    bear_total = array.get(signals, i + 6)
                    bull_rate = bull_total > 0 ? (array.get(success, i) / bull_total) * 100 : 0
                    bear_rate = bear_total > 0 ? (array.get(success, i + 6) / bear_total) * 100 : 0
                    
                    // Apply Markov enhancement
                    enhanced_bull_rate = use_markov_enhancement and show_enhanced_probabilities ? getEnhancedProbability(bull_rate, i) : bull_rate
                    enhanced_bear_rate = use_markov_enhancement and show_enhanced_probabilities ? getEnhancedProbability(bear_rate, i + 6) : bear_rate
                    
                    table.cell(stats_table, 0, row, array.get(individual_names, i), text_color=stats_text_color, text_size=stats_font_size)
                    
                    bull_display = show_enhanced_probabilities and use_markov_enhancement ? str.tostring(enhanced_bull_rate, "#.#") + "%" + (enhanced_bull_rate != bull_rate ? "*" : "") : str.tostring(bull_rate, "#.#") + "%"
                    bear_display = show_enhanced_probabilities and use_markov_enhancement ? str.tostring(enhanced_bear_rate, "#.#") + "%" + (enhanced_bear_rate != bear_rate ? "*" : "") : str.tostring(bear_rate, "#.#") + "%"
                    
                    table.cell(stats_table, 1, row, bull_display, text_color=stats_bull_color, text_size=stats_font_size)
                    table.cell(stats_table, 2, row, bear_display, text_color=stats_bear_color, text_size=stats_font_size)
                    table.cell(stats_table, 3, row, str.tostring(bull_total + bear_total), text_color=stats_text_color, text_size=stats_font_size)
                else
                    // Basic patterns - treat like original patterns
                    pattern_index = i + 6  // Maps to indices 12-15
                    pattern_total = array.get(signals, pattern_index)
                    pattern_rate = pattern_total > 0 ? (array.get(success, pattern_index) / pattern_total) * 100 : 0
                    
                    // Apply Markov enhancement
                    enhanced_pattern_rate = use_markov_enhancement and show_enhanced_probabilities ? getEnhancedProbability(pattern_rate, pattern_index) : pattern_rate
                    
                    table.cell(stats_table, 0, row, array.get(individual_names, i), text_color=stats_text_color, text_size=stats_font_size)
                    
                    pattern_display = show_enhanced_probabilities and use_markov_enhancement ? str.tostring(enhanced_pattern_rate, "#.#") + "%" + (enhanced_pattern_rate != pattern_rate ? "*" : "") : str.tostring(pattern_rate, "#.#") + "%"
                    
                    // Show in appropriate column based on pattern type
                    if i == 6 or i == 8  // Close-Above, Bull-Sweep (bull patterns)
                        table.cell(stats_table, 1, row, pattern_display, text_color=stats_bull_color, text_size=stats_font_size)
                        table.cell(stats_table, 2, row, "-", text_color=stats_text_color, text_size=stats_font_size)
                    else  // Close-Below, Bear-Sweep (bear patterns)
                        table.cell(stats_table, 1, row, "-", text_color=stats_text_color, text_size=stats_font_size)
                        table.cell(stats_table, 2, row, pattern_display, text_color=stats_bear_color, text_size=stats_font_size)
                    
                    table.cell(stats_table, 3, row, str.tostring(pattern_total), text_color=stats_text_color, text_size=stats_font_size)
                row += 1
        
        table.cell(stats_table, 0, enabled_count + 1, "Data: " + data_timeframe, text_color=stats_text_color, bgcolor=stats_timeframe_color, text_size=stats_font_size)
        
        // Add Markov Chain info if enabled
        if use_markov_enhancement and show_regime_info
            regime_text = switch current_regime
                0 => "RANGING"
                1 => "TRENDING" 
                2 => "TRANSITION"
                => "UNKNOWN"
            
            regime_color = switch current_regime
                0 => color.orange
                1 => color.green
                2 => color.red
                => color.gray
            
            table.cell(stats_table, 1, enabled_count + 1, regime_text, text_color=color.white, bgcolor=regime_color, text_size=stats_font_size)
            table.cell(stats_table, 2, enabled_count + 1, str.tostring(regime_confidence, "#.##"), text_color=stats_text_color, text_size=stats_font_size)
            
            if avoid_trading
                table.cell(stats_table, 3, enabled_count + 1, "⚠️ AVOID", text_color=color.white, bgcolor=color.red, text_size=stats_font_size)
            else
                table.cell(stats_table, 3, enabled_count + 1, "✅ TRADE", text_color=color.white, bgcolor=color.green, text_size=stats_font_size)

// Combinations table
var table combo_table = na
if barstate.islast and show_combinations
    combo_count = 0
    for i = 16 to 35
        total = array.get(signals, i)
        rate = total > 0 ? (array.get(success, i) / total) * 100 : 0
        if total >= min_occurrences and rate >= min_success_rate
            combo_count += 1
    
    if combo_count > 0
        combo_table := table.new(position.middle_right, 3, combo_count + 1, bgcolor=stats_bg_color, border_width=1)
        
        table.cell(combo_table, 0, 0, "Combination", text_color=stats_text_color, bgcolor=stats_header_color, text_size=size.small)
        table.cell(combo_table, 1, 0, "Success %", text_color=stats_text_color, bgcolor=stats_header_color, text_size=size.small)
        table.cell(combo_table, 2, 0, "Total", text_color=stats_text_color, bgcolor=stats_header_color, text_size=size.small)
        
        row = 1
        for i = 16 to 35
            total = array.get(signals, i)
            rate = total > 0 ? (array.get(success, i) / total) * 100 : 0
            if total >= min_occurrences and rate >= min_success_rate
                table.cell(combo_table, 0, row, array.get(names, i), text_color=stats_text_color, text_size=size.small)
                table.cell(combo_table, 1, row, str.tostring(rate, "#.#") + "%", text_color=rate > 50 ? stats_bull_color : stats_bear_color, text_size=size.small)
                table.cell(combo_table, 2, row, str.tostring(total), text_color=stats_text_color, text_size=size.small)
                row += 1

// Opportunity Table
var table opportunity_table = na
if barstate.islast
    opp_header_font_size = switch opp_header_size
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.normal
    
    opp_font_size = switch opp_text_size
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.small
    
    // Check for ALL current patterns
    current_patterns = array.new<string>()
    current_success_rates = array.new<float>()
    
    // Get ALL active patterns from PREVIOUS completed bar
    pattern_checks = array.from(ebp_bull_htf[1], inside_bull_htf[1], engulf_bull_htf[1], gap_bull_htf[1], hammer_bull_htf[1], three_bull_htf[1],
                               ebp_bear_htf[1], inside_bear_htf[1], engulf_bear_htf[1], gap_bear_htf[1], hammer_bear_htf[1], three_bear_htf[1],
                               bull_close_above_htf[1], bear_close_below_htf[1], bull_sweep_htf[1], bear_sweep_htf[1])
    
    // Collect active pattern indices
    active_patterns = array.new<int>()
    for i = 0 to 15
        if array.get(pattern_checks, i)
            array.push(active_patterns, i)
    
    // Add individual patterns
    if array.size(active_patterns) > 0
        for i = 0 to array.size(active_patterns) - 1
            pattern_idx = array.get(active_patterns, i)
            pattern_name = array.get(names, pattern_idx)
            pattern_total = array.get(signals, pattern_idx)
            pattern_rate = pattern_total > 0 ? (array.get(success, pattern_idx) / pattern_total) * 100 : 0
            enhanced_rate = use_markov_enhancement ? getEnhancedProbability(pattern_rate, pattern_idx) : pattern_rate
            array.push(current_patterns, pattern_name)
            array.push(current_success_rates, enhanced_rate)
    
    // Add multi-pattern combinations if multiple patterns active
    if array.size(active_patterns) > 1
        combo_key = ""
        combo_name = ""
        for i = 0 to array.size(active_patterns) - 1
            pattern_idx = array.get(active_patterns, i)
            combo_key += (i > 0 ? "+" : "") + str.tostring(pattern_idx)
            combo_name += (i > 0 ? "+" : "") + array.get(names, pattern_idx)
        
        // Check if this multi-combo exists in tracking
        multi_combo_rate = 0.0
        for j = 0 to array.size(multi_combo_keys) - 1
            if array.get(multi_combo_keys, j) == combo_key
                combo_signals_count = array.get(multi_combo_signals, j)
                combo_success_count = array.get(multi_combo_success, j)
                capped_combo_success = math.min(combo_success_count, combo_signals_count)
                multi_combo_rate := combo_signals_count > 0 ? (capped_combo_success / combo_signals_count) * 100 : 0
                multi_combo_rate := math.min(multi_combo_rate, 100.0)
                break
        
        if multi_combo_rate > 0
            array.push(current_patterns, combo_name + " (MULTI)")
            array.push(current_success_rates, multi_combo_rate)
    
    // Check ALL combinations from PREVIOUS completed bar
    combo_checks = array.from(combo_1_htf[1], combo_2_htf[1], combo_3_htf[1], combo_4_htf[1], combo_5_htf[1], combo_6_htf[1], combo_7_htf[1], combo_8_htf[1], combo_9_htf[1], combo_10_htf[1],
                             combo_11_htf[1], combo_12_htf[1], combo_13_htf[1], combo_14_htf[1], combo_15_htf[1], combo_16_htf[1], combo_17_htf[1], combo_18_htf[1], combo_19_htf[1], combo_20_htf[1])
    
    for i = 0 to 19
        if array.get(combo_checks, i)
            combo_name = array.get(names, i + 16)
            combo_total = array.get(signals, i + 16)
            combo_rate = combo_total > 0 ? (array.get(success, i + 16) / combo_total) * 100 : 0
            array.push(current_patterns, combo_name)
            array.push(current_success_rates, combo_rate)
    
    // Add ALL active sequences
    if array.size(pattern_sequence) >= 2
        current_seq_key = str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 2)) + "-" + str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1))
        seq_rate = getSequenceSuccessRate(current_seq_key)
        if seq_rate > 0
            seq_parts = str.split(current_seq_key, "-")
            if array.size(seq_parts) == 2
                first_pattern = switch array.get(seq_parts, 0)
                    "0" => "EBP-Bull"
                    "1" => "Inside-Bull"
                    "2" => "Engulf-Bull"
                    "3" => "Gap-Bull"
                    "4" => "Hammer-Bull"
                    "5" => "3Bar-Bull"
                    "6" => "EBP-Bear"
                    "7" => "Inside-Bear"
                    "8" => "Engulf-Bear"
                    "9" => "Gap-Bear"
                    "10" => "Hammer-Bear"
                    "11" => "3Bar-Bear"
                    "12" => "Close-Above"
                    "13" => "Close-Below"
                    "14" => "Bull-Sweep"
                    "15" => "Bear-Sweep"
                    => "?"
                second_pattern = switch array.get(seq_parts, 1)
                    "0" => "EBP-Bull"
                    "1" => "Inside-Bull"
                    "2" => "Engulf-Bull"
                    "3" => "Gap-Bull"
                    "4" => "Hammer-Bull"
                    "5" => "3Bar-Bull"
                    "6" => "EBP-Bear"
                    "7" => "Inside-Bear"
                    "8" => "Engulf-Bear"
                    "9" => "Gap-Bear"
                    "10" => "Hammer-Bear"
                    "11" => "3Bar-Bear"
                    "12" => "Close-Above"
                    "13" => "Close-Below"
                    "14" => "Bull-Sweep"
                    "15" => "Bear-Sweep"
                    => "?"
                
                readable_seq = first_pattern + "→" + second_pattern + " (SEQ)"
                array.push(current_patterns, readable_seq)
                array.push(current_success_rates, seq_rate)
    
    pattern_count = array.size(current_patterns)
    
    // Always show table for debugging
    if true
        opportunity_table := table.new(position.bottom_right, 4, math.max(pattern_count, 1) + 3, bgcolor=opp_bg_color, border_width=1)
        
        tf_display = switch data_timeframe
            "15" => "15M"
            "60" => "1H"
            "240" => "4H"
            "1D" => "DAILY"
            => data_timeframe
        
        table.cell(opportunity_table, 0, 0, "", text_color=opp_text_color, bgcolor=opp_header_color, text_size=opp_header_font_size)
        table.cell(opportunity_table, 1, 0, "🎯 " + tf_display + " OPPORTUNITY", text_color=opp_text_color, bgcolor=opp_header_color, text_size=opp_header_font_size)
        table.cell(opportunity_table, 2, 0, "", text_color=opp_text_color, bgcolor=opp_header_color, text_size=opp_header_font_size)
        table.cell(opportunity_table, 3, 0, "", text_color=opp_text_color, bgcolor=opp_header_color, text_size=opp_header_font_size)
        
        table.cell(opportunity_table, 0, 1, "Pattern", text_color=opp_text_color, bgcolor=opp_subheader_color, text_size=opp_font_size)
        table.cell(opportunity_table, 1, 1, "Success %", text_color=opp_text_color, bgcolor=opp_subheader_color, text_size=opp_font_size)
        table.cell(opportunity_table, 2, 1, "Status", text_color=opp_text_color, bgcolor=opp_subheader_color, text_size=opp_font_size)
        table.cell(opportunity_table, 3, 1, "Points", text_color=opp_text_color, bgcolor=opp_subheader_color, text_size=opp_font_size)
        
        if pattern_count > 0
            for i = 0 to pattern_count - 1
                pattern_name = array.get(current_patterns, i)
                pattern_rate = array.get(current_success_rates, i)
                
                // Check if pattern succeeded
                is_bull_pattern = str.contains(pattern_name, "Bull")
                is_bear_pattern = str.contains(pattern_name, "Bear")
                is_recent = str.contains(pattern_name, "Recent")
                
                status_text = is_recent ? "📈 RECENT" : "📈 ACTIVE"
                status_color = opp_pending_color
                points_text = "0.0"
                
                // For current patterns, check if they succeeded
                if not is_recent
                    if is_bull_pattern and htf_high_data > htf_high_prev
                        status_text := "✅ SUCCESS"
                        status_color := opp_success_color
                        points_text := str.tostring((htf_high_data - htf_high_prev) / syminfo.mintick, "#.#")
                    else if is_bear_pattern and htf_low_data < htf_low_prev
                        status_text := "✅ SUCCESS"
                        status_color := opp_success_color
                        points_text := str.tostring((htf_low_prev - htf_low_data) / syminfo.mintick, "#.#")
                else
                    // For recent patterns, assume they already succeeded if they're showing
                    status_text := "✅ COMPLETED"
                    status_color := opp_success_color
                    points_text := "N/A"
                
                table.cell(opportunity_table, 0, i + 2, pattern_name, text_color=opp_text_color, text_size=opp_font_size)
                table.cell(opportunity_table, 1, i + 2, str.tostring(pattern_rate, "#.#") + "%", text_color=pattern_rate > 50 ? opp_success_color : opp_fail_color, text_size=opp_font_size)
                table.cell(opportunity_table, 2, i + 2, status_text, text_color=status_color, text_size=opp_font_size)
                table.cell(opportunity_table, 3, i + 2, points_text, text_color=status_color, text_size=opp_font_size)
        else
            // Debug info
            // Debug all pattern conditions
            debug_text = "Patterns: " + str.tostring(array.size(current_patterns)) + " found"
            table.cell(opportunity_table, 0, 2, "No Active Patterns", text_color=opp_text_color, text_size=opp_font_size)
            table.cell(opportunity_table, 1, 2, debug_text, text_color=opp_text_color, text_size=size.tiny)
            table.cell(opportunity_table, 2, 2, "TF:" + data_timeframe, text_color=opp_text_color, text_size=opp_font_size)
            table.cell(opportunity_table, 3, 2, "Chart:" + timeframe.period, text_color=opp_text_color, text_size=opp_font_size)

// Markov Chain Information Table
var table markov_table = na
if barstate.islast and use_markov_enhancement and show_regime_info
    markov_table := table.new(position.top_left, 2, 6, bgcolor=color.new(color.black, 80), border_width=1)
    
    table.cell(markov_table, 0, 0, "MARKOV CHAIN STATUS", text_color=color.white, bgcolor=color.new(color.blue, 50), text_size=size.normal)
    table.cell(markov_table, 1, 0, "", text_color=color.white, bgcolor=color.new(color.blue, 50), text_size=size.normal)
    
    regime_name = switch current_regime
        0 => "RANGING"
        1 => "TRENDING"
        2 => "TRANSITION"
        => "UNKNOWN"
    
    regime_color = switch current_regime
        0 => color.orange
        1 => color.green
        2 => color.red
        => color.gray
    
    table.cell(markov_table, 0, 1, "Current Regime:", text_color=color.white, text_size=size.small)
    table.cell(markov_table, 1, 1, regime_name, text_color=color.white, bgcolor=regime_color, text_size=size.small)
    
    table.cell(markov_table, 0, 2, "Confidence:", text_color=color.white, text_size=size.small)
    table.cell(markov_table, 1, 2, str.tostring(regime_confidence, "#.##"), text_color=color.white, text_size=size.small)
    
    sequence_text = array.size(pattern_sequence) > 0 ? str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1)) : "None"
    table.cell(markov_table, 0, 3, "Last Pattern:", text_color=color.white, text_size=size.small)
    table.cell(markov_table, 1, 3, sequence_text, text_color=color.white, text_size=size.small)
    
    current_seq = array.size(pattern_sequence) >= 2 ? str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 2)) + "-" + str.tostring(array.get(pattern_sequence, array.size(pattern_sequence) - 1)) : "None"
    seq_rate = getSequenceSuccessRate(current_seq)
    seq_display = seq_rate > 0 ? str.tostring(seq_rate, "#.#") + "%" : "N/A"
    table.cell(markov_table, 0, 4, "Sequence Rate:", text_color=color.white, text_size=size.small)
    table.cell(markov_table, 1, 4, seq_display, text_color=color.white, text_size=size.small)
    
    table.cell(markov_table, 0, 5, "Trade Status:", text_color=color.white, text_size=size.small)
    status_text = avoid_trading ? "⚠️ AVOID" : "✅ ACTIVE"
    status_color = avoid_trading ? color.red : color.green
    table.cell(markov_table, 1, 5, status_text, text_color=color.white, bgcolor=status_color, text_size=size.small)

// Pattern Sequence Success Table
var table sequence_table = na
if barstate.islast and use_markov_enhancement and show_regime_info and array.size(sequence_keys) > 0
    sequence_table := table.new(position.middle_left, 4, math.min(array.size(sequence_keys), 10) + 1, bgcolor=color.new(color.black, 80), border_width=1)
    
    table.cell(sequence_table, 0, 0, "SEQUENCE", text_color=color.white, bgcolor=color.new(color.purple, 50), text_size=size.small)
    table.cell(sequence_table, 1, 0, "SUCCESS %", text_color=color.white, bgcolor=color.new(color.purple, 50), text_size=size.small)
    table.cell(sequence_table, 2, 0, "COUNT", text_color=color.white, bgcolor=color.new(color.purple, 50), text_size=size.small)
    table.cell(sequence_table, 3, 0, "STATUS", text_color=color.white, bgcolor=color.new(color.purple, 50), text_size=size.small)
    
    row_count = 1
    for i = 0 to math.min(array.size(sequence_keys) - 1, 9)
        seq_key = array.get(sequence_keys, i)
        seq_signals = array.get(sequence_signals, i)
        seq_success = array.get(sequence_success, i)
        capped_success = math.min(seq_success, seq_signals)
        seq_rate = seq_signals > 0 ? math.min((capped_success / seq_signals) * 100, 100.0) : 0.0
        
        // Convert sequence key to readable format
        seq_parts = str.split(seq_key, "-")
        if array.size(seq_parts) == 2
            first_pattern = switch array.get(seq_parts, 0)
                "0" => "EBP-Bull"
                "1" => "Inside-Bull"
                "2" => "Engulf-Bull"
                "3" => "Gap-Bull"
                "4" => "Hammer-Bull"
                "5" => "3Bar-Bull"
                "6" => "EBP-Bear"
                "7" => "Inside-Bear"
                "8" => "Engulf-Bear"
                "9" => "Gap-Bear"
                "10" => "Hammer-Bear"
                "11" => "3Bar-Bear"
                "12" => "Close-Above"
                "13" => "Close-Below"
                "14" => "Bull-Sweep"
                "15" => "Bear-Sweep"
                => "?"
            second_pattern = switch array.get(seq_parts, 1)
                "0" => "EBP-Bull"
                "1" => "Inside-Bull"
                "2" => "Engulf-Bull"
                "3" => "Gap-Bull"
                "4" => "Hammer-Bull"
                "5" => "3Bar-Bull"
                "6" => "EBP-Bear"
                "7" => "Inside-Bear"
                "8" => "Engulf-Bear"
                "9" => "Gap-Bear"
                "10" => "Hammer-Bear"
                "11" => "3Bar-Bear"
                "12" => "Close-Above"
                "13" => "Close-Below"
                "14" => "Bull-Sweep"
                "15" => "Bear-Sweep"
                => "?"
            
            readable_seq = first_pattern + "→" + second_pattern
            status_text = seq_signals >= 5 ? "RELIABLE" : "LEARNING"
            status_color = seq_signals >= 5 ? (seq_rate > 60 ? color.green : color.orange) : color.gray
            
            table.cell(sequence_table, 0, row_count, readable_seq, text_color=color.white, text_size=size.tiny)
            table.cell(sequence_table, 1, row_count, str.tostring(seq_rate, "#.#") + "%", text_color=seq_rate > 60 ? color.lime : color.orange, text_size=size.tiny)
            table.cell(sequence_table, 2, row_count, str.tostring(seq_signals), text_color=color.white, text_size=size.tiny)
            table.cell(sequence_table, 3, row_count, status_text, text_color=color.white, bgcolor=status_color, text_size=size.tiny)
            
            row_count += 1

// Color candles - only show when on selected data timeframe
any_bull = ebp_bull or inside_bull or engulf_bull or gap_bull or hammer_bull or three_bull or bull_close_above or bull_sweep
any_bear = ebp_bear or inside_bear or engulf_bear or gap_bear or hammer_bear or three_bear or bear_close_below or bear_sweep

// Enhanced candle coloring with regime awareness
candle_color := na
if show_candle_coloring and show_current_tf_signals
    if use_markov_enhancement and avoid_trading
        candle_color := color.gray  // Gray for avoid trading periods
    else if any_bull
        candle_color := use_markov_enhancement ? (current_regime == 1 ? color.lime : current_regime == 0 ? color.green : color.olive) : color.green
    else if any_bear
        candle_color := use_markov_enhancement ? (current_regime == 1 ? color.fuchsia : current_regime == 0 ? color.red : color.maroon) : color.red

barcolor(candle_color)

// Success/fail markers - only on selected data timeframe
bull_pattern_prev = ebp_bull[1] or inside_bull[1] or engulf_bull[1] or gap_bull[1] or hammer_bull[1] or three_bull[1] or bull_close_above[1] or bull_sweep[1]
bear_pattern_prev = ebp_bear[1] or inside_bear[1] or engulf_bear[1] or gap_bear[1] or hammer_bear[1] or three_bear[1] or bear_close_below[1] or bear_sweep[1]

bull_success_mark = show_success_markers and show_current_tf_signals and bull_pattern_prev and high > high[1] and barstate.isconfirmed
bull_fail_mark = show_success_markers and show_current_tf_signals and bull_pattern_prev and high <= high[1] and barstate.isconfirmed
bear_success_mark = show_success_markers and show_current_tf_signals and bear_pattern_prev and low < low[1] and barstate.isconfirmed
bear_fail_mark = show_success_markers and show_current_tf_signals and bear_pattern_prev and low >= low[1] and barstate.isconfirmed

// Offset markers to avoid overlap with labels - only show on allowed timeframes
plotshape(bull_success_mark and show_current_tf_signals, "Bull Success", shape.triangleup, location.belowbar, color.lime, size=size.tiny, offset=-1)
plotshape(bull_fail_mark and show_current_tf_signals, "Bull Fail", shape.xcross, location.belowbar, color.orange, size=size.tiny, offset=-1)
plotshape(bear_success_mark and show_current_tf_signals, "Bear Success", shape.triangledown, location.abovebar, color.lime, size=size.tiny, offset=-1)
plotshape(bear_fail_mark and show_current_tf_signals, "Bear Fail", shape.xcross, location.abovebar, color.orange, size=size.tiny, offset=-1)

// Pattern labels - only show when on selected data timeframe and bar is confirmed
if show_pattern_labels and show_current_tf_signals and barstate.isconfirmed
    bull_label_text = ""
    bear_label_text = ""
    
    if ebp_bull
        bull_label_text += "EBP\n"
    if inside_bull
        bull_label_text += "Inside\n"
    if engulf_bull
        bull_label_text += "Engulf\n"
    if gap_bull
        bull_label_text += "Gap\n"
    if hammer_bull
        bull_label_text += "Hammer\n"
    if three_bull
        bull_label_text += "3-Bar\n"
    if bull_close_above
        bull_label_text += "Close-Above\n"
    if bull_sweep
        bull_label_text += "Bull-Sweep\n"
    
    if str.length(bull_label_text) > 0
        bull_label_text := str.substring(bull_label_text, 0, str.length(bull_label_text) - 1)
        label.new(bar_index, low * 0.9999, bull_label_text, style=label.style_label_up, color=bull_label_bg, textcolor=label_text_color, size=size.small)
    
    if ebp_bear
        bear_label_text += "EBP\n"
    if inside_bear
        bear_label_text += "Inside\n"
    if engulf_bear
        bear_label_text += "Engulf\n"
    if gap_bear
        bear_label_text += "Gap\n"
    if hammer_bear
        bear_label_text += "Shoot\n"
    if three_bear
        bear_label_text += "3-Bar\n"
    if bear_close_below
        bear_label_text += "Close-Below\n"
    if bear_sweep
        bear_label_text += "Bear-Sweep\n"
    
    if str.length(bear_label_text) > 0
        bear_label_text := str.substring(bear_label_text, 0, str.length(bear_label_text) - 1)
        label.new(bar_index, high * 1.0001, bear_label_text, style=label.style_label_down, color=bear_label_bg, textcolor=label_text_color, size=size.small)

// Markov Chain Alerts and Visualizations
if use_markov_enhancement
    // Regime change alerts
    if regime_changed and barstate.isconfirmed
        regime_text = switch current_regime
            0 => "REGIME: RANGING"
            1 => "REGIME: TRENDING"
            2 => "REGIME: TRANSITION"
            => "REGIME: UNKNOWN"
        
        regime_alert_color = switch current_regime
            0 => color.orange
            1 => color.green
            2 => color.red
            => color.gray
        
        label.new(bar_index, high * 1.002, regime_text, color=regime_alert_color, textcolor=color.white, style=label.style_label_down, size=size.small)
    
    // High confidence pattern alerts
    if show_pattern_labels and show_current_tf_signals and barstate.isconfirmed
        if any_bull or any_bear
            seq_mult = array.size(sequence_multipliers) > 0 ? array.get(sequence_multipliers, 0) : 1.0
            reg_mult = array.size(regime_multipliers) > 0 ? array.get(regime_multipliers, 0) : 1.0
            pattern_confidence = seq_mult * reg_mult
            if pattern_confidence > 1.3  // High confidence threshold
                confidence_text = "HIGH CONF: " + str.tostring(pattern_confidence, "#.##") + "x"
                label.new(bar_index, low * 0.998, confidence_text, color=color.yellow, textcolor=color.black, style=label.style_label_up, size=size.tiny)

// Current timeframe combinations for visual signals
combo_1 = ebp_bull and inside_bull
combo_2 = ebp_bull and engulf_bull
combo_3 = ebp_bull and gap_bull
combo_4 = ebp_bull and hammer_bull
combo_5 = ebp_bull and three_bull
combo_6 = inside_bull and engulf_bull
combo_7 = inside_bull and gap_bull
combo_8 = inside_bull and hammer_bull
combo_9 = inside_bull and three_bull
combo_10 = engulf_bull and gap_bull
combo_11 = engulf_bull and hammer_bull
combo_12 = engulf_bull and three_bull
combo_13 = gap_bull and hammer_bull
combo_14 = gap_bull and three_bull
combo_15 = hammer_bull and three_bull
combo_16 = ebp_bear and inside_bear
combo_17 = ebp_bear and engulf_bear
combo_18 = ebp_bear and gap_bear
combo_19 = ebp_bear and hammer_bear
combo_20 = ebp_bear and three_bear

// Plot regime score for debugging (optional)
// plot(use_markov_enhancement ? regime_score : na, title="Regime Score", color=color.blue, display=display.none)